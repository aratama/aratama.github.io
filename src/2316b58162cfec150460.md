<!-- {
  "id": "2316b58162cfec150460",
  "created_at": "2016-09-16T02:11:58+09:00",
  "tags": [
    {
      "name": "JavaScript",
      "versions": []
    },
    {
      "name": "Haskell",
      "versions": []
    },
    {
      "name": "purescript",
      "versions": []
    },
    {
      "name": "関数型プログラミング",
      "versions": []
    }
  ],
  "title": "純粋関数型スクリプト言語PureScriptのはじめかた。コンパイラの使いかたからサーバサイド/クライアントサイドアプリケーション開発まで",
  "pinned": true
} -->
# はじめに

<blockquote class="twitter-tweet" data-lang="ja"><p lang="en" dir="ltr">&quot;PureScript is more like Haskell than Haskell itself.&quot; – `<a href="https://twitter.com/thebeardedzug">@thebeardedzug</a></p>&mdash; Rahul Goma Phulore (@missingfaktor) <a href="https://twitter.com/missingfaktor/status/845400837841195009">2017年3月24日</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

スクリプト言語**[PureScript](http://www.purescript.org/)**の開発環境構築手順を紹介します。PureScriptには**AltJS**としての側面があり、ブラウザ環境やNode環境での実行が主眼に置かれており、JavaScriptでは難しかった大規模な開発に耐えうる極めて高い堅牢性や可読性を備えています。また、JavaScriptに変換されるため、膨大なJavaScriptの資産を比較的簡単に活用できるほか、PureScriptのソースコードとそこから出力されるJavaScriptコードを対比させながら学べるという利点もあります。

PureScriptは最高級の機能を備える**関数型プログラミング言語**としての側面も持ちます。関数型プログラミング言語の代名詞的存在であるHaskellは、互換性を保つためにその長い歴史の中で数々の欠陥を抱え込んできました。PureScriptはHaskellのコンセプトを更に洗練して、新規の言語としてすべてを作り直すもので、**PureScriptはHaskellよりもHaskellらしい**とすら言われることもあります。しかも、Haskellの最大の難点であった『遅延評価』を取り除くことで、Haskellに習熟していない開発者でも馴染みやすい言語仕様になっています。

この記事では、Nodeのコマンドライン環境のような基本的なターゲットだけではなく、ウェブのシングルページアプリケーションのような実用性の高いアプリケーションを作って試せるように、Halogenというユーザインターフェイスのフレームワークや、Hyperというサーバサイドフレームワークを動かすところまでを紹介します。ブラウザ環境で動けば、ウェブページに組み込んで自分が作ったアプリケーションを簡単に他の人に見せられますし、[Electron](http://electron.atom.io/)を使って単独で動くウィンドウアプリケーションなんかも作ることができるなど夢が広がりますね。

## 前提となる知識

* HTML/CSS/JavaScript
* Node環境でのJavaScript開発。CommonJSモジュール
* パッケージマネージャ。NPM/Bower
* Browserify(Webpack/Rollup)
* reactに代表される仮想DOMの概要

nodeやbower、browserifyといった基本的なツールは、予めインストールしておいてください。ここに挙げられているものでよく知らないものがあれば、先に簡単に調べておきましょう。







# Node環境での開発

まずは一番シンプルに、Nodeのコマンドライン環境でPureScriptコードを動かすところまで説明します。

## コンパイラのインストール

何をするにも、まずはコンパイラが必要です。nodeがインストールしてあれば、最新版のコンパイラをインストールするには次のコマンド一発だけです。

```bash
$ npm install -g purescript
```

## ソースファイルの作成 

HelloWorldのソースファイルを作成しましょう。新しいプロジェクトのために適当なディレクトリを作成して、そこに`src/Main.purs`というファイルを作成し、次のようなコードをコピペして保存してください。PureScriptソースファイルの拡張子は`.purs`を使います。

```haskell:src/Main.purs
module Main where

import Prelude
import Control.Monad.Eff (Eff)
import Control.Monad.Eff.Console (CONSOLE, log)

main :: Eff (console :: CONSOLE) Unit
main = log "Hello, world!"
```


## PureScriptパッケージのインストール

PureScriptコンパイラには一切のライブラリが付属しておらず、コンパイラのみでは標準出力はおろか足し算すらできません。すべてのライブラリがコンパイラから完全に分離されているので、まずはプロジェクトにbowerで必要なPureScriptパッケージをインストールしなければなりません。標準出力を行うには[`purescript-console`パッケージ](https://pursuit.purescript.org/packages/purescript-console)を使いますので、インストールしておきましょう。`bower install`でパッケージ名を指定するだけです。


```bash
$ bower install --save purescript-console
```

このように、プロジェクトで必要になるたびにbowerでパッケージを集めてきます。開発が進むと他にもいろいろなパッケージが欲しくなると思いますが、PureScriptのパッケージを探すには、[pursuit](https://pursuit.purescript.org/)というドキュメント検索サービスを使うか、[bowerのサイト](https://bower.io/search/)で"purescript"というキーワードで検索するといいと思います。bowerに登録されていないライブラリも結構あるので、[githubで探してみる](https://github.com/search?utf8=%E2%9C%93&q=purescript)のもいいと思います。





## コンパイル

PureScriptのツール群は`purs`という単一の実行可能ファイルにまとめられており、この`purs`に続いて任意のコマンドを入力することでそれぞれのツールを起動します。PureScriptソースコードをコンパイルするには**`purs compile`コマンド**を実行しますが、引数にはコンパイルに必要なソースファイルのパスをすべて列挙して与えます。パスにはglobが効きますので、`purs compile "**/*.purs"`のように指定すれば、`.purs`の拡張子を持つファイルを片っ端から見つけ出してまとめてコンパイルできます。ただしそのコマンドでは、複数のパッケージをインストールした時に、テスト用のコードのモジュール名が衝突してコンパイルに失敗するケースがあります。基本的には次のようにして、`src`ディレクトリだけを対象に含めるように指定するといいと思います。

```bash
$ purs compile "bower_components/purescript-*/src/**/*.purs" "src/**/*.purs"
```

また、パスをダブルクォーテーションで囲まずに渡すと、環境によってはシェルがパスのワイルドカードを勝手に展開してしまい、それがpscのglobの挙動と微妙に異なっているためコンパイルが通らないことがありました。psc自身にglobが備わっているので、シェルにワイルドカードを展開されないようにしてください。

成功すれば、`output`ディレクトリ以下にコンパイルされたJavaScriptコードが出力されているはずです。例として、`Main.purs`がコンパイルされた結果の`output/Main/index.js`を掲載しておきます。

```js:output/Main/index.js
// Generated by psc version 0.10.5
"use strict";
var Prelude = require("../Prelude");
var Control_Monad_Eff = require("../Control.Monad.Eff");
var Control_Monad_Eff_Console = require("../Control.Monad.Eff.Console");
var main = Control_Monad_Eff_Console.log("Hello, world!");
module.exports = {
    main: main
};
```

## Node環境でHelloWorld

コンパイルされて出力されたJavaScriptソースファイルはCommonJSモジュールになっているので、JavaScriptで直接書かれた通常のモジュールのように扱うことができます。例えば次のようにすればNode環境で先ほどのHelloWorldを実行することができます。

```bash
$ node
> const Main = require('./output/Main/index')
undefined
> Main.main()
Hello, world!
{}
```











# Hyperによるサーバーサイドアプリケーションの開発

次は、[**Hyper**](https://github.com/owickstrom/hyper)というかなり本格的なサーバサイドアプリケーション開発用のライブラリを使って、アクセスすると`Hello`とだけ返す簡単なサーバサイドウェブアプリケーションを作ってみましょう。サンプルコードを[こちら](https://github.com/owickstrom/hyper/blob/master/examples/HelloHyper.purs)からコピペしてきました。

```haskell:src/Examples/HelloHyper.purs
module Examples.HelloHyper where

import Prelude
import Control.IxMonad ((:*>))
import Control.Monad.Eff (Eff)
import Control.Monad.Eff.Console (CONSOLE)
import Hyper.Node.Server (defaultOptionsWithLogging, runServer)
import Hyper.Response (closeHeaders, respond, writeStatus)
import Hyper.Status (statusOK)
import Node.HTTP (HTTP)

main :: forall e. Eff (console :: CONSOLE, http :: HTTP | e) Unit
main =
  let app = writeStatus statusOK
            :*> closeHeaders
            :*> respond "Hello, Hyper!"
  in runServer defaultOptionsWithLogging {} app
```

HyperのBowerパッケージの名前は`purescript-hyper`です。忘れないようにパッケージをインストールし、それからコンパイルして、うまく行ったら`node`でアプリケーションを起動してみましょう。起動するときはモジュールの名前を間違えないように気をつけてください。

```bash
$ bower install --save purescript-hyper
$ purs compile "bower_components/purescript-*/src/**/*.purs" "src/**/*.purs"
$ node
> const HelloHyper = require('./output/Examples.HelloHyper/index')
undefined
> HelloHyper.main()
undefined
> Listening on http://localhost:3000
```

これで、あとはブラウザで http://localhost:3000/ にアクセスすれば`Hello, Hyper!`と表示されると思います。このコンパイルで生成されたアプリケーションは、もちろんNodeが動く環境ならどんなサーバでも実行することができます。ただし、上の手順で起動するのは少々面倒なので、次のような起動用のスクリプトを用意して起動してもいいでしょう。

```js:main.js
const HelloHyper = require('./output/Examples.HelloHyper/index');
Main.main();
```

```shell-session
$ node main.js
Listening on http://localhost:3000
```

また、以降の節で紹介する`purs bundle`コマンドを使えば、すべてのモジュールを結合しつつ、単独でそのまま起動できるモジュールを作ることができます。



# ブラウザ環境での実行

次は、ブラウザ環境でPureScriptアプリケーションを実行してみましょう。ブラウザ環境ではCommonJSモジュールは直接インポート出来ませんので、`purs bundle`というコマンドを使って、事前にモジュールを単一のJavaScriptファイルへと結合しておくのがいいと思います。コードは先程のHelloWorldを再び使いましょう。

```haskell:src/Main.purs
module Main where

import Prelude
import Control.Monad.Eff (Eff)
import Control.Monad.Eff.Console (CONSOLE, log)

main :: Eff (console :: CONSOLE) Unit
main = log "Hello, world!"
```


[^browserify]: `psc`でコンパイルした結果はただのCommonJSモジュールなので、`browserify`や`webpack`で結合することもできるのですが、`psc-bundle`で結合したほうが劇的にサイズが小さくなるので、なるべく`psc-bundle`を使ったほうがいいです。

```bash
$ purs compile "bower_components/purescript-*/src/**/*.purs" "src/**/*.purs"
$ purs bundle "output/**/*.js" --module Main --main Main --output public/app.js
```

`purs bundle`コマンドのオプションは次のとおりです。

* `--module`オプションでモジュールを指定すると、そのモジュールに関連したモジュールだけが結合されます。このオプションを指定しなくても動きますが、ファイルサイズが劇的に小さくなるので指定したほうがいいです。ただし、コマンドの実行に少し時間がかかると思います
* `--output`オプションで出力先ファイルを選べます。指定しない場合は結合の結果が標準出力に垂れ流されます
* `--main`オプションでモジュールを指定すると、そのモジュールの`main`が実行されるコードが追加されます。この場合、コンパイル後のコードの最後に`PS["Main"].main();`という一行が追加されます。

短いのでコンパイル後のコードを全文掲載しておきます。

```js:public/app.js
// Generated by psc-bundle 0.11.4
var PS = {};
(function(exports) {
    "use strict";

  exports.log = function (s) {
    return function () {
      console.log(s);
      return {};
    };
  };
})(PS["Control.Monad.Eff.Console"] = PS["Control.Monad.Eff.Console"] || {});
(function(exports) {
  // Generated by purs version 0.11.4
  "use strict";
  var $foreign = PS["Control.Monad.Eff.Console"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Data_Show = PS["Data.Show"];
  var Data_Unit = PS["Data.Unit"];
  exports["log"] = $foreign.log;
})(PS["Control.Monad.Eff.Console"] = PS["Control.Monad.Eff.Console"] || {});
(function(exports) {
    "use strict";
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_Eff_Console = PS["Control.Monad.Eff.Console"];
  var Prelude = PS["Prelude"];        
  var main = Control_Monad_Eff_Console.log("Hello, world!");
  exports["main"] = main;
})(PS["Main"] = PS["Main"] || {});
PS["Main"].main();
```

これを読み込む`public/index.html`を適当に作成しておきます。

```html:public/index.html
<!doctype html>
<script src="app.js"></script>
```

`public/index.html`をブラウザで開くと、コンソールに`Hello, world!`と表示されるはずです。

`psc-bundle`で結合したコードは、もちろんNode環境でも次のようにして実行できます。

```bash
$ node public/app.js
Hello, world!
```

単体のアプリケーションを作る場合は、起動したあとでいちいち`require`を呼び出してモジュールをロードするのは面倒ですから、`purs bundle`でバンドルしてしまうのがいいと思います。


# Halogenによるクライアントサイドウェブアプリケーション開発

**注：Halogenは0.11にアップデートされたのですが、purescript-halogen-templeteのアップデートがまだです**

PureScriptのUIフレームワークでは[`purescript-halogen`](https://github.com/slamdata/purescript-halogen)というのが一番メジャーです。このフレームワークのテンプレートプロジェクト[purescript-halogen-template](https://github.com/slamdata/purescript-halogen-template)があるので、これをgitでも何でも構わないのでダウンロードしてきましょう。`my-halogen-project`のところはお好みでどうぞ。

```bash
$ git clone https://github.com/slamdata/purescript-halogen-template.git my-halogen-project
$ cd my-halogen-project
```

それから、`npm install`や`bower update`でこのテンプレートプロジェクトが依存するパッケージをかき集めます。

```bash
$ npm install --production
$ bower update
```

これができたらビルド可能になるので、先ほどと同じコマンドで`psc`を叩いてコンパイルし、それから`psc-bundle`を叩いて結合します。

```bash
$ purs compile "bower_components/purescript-*/src/**/*.purs" "src/**/*.purs"
$ purs bundle "output/**/*.js" --module Main --main Main --output dist/app.js
```

`dist/index.html`を開くと、ボタンをクリックするたびに表示が切り替わるページが表示されるのがわかると思います。あとはお好みでuglifyなんかで圧縮してもいいと思います。

```bash
$ purs bundle "output/**/*.js" --module Main --main Main | uglifyjs > dist/app.js
```

これで、PureScriptで本格的なシングルページアプリケーションを開発する準備が整いました。この記事ではコンパイラを直接叩きましたが、必要に応じてシェルスクリプトやnpmスクリプトなどで自動化しておくと楽かと思います。このHalogenというフレームワークを使ってどのようにアプリケーションを開発すればいいのかは、また別に記事を書きたいと思っています。







# ビルドタスクの自動化

先に説明したコマンドをいちいち手で打つのは面倒くさいので、筆者はnpmスクリプトに次のように書いておくことが多いです。

```text:package.json
  "scripts": {
    "prebuild": "purs compile \"bower_components/purescript-*/src/**/*.purs\" \"src/**/*.purs\"",
    "build": "purs bundle \"output/**/*.js\" --module Main --main Main --output public/index.js"
  },
```

これで、`npm run build`を実行すれば単体で実行可能なJavaScriptが`public/index.js`に出力されます。ビルド自体はコンパイラを直接叩いてもそれほど難しくはないと筆者は思うんですが、一連の作業をさらに簡略化するためにはPureScript専用のビルドツール**[pulp](https://github.com/bodil/pulp)**を導入する方法があります。これを使うとブランクなプロジェクトの作成もコマンド一発、コンパイルもコマンド一発です。たまに意味の分からないエラーが出て頭を抱えることもあるんですが、楽なのは確かです。多くのPureScriptプロジェクトで使われているので、いろんなライブラリを試したりするときにいずれ使うことになると思います。

pulpの導入自体は`npm install`で一発です。

```bash
$ npm install -g purescript pulp
```

あとは適当なディレクトリを作って、`pulp init`で空のプロジェクトが作成できます。また`pulp run`でそのプロジェクトをビルドし実行することができます。

```bash
$ pulp init
$ pulp run
```

筆者があまりpulpを使っていないのもあって、ここではこれ以上詳しい解説はしません。詳しい使い方についてはgithubのプロジェクトページなどを確認してください。




# 統合開発環境psc-ideの紹介

PureScriptのコンパイラには[psc-ide](https://github.com/purescript/purescript/tree/master/psc-ide-server)というIDE、つまり統合開発環境が付属していています。『統合開発環境』といってもVisual StudioやEclipseのようなゴッツいものではなくて、コンパイラと連携してコードの問題の修復なんかを自動的に実行するためのインターフェイスを提供するコマンドライン上で動くプログラムです。このpsc-ideを使うための拡張が各種エディタについて提供されています。

* Emacs: https://github.com/epost/psc-ide-emacs
* Atom: https://github.com/nwolverson/atom-ide-purescript
* Visual Studio Code: https://github.com/nwolverson/vscode-ide-purescript
* Vim: https://github.com/FrigoEU/psc-ide-vim

PureScriptではモジュールのインポートがとにかく面倒くさいのですが、ide-purescriptを使ったら簡単にインポートを整理できるようになってだいぶ楽になりました。推論された関数の型の型注釈を補間してくれる機能や、カーソルを合わせると関数の型を表示してくれる機能なんかは、入門したてのころは特に役に立つと思います。


# このあとは

* **["PureScript by Example"](https://leanpub.com/purescript/read)** オリジナルの作者philさんが書いたPureScriptの入門書です。無料で読めます。PureScriptを使いたいならまっさきに読みたい。PureScriptに限らず、現代的な関数型プログラミングの一般的な入門としても適しています。SICPみたいな古文書を読んでる場合じゃないぞ！
* [Wiki](https://github.com/purescript/purescript/wiki) Wikiにも色々情報があります
* [24-days-of-purescript-2016](https://github.com/paf31/24-days-of-purescript-2016) 小ネタ集
* [purescript/documentation](https://github.com/purescript/documentation) ドキュメント用のリポジトリができたらしいです

なお、これ全部**英語**です。がんばろう。




# 気になるIssueメモ（随時更新）

* [Inlining #2345](https://github.com/purescript/purescript/issues/2345) インライン化の話。PureScriptは現時点ではあまり最適化に力を入れていません。でも私もPureScriptのパフォーマンスの問題で躓いたことがあったので、もっと強力な最適化ができるといいとは思うのですが……。
* [Support ES6 and beyond?](https://github.com/purescript/purescript/issues/2207) / [Change psc to emit ES6 modules instead of CommonJS](https://github.com/purescript/purescript/issues/2574) ES6対応。内部表現に破壊的変更が加わり、一部のFFIが壊れるかも。結局みんな静的解析が欲しくなるんじゃん。Commonjsモジュールとはなんだったのか。

## 変更履歴

PureScriptもどんどんバージョンアップしてすぐコンパイル通らなくなって困るのですが、この記事はなるべくメンテナンスしたいと思います。

* **2017/04/18** 0.11アップデート作業。あとpurescript-halogen-templeteだけ
* **2017/03/30** 0.11アップデートの注意書きだけ加えました。そのうちまた更新します 
* **2017/01/25** 環境によってコンパイルが通らない問題を修正しました
* **2017/01/07** 記事のメンテナンスをしました。pscのバージョンは**[v0.10.5](https://github.com/purescript/purescript/releases/tag/v0.10.5)**です。バージョンがガンガン上がっていますが、コンパイラに破壊的変更はないので、この記事の内容にも大きな変更はありません。
* **2016/11/12** 記事のメンテナンスをしました。pscのバージョンは**[v0.10.2](https://github.com/purescript/purescript/releases/tag/v0.10.2)**です。node-hhtpモジュールでAPIの変更があった部分を修正しました。
* この記事を最初に書いた時点での`psc`のバージョンは`0.9.3`でした。

----



