<!DOCTYPE html><html><head><meta charset="UTF-8">

  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="実例によるPureScript">
  <meta name="twitter:description" content="純粋関数型プログラミング言語 PureScriptの入門書、"PureScript by Example"の日本語訳">
  <meta name="twitter:いまげ" content="http://aratama.github.io/purescript/card.png">    
  <meta property="og:url" content="http://aratama.github.io/purescript/">
  <meta property="og:title" content="実例によるPureScript">
  <meta property="og:description" content="純粋関数型プログラミング言語 PureScriptの入門書、"PureScript by Example"の日本語訳">
  <meta property="og:image" content="http://aratama.github.io/purescript/card.png">
  
  <title>実例によるPureScript</title>

  <link rel="icon" type="image/png" href="favicon-96x96.png" sizes="96x96">
  <link rel="stylesheet" href="github-markdown.css" type="text/css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Roboto">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/agate.min.css">
</head>

<body>
  <div class="main">
    <header>
      <a class="logo" href="/purescript/">
          <img class="logo" src="logo-shadow.png">
      </a>
      <div class="title">
          <h1 id="実例によるpurescript">実例による<wbr>PureScript</h1>
          <p>ウェブのための<wbr>関数型<wbr>プログラミング</p>
          <p class="author">
            <a href="https://leanpub.com/purescript/read">
              Phil Freeman, "PureScript by Example - Functional Programming for the Web"
            </a>
          </p>
      </div>
    </header>

    <div class="markdown-body content">
    <p class="home"><a href="index.html">目次に戻る</a></p><h1>第11章 モナドの探求</h1><h2>11.1 この章の目標</h2><p>この章の目標は、異なるモナドから提供された副作用を合成する方法を提供する<strong>モナド変換子</strong>(monad transformers)について学ぶことです。NodeJSのコンソール上で遊ぶことができる、テキストアドベンチャーゲームを題材として扱います。ゲームの様々な副作用(ロギング、状態、および設定)がすべてモナド変換子スタックによって提供されます。</p><h2>11.2 プロジェクトの準備</h2><p>このモジュールのプロジェクトでは以下のBower依存関係が新たに導入されます。</p><ul>
<li><code>purescript-maps</code>　- 不変のマップと集合のためのデータ型を提供します。</li>
<li><code>purescript-sets</code>- 不変集合のデータ型を提供する標準的なモナド変換子の実装を提供する</li>
<li><code>purescript-transformers</code>- 標準のモナド変換子の実装を提供します。</li>
<li><code>purescript-node-readline</code>- NodeJSが提供する<a href="http://nodejs.org/api/readline.html"><code>readline</code></a>インターフェイスへのFFIバインディングを提供します。</li>
<li><code>purescript-yargs</code>- <a href="https://www.npmjs.org/package/yargs"><code>yargs</code></a>コマンドライン引数処理ライブラリにApplicativeなインターフェイスを提供します。</li>
</ul><p>また、NPMを使って <code>yargs</code>モジュールをインストールする必要があります。</p><pre><code class="language-text">npm install
</code></pre><h2>11.3 ゲームの遊びかた</h2><p>プロジェクトを実行するには、 <code>pulp run</code>でソースコードをビルドしてから、NodeJSにコンパイルされたJavaScriptを渡します。</p><p>デフォルトでは使い方が表示されます。</p><pre><code class="language-text">node ./dist/Main.js -p <player name>

Options:
  -p, --player  Player name  [required]
  -d, --debug   Use debug mode

Missing required arguments: p
The player name is required
</code></pre><p><code>-p</code>オプションを使ってプレイヤー名を指定してください。</p><pre><code class="language-text">pulp run -- -p Phil
> 
</code></pre><p>プロンプトからは、 <code>look</code>、 <code>inventory</code>、 <code>take</code>、 <code>use</code>、 <code>north</code>、 <code>south</code>、 <code>east</code>、 <code>west</code>などのコマンドを入力することができます。 <code>--debug</code>コマンドラインオプションが与えられたときには、ゲームの状態を出力するための <code>debug</code>コマンドも使えます。</p><p>ゲームは2次元の碁盤の目の上でプレイし、コマンド <code>north</code>、 <code>south</code>、 <code>east</code>、 <code>west</code>を発行することによってプレイヤーが移動します。ゲームにはアイテムの配列があり、プレイヤーの所持アイテム一覧を表したり、ゲーム盤上のその位置にあるアイテムの一覧を表すのに使われます。 <code>take</code>コマンドを使うと、プレイヤーの位置にあるアイテムを拾い上げることができます。</p><p>参考までに、このゲームのひと通りの流れは次のようになります。</p><pre><code class="language-text">$ pulp run -- -p Phil

> look
You are at (0, 0)
You are in a dark forest. You see a path to the north.
You can see the Matches.

> take Matches
You now have the Matches

> north
> look
You are at (0, 1)
You are in a clearing.
You can see the Candle.

> take Candle
You now have the Candle

> inventory
You have the Candle.
You have the Matches.

> use Matches
You light the candle.
Congratulations, Phil!
You win!
</code></pre><p>このゲームはとても単純ですが、この章の目的は <code>purescript-transformers</code>パッケージを使用してこのようなゲームを素早く開発できるようにするライブラリを構築することです。</p><h2>11.4 Stateモナド</h2><p><code>purescript-transformers</code>パッケージで提供されるモナドをいくつか見てみましょう。</p><p>最初の例は、<strong>純粋な変更可能状態</strong>を提供する <code>State</code>モナドです。すでに <code>Eff</code>モナド、すなわち <code>REF</code>作用と <code>ST</code>作用によって提供された変更可能な状態という2つのアプローチについては見てきました。 <code>State</code>は第3の選択肢を提供しますが、これは <code>Eff</code>モナドを使用して実装されているわけではありません。</p><p><code>State</code>型構築子は、状態の型 <code>s</code>、および返り値の型 <code>a</code>という2種類の引数を取ります。「 <code>State</code>モナド」というように説明はしていますが、実際には <code>Monad</code>型クラスのインスタンスが用意されているのは <code>State</code>に対してではなく、任意の型 <code>s</code>についての <code>State s</code>型構築子に対してです。</p><p><code>Control.Monad.State</code>モジュールは以下のAPIを提供しています。</p><pre><code class="language-haskell"><span class="hljs-title">get</span>    :: <span class="hljs-keyword">forall</span> s.             <span class="hljs-type">State</span> s s
<span class="hljs-title">put</span>    :: <span class="hljs-keyword">forall</span> s. s        -&gt; <span class="hljs-type">State</span> s <span class="hljs-type">Unit</span>
<span class="hljs-title">modify</span> :: <span class="hljs-keyword">forall</span> s. (s -&gt; s) -&gt; <span class="hljs-type">State</span> s <span class="hljs-type">Unit</span>
</code></pre><p>これは <code>REF</code>作用や <code>ST</code>作用が提供するAPIととてもよく似ています。しかし、これらのアクションに <code>Ref</code>や <code>STRef</code>に渡しているような、可変領域への参照を引数に渡さないことに注意してください。 <code>State</code>と <code>Eff</code>モナドが提供する解決策の違いは、 <code>State</code>モナドは暗黙的な単一の状態だけを提供していることです。この状態は <code>State</code>モナドの型構築子によって隠された関数の引数として実装されており、参照は明示的には渡されないのです。</p><p>例を見てみましょう。 <code>State</code>モナドの使いかたのひとつとしては、状態を数として、現在の状態に配列の値を加算していくようなものかもしれません。状態の型 <code>s</code>として <code>Number</code>を選択し、配列の走査に <code>traverse_</code>を使って、配列の要素それぞれについて <code>modify</code>を呼び出すと、これを実現することができます。</p><pre><code class="language-haskell"><span class="hljs-keyword">import</span> Data.Foldable (<span class="hljs-title">traverse_</span>)
<span class="hljs-keyword">import</span> Control.Monad.State
<span class="hljs-keyword">import</span> Control.Monad.State.Class

<span class="hljs-title">sumArray</span> :: <span class="hljs-type">Array</span> <span class="hljs-type">Number</span> -&gt; <span class="hljs-type">State</span> <span class="hljs-type">Number</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">sumArray</span> = traverse_ \n -&gt; modify \sum -&gt; sum + n
</code></pre><p><code>Control.Monad.State</code>モジュールは <code>State</code>モナドでの計算を実行するための次の3つの関数を提供します。</p><pre><code class="language-haskell"><span class="hljs-title">evalState</span> :: <span class="hljs-keyword">forall</span> s a. <span class="hljs-type">State</span> s a -&gt; s -&gt; a
<span class="hljs-title">execState</span> :: <span class="hljs-keyword">forall</span> s a. <span class="hljs-type">State</span> s a -&gt; s -&gt; s
<span class="hljs-title">runState</span>  :: <span class="hljs-keyword">forall</span> s a. <span class="hljs-type">State</span> s a -&gt; s -&gt; <span class="hljs-type">Tuple</span> a s
</code></pre><p>３つの関数はそれぞれ初期値の型 <code>s</code>と計算の型 <code>State s a</code>を引数にとります。 <code>evalState</code>は返り値だけを返し、 <code>execState</code>は最終的な状態だけを返し、 <code>runState</code>は <code>Tuple a s</code>型の値として表現された返り値と状態の両方を返します。</p><p>先ほどの <code>sumArray</code>関数が与えられたとすると、 <code>PSCi</code>で次のように <code>execState</code>を使うと複数の配列内の数字を合計することができます。</p><pre><code class="language-text">> :paste
… execState (do
…   sumArray [1, 2, 3]
…   sumArray [4, 5]
…   sumArray [6]) 0
… ^D
21
</code></pre><div class="exercise"><h2>演習</h2><ol>
<li>
<p>(簡単) 上の例で、 <code>execState</code>を <code>runState</code>や <code>evalState</code>で 置き換えると結果はどうなるでしょうか。</p>
</li>
<li>
<p>(やや難しい)<code>State</code>モナドと <code>traverse_</code>関数を使用して、次のような関数を書いてください。</p>
<pre><code class="language-haskell">testParens :: <span class="hljs-built_in">String</span> -&gt; <span class="hljs-built_in">Boolean</span>
</code></pre>
<p>これは <code>String</code>が括弧の対応が正しく付けられているかどうかを調べる関数です。この関数は次のように動作しなくてはなりません。</p>
<pre><code class="language-text">> testParens ""
true

> testParens "(()(())())"
true

> testParens ")"
false

> testParens "(()()"
false
</code></pre>
<p><strong>ヒント</strong>： 入力の文字列を文字の配列に変換するのに、 <code>Data.String</code>モジュールの <code>split</code>関数を使うと良いでしょう。</p>
</li>
</ol></div><h2>11.5 Readerモナド</h2><p><code>purescript-transformers</code>パッケージでは <code>Reader</code>というモナドも提供されています。このモナドは大域的な設定を読み取る機能を提供します。 <code>State</code>モナドがひとつの可変状態を読み書きする機能を提供するのに対し、 <code>Reader</code>モナドはデータの読み取りの機能だけを提供します。</p><p><code>Reader</code>型構築子は、構成の型を表す型 <code>r</code>、および戻り値の型 <code>a</code>の2つの型引数を取ります。</p><p><code>Contro.Monad.Reader</code>モジュールは以下のAPIを提供します。</p><pre><code class="language-haskell"><span class="hljs-title">ask</span>   :: <span class="hljs-keyword">forall</span> r. <span class="hljs-type">Reader</span> r r
<span class="hljs-title">local</span> :: <span class="hljs-keyword">forall</span> r a. (r -&gt; r) -&gt; <span class="hljs-type">Reader</span> r a -&gt; <span class="hljs-type">Reader</span> r a
</code></pre><p><code>ask</code>アクションは現在の設定を読み取るために使い、 <code>local</code>アクションは局所的に設定を変更して計算を実行するために使います。</p><p>たとえば、権限で制御されたアプリケーションを開発しており、現在の利用者の権限オブジェクトを保持するのに <code>Reader</code>モナドを使いたいとしましょう。型 <code>r</code>を次のようなAPIを備えた型 <code>Permission</code>として選択します。</p><pre><code class="language-haskell"><span class="hljs-title">hasPermission</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Permissions</span> -&gt; <span class="hljs-type">Boolean</span>
<span class="hljs-title">addPermission</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Permissions</span> -&gt; <span class="hljs-type">Permissions</span>
</code></pre><p>利用者が特定の権限を持っているかどうかを確認したいときは、 <code>ask</code>を使って現在の権限オブジェクトを取得すればいつでも調べることができます。たとえば、管理者だけが新しい利用者の作成を許可されているとしましょう。</p><pre><code class="language-haskell"><span class="hljs-title">createUser</span> :: <span class="hljs-type">Reader</span> <span class="hljs-type">Permissions</span> (<span class="hljs-type">Maybe</span> <span class="hljs-type">User</span>)
<span class="hljs-title">createUser</span> = <span class="hljs-keyword">do</span>
  permissions &lt;- ask
  <span class="hljs-keyword">if</span> hasPermission <span class="hljs-string">"admin"</span> permissions
    <span class="hljs-keyword">then</span> map <span class="hljs-type">Just</span> newUser
    <span class="hljs-keyword">else</span> pure <span class="hljs-type">Nothing</span>
</code></pre><p><code>local</code>アクションを使うと、計算の実行中に <code>Permissions</code>オブジェクトを局所的に変更し、ユーザーの権限を昇格させることもできます。</p><pre><code class="language-haskell"><span class="hljs-title">runAsAdmin</span> :: <span class="hljs-keyword">forall</span> a. <span class="hljs-type">Reader</span> <span class="hljs-type">Permissions</span> a -&gt; <span class="hljs-type">Reader</span> <span class="hljs-type">Permissions</span> a
<span class="hljs-title">runAsAdmin</span> = local (addPermission <span class="hljs-string">"admin"</span>)
</code></pre><p>こうすると、利用者が <code>admin</code>権限を持っていなかった場合であっても、新しい利用者を作成する関数を書くことができます。</p><pre><code class="language-haskell">createUserAsAdmin :: Reader Permissions (Maybe User)
createUserAsAdmin = runAsAdmin createUser
</code></pre><p><code>Reader</code>モナドの計算を実行するには、大域的な設定を与える <code>runReader</code>関数を使います。</p><pre><code class="language-haskell"><span class="hljs-title">runReader</span> :: <span class="hljs-keyword">forall</span> r a. <span class="hljs-type">Reader</span> r a -&gt; r -&gt; a
</code></pre><div class="exercise"><h2>演習</h2><p>以下の演習では、 <code>Reader</code>モナドを使って、字下げのついた文書を出力するための小さなライブラリを作っていきます。「大域的な設定」は、現在の字下げの深さを示す数になります。</p></div><pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Level</span> = <span class="hljs-type">Number</span></span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Doc</span> = <span class="hljs-type">Reader</span> <span class="hljs-type">Level</span> <span class="hljs-type">String</span></span>
</code></pre><ol>
<li>
<p>(簡単)　現在の字下げの深さで文字列を出力する関数 <code>line</code>を書いてください。その関数は、以下の型を持っている必要があります。</p>
<pre><code class="language-haskell"><span class="hljs-title">line</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Doc</span>
</code></pre>
<p><strong>ヒント</strong>：現在の字下げの深さを読み取るためには <code>ask</code>関数を使用します。</p>
</li>
<li>
<p>(やや難しい)<code>local</code>関数を使用して、コードブロックの字下げの深さを大きくする次のような関数を書いてください。</p>
<pre><code class="language-haskell"><span class="hljs-title">indent</span> :: <span class="hljs-type">Doc</span> -&gt; <span class="hljs-type">Doc</span>
</code></pre>
</li>
<li>
<p>(やや難しい)<code>Data.Traversable</code>で定義された <code>sequence</code>関数を使用して、文書のリストを改行で区切って連結する次のような関数を書いてください。</p>
<pre><code class="language-haskell"><span class="hljs-title">cat</span> :: <span class="hljs-type">Array</span> <span class="hljs-type">Doc</span> -&gt; <span class="hljs-type">Doc</span>
</code></pre>
</li>
<li>
<p>(やや難しい)<code>runReader</code>関数を使用して、文書を文字列として出力する次のような関数を書いてください。</p>
<pre><code class="language-haskell"><span class="hljs-title">render</span> :: <span class="hljs-type">Doc</span> -&gt; <span class="hljs-type">String</span>
</code></pre>
<p>これで、このライブラリを次のように使うと、簡単な文書を書くことができるはずです。</p>
<pre><code class="language-haskell"><span class="hljs-title">render</span> $ cat
  [ line <span class="hljs-string">"Here is some indented text:"</span>
  , indent $ cat
      [ line <span class="hljs-string">"I am indented"</span>
      , line <span class="hljs-string">"So am I"</span>
      , indent $ line <span class="hljs-string">"I am even more indented"</span>
      ]
  ]
</code></pre>
</li>
</ol><h2>11.6 Writerモナド</h2><p><code>Writer</code>モナドは、計算の返り値に加えて、もうひとつの値を累積していく機能を提供します。</p><p>よくある使い方としては型 <code>String</code>もしくは <code>Array String</code>でログを累積していくというものなどがありますが、 <code>Writer</code>モナドはこれよりもっと一般的なものです。これは累積するのに任意のモノイドの値を使うことができ、 <code>Sum</code>モノイドを使って、合計を追跡し続けるのに使ったり、 <code>Any</code>モノイドを使って途中の <code>Boolean</code>値がすべて真であるかどうかを追跡するのに使うことができます。</p><p><code>Writer</code>型の構築子は、 <code>Monoid</code>型クラスのインスタンスである型 <code>w</code>、および返り値の型 <code>a</code>という2つの型引数を取ります。</p><p><code>Writer</code>のAPIで重要なのは <code>tell</code>関数です。</p><pre><code class="language-haskell"><span class="hljs-title">tell</span> :: <span class="hljs-keyword">forall</span> w a. <span class="hljs-type">Monoid</span> w =&gt; w -&gt; <span class="hljs-type">Writer</span> w <span class="hljs-type">Unit</span>
</code></pre><p><code>tell</code>アクションは、与えられた値を現在の累積結果に加算します。</p><p>例として、 <code>Array String</code>モノイドを使用して、既存の関数にログ機能を追加してみましょう。<strong>最大公約数</strong>関数の以前の実装を考えてみます。</p><pre><code class="language-haskell"><span class="hljs-title">gcd</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span>
<span class="hljs-title">gcd</span> n <span class="hljs-number">0</span> = n
<span class="hljs-title">gcd</span> <span class="hljs-number">0</span> m = m
<span class="hljs-title">gcd</span> n m = <span class="hljs-keyword">if</span> n &gt; m
            <span class="hljs-keyword">then</span> gcd (n - m) m
            <span class="hljs-keyword">else</span> gcd n (m - n)
</code></pre><p><code>Writer (Array String) Int</code>に返り値の型を変更することで、この関数にログ機能を追加することができます。</p><pre><code class="language-haskell"><span class="hljs-keyword">import</span> Control.Monad.Writer
<span class="hljs-keyword">import</span> Control.Monad.Writer.Class

<span class="hljs-title">gcdLog</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Writer</span> (<span class="hljs-type">Array</span> <span class="hljs-type">String</span>) <span class="hljs-type">Int</span>
</code></pre><p>各手順で二つの入力を記録するために、少し関数を変更する必要があります。</p><pre><code class="language-haskell"><span class="hljs-title">gcdLog</span> n <span class="hljs-number">0</span> = pure n
<span class="hljs-title">gcdLog</span> <span class="hljs-number">0</span> m = pure m
<span class="hljs-title">gcdLog</span> n m = <span class="hljs-keyword">do</span>
  tell [<span class="hljs-string">"gcdLog "</span> &lt;&gt; show n &lt;&gt; <span class="hljs-string">" "</span> &lt;&gt; show m]
  <span class="hljs-keyword">if</span> n &gt; m
    <span class="hljs-keyword">then</span> gcdLog (n - m) m
    <span class="hljs-keyword">else</span> gcdLog n (m - n)
</code></pre><p><code>Writer</code>モナドの計算を実行するには、 <code>execWriter</code>関数と <code>runWriter</code>関数のいずれかを使います。</p><pre><code class="language-haskell"><span class="hljs-title">execWriter</span> :: <span class="hljs-keyword">forall</span> w a. <span class="hljs-type">Writer</span> w a -&gt; w
<span class="hljs-title">runWriter</span>  :: <span class="hljs-keyword">forall</span> w a. <span class="hljs-type">Writer</span> w a -&gt; <span class="hljs-type">Tuple</span> a w
</code></pre><p>ちょうど <code>State</code>モナドの場合と同じように、 <code>execWriter</code>が累積されたログだけを返すのに対して、 <code>runWriter</code>は累積されたログと結果の両方を返します。</p><p><code>PSCi</code>で修正された関数を試してみましょう。</p><pre><code class="language-text">> import Control.Monad.Writer
> import Control.Monad.Writer.Class

> runWriter (gcdLog 21 15)
Tuple 3 ["gcdLog 21 15","gcdLog 6 15","gcdLog 6 9","gcdLog 6 3","gcdLog 3 3"]
</code></pre><div class="exercise"><h2>演習</h2><ol>
<li>
<p>(やや難しい)<code>Writer</code>モナドと <code>purescript-monoid</code>パッケージの <code>Additive Int</code>のモノイドを使うように、上の <code>sumArray</code>関数を書き換えてください。</p>
</li>
<li>
<p>(やや難しい)<strong>コラッツ関数</strong>は、自然数 <code>n</code>が偶数なら <code>n / 2</code>、 <code>n</code>が奇数なら <code>3 * n + 1</code>であると定義されています。たとえば、 <code>10</code>で始まるコラッツ数列は次のようになります。</p>
<pre><code class="language-text">10, 5, 16, 8, 4, 2, 1, ...
</code></pre>
<p>コラッツ関数の有限回の適用を繰り返すと、コラッツ数列は必ず最終的に <code>1</code>になるということとが予想できます。</p>
<p>数列が <code>1</code>に到達するまでに何回のコラッツ関数の適用が必要かを計算する再帰的な関数を書いてください。</p>
<p><code>Writer</code>モナドを使用してコラッツ関数のそれぞれの適用の経過を記録するように、関数を変更してください。</p>
</li>
</ol></div><h2>11.7 モナド変換子</h2><p>上の3つのモナド、 <code>State</code>、 <code>Reader</code>、 <code>Writer</code>は、いずれもいわゆる<strong>モナド変換子</strong>(monad transformers)の例となっています。対応するモナド変換子はそれぞれ <code>StateT</code>、 <code>ReaderT</code>、 <code>WriterT</code>と呼ばれています。</p><p>モナド変換子とは何でしょうか。さて、これまで見てきたように、モナドはPureScriptで適切なハンドラ(<code>runState</code>、 <code>runReader</code>、 <code>runWriter</code>など)を使って解釈される、いろいろな種類の副作用でPureScriptコードを拡張します。使用する必要がある副作用が<strong>ひとつだけ</strong>なら、これで問題ありません。しかし、同時に複数の副作用を使用できると便利なことがよくあります。例えば、 <code>Maybe</code>と <code>Reader</code>を一緒に使用すると、ある大域的な設定の文脈で<strong>省略可能な結果</strong>を表現することができます。もしくは、 <code>Either</code>モナドの純粋なエラー追跡機能と、 <code>State</code>モナドが提供する変更可能な状態が同時に欲しくなるかもしれません。この問題を解決するのが<strong>モナド変換子</strong>です。</p><p><strong>拡張可能作用</strong>の手法を使うとネイティブな作用を混在させることができるので、 <code>Eff</code>モナドはこの問題に対する部分的な解決策を提供していることをすでに見てきたことに注意してください。モナド変換子はまた異なった解決策を提供しますが、これらの手法にはそれぞれ利点と限界があります。</p><p>モナド変換子は型だけでなく別の型構築子によってもパラメータ化される型構築子です。モナド変換子はモナドをひとつ取り、独自のいろいろな副作用を追加した別のモナドへと変換します。</p><p>例を見てみましょう。 <code>Control.Monad.State.Trans</code>で定義された <code>StateT</code>は <code>State</code>のモナド変換子版です。 <code>PSCi</code>を使って <code>StateT</code>の種を見てみましょう。</p><pre><code class="language-text">> import Control.Monad.State.Trans
> :kind StateT
Type -> (Type -> Type) -> Type -> Type
</code></pre><p>とても読みにくそうに思うかもしれませんが、使い方を理解するために、 <code>StateT</code>にひとつ引数を与えてみましょう。</p><p><code>State</code>の場合、最初の型引数は使いたい状態の型です。それでは型 <code>String</code>を与えてみましょう。</p><pre><code class="language-text">> :kind StateT String
(Type -> Type) -> Type -> Type
</code></pre><p>次の引数は種 <code>Type -> Type</code>の型構築子です。これは <code>StateT</code>の機能を追加したい元のモナドを表します。例として、 <code>Either String</code>モナドを選んでみます。</p><pre><code class="language-text">> :kind StateT String (Either String)
Type -> Type
</code></pre><p>型構築子が残りました。最後の引数は戻り値の型を表しており、たとえばそれを <code>Number</code>にすることができます。</p><pre><code class="language-text">> :kind StateT String (Either String) Number
Type
</code></pre><p>最後に、種 <code>Type</code>の何かが残りましたが、この型の値を探してみましょう。</p><p>構築したモナド <code>StateT String (Either String)</code>は、エラーで失敗する可能性があり、変更可能な状態を使える計算を表しています。</p><p>外側の <code>StateT String (Either String)</code>モナドのアクション(<code>get</code>、 <code>put</code>、 <code>modify</code>)は直接使うことができますが、ラップされている内側のモナド(<code>Either String</code>)の作用を使うためには、これらの関数をモナド変換子まで「持ち上げ」なくてはいけません。 <code>Control.MonadTrans</code>モジュールでは、モナド変換子であるような型構築子を捕捉する <code>MonadTrans</code>型クラスを次のように定義しています。</p><pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">MonadTrans</span> t <span class="hljs-keyword">where</span></span>
  lift :: <span class="hljs-keyword">forall</span> m a. <span class="hljs-type">Monad</span> m =&gt; m a -&gt; t m a
</code></pre><p>このクラスは、基礎となる任意のモナド <code>m</code>の計算をとり、それをラップされたモナド <code>t m</code>へと持ち上げる、 <code>lift</code>というひとつの関数だけを持っています。今回の場合、型構築子 <code>t</code>は <code>StateT String</code>で、 <code>m</code>は <code>Either String</code>モナドとなり、 <code>lift</code>は型 <code>Either String a</code>の計算を、型 <code>State String (Either String) a</code>の計算へと持ち上げる方法を提供することになります。これは、型 <code>Either String a</code>の計算を使うときは、 <code>lift</code>を使えばいつでも作用 <code>StateT String</code>と <code>Either String</code>を隣り合わせに使うことができることを意味します。</p><p>たとえば、次の計算は <code>StateT</code>モナド変換子で導入されている状態を読み込み、状態が空の文字列である場合はエラーを投げます。</p><pre><code class="language-haskell"><span class="hljs-keyword">import</span> Data.String (<span class="hljs-title">drop</span>, <span class="hljs-title">take</span>)

<span class="hljs-title">split</span> :: <span class="hljs-type">StateT</span> <span class="hljs-type">String</span> (<span class="hljs-type">Either</span> <span class="hljs-type">String</span>) <span class="hljs-type">String</span>
<span class="hljs-title">split</span> = <span class="hljs-keyword">do</span>
  s &lt;- get
  <span class="hljs-keyword">case</span> s <span class="hljs-keyword">of</span>
    <span class="hljs-string">""</span> -&gt; lift $ <span class="hljs-type">Left</span> <span class="hljs-string">"Empty string"</span>
    _ -&gt; <span class="hljs-keyword">do</span>
      put (drop <span class="hljs-number">1</span> s)
      pure (take <span class="hljs-number">1</span> s)
</code></pre><p>状態が空でなければ、この計算は <code>put</code>を使って状態を <code>drop 1 s</code>(最初の文字を取り除いた <code>s</code>)へと更新し、 <code>take 1 s</code>(<code>s</code>の最初の文字)を返します。</p><p>それでは <code>PSCi</code>でこれを試してみましょう。</p><pre><code class="language-text">> runStateT split "test"
Right (Tuple "t" "est")

> runStateT split ""
Left "Empty string"
</code></pre><p>これは <code>StateT</code>を使わなくても実装できるので、さほど驚くようなことではありません。しかし、モナドとして扱っているので、do記法やApplicativeコンビネータを使って、小さな計算から大きな計算を構築していくことができます。例えば、2回 <code>split</code>を適用すると、文字列から最初の2文字を読むことができます。</p><pre><code class="language-text">> runStateT ((<>) <$> split <*> split) "test"
(Right (Tuple "te" "st"))
</code></pre><p>他にもアクションを幾つか用意すれば、 <code>split</code>関数を使って、基本的な構文解析ライブラリを構築することができます。これは実際に <code>purescript-parsing</code>ライブラリで採用されている手法です。これがモナド変換子の力なのです。必要な副作用を選択して、do記法とApplicativeコンビネータで表現力を維持しながら、様々な問題のための特注のモナドを作成することができるのです。</p><h2>11.8 ExceptTモナド変換子</h2><p><code>purescript-transformers</code>パッケージでは、 <code>Either e</code>モナドに対応する変換子である <code>ExceptT e</code>モナド変換子も定義されています。これは次のAPIを提供します。</p><pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">MonadError</span> e m <span class="hljs-keyword">where</span></span>
  throwError :: <span class="hljs-keyword">forall</span> a. e -&gt; m a
  catchError :: <span class="hljs-keyword">forall</span> a. m a -&gt; (e -&gt; m a) -&gt; m a
<span class="hljs-class">
<span class="hljs-keyword">instance</span> monadErrorExceptT :: <span class="hljs-type">Monad</span> m =&gt; <span class="hljs-type">MonadError</span> e (<span class="hljs-type">ExceptT</span> <span class="hljs-title">e</span> <span class="hljs-title">m</span>)

runExceptT :: forall e m a. <span class="hljs-type">ExceptT</span> e m a -&gt; m (<span class="hljs-type">Either</span> <span class="hljs-title">e</span> <span class="hljs-title">a</span>)
</span></code></pre><p><code>MonadError</code>クラスは <code>e</code>型のエラーのスローとキャッチをサポートするモナドを取得し、 <code>ExceptT e</code>モナド変換子のインスタンスが提供されます。 <code>Either e</code>モナドの <code>Left</code>と同じように、 <code>throwError</code>アクションは失敗を示すために使われます。 <code>catchError</code>アクションを使うと、 <code>throwError</code>でエラーが投げられたあとでも処理を継続することができるようになります。</p><p><code>runExceptT</code>ハンドラを使うと、型 <code>ExceptT e m a</code>の計算を実行することができます。</p><p>このAPIは <code>purescript-exceptions</code>パッケージの <code>Exception</code>作用によって提供されているものと似ています。しかし、いくつかの重要な違いがあります。</p><ul>
<li><code>ExceptT</code>モデルが代数的データ型を使っているのに対して、 <code>Exception</code>は実際のJavaScriptの例外を使っています。</li>
<li><code>ExceptT</code>が <code>Error</code>型クラスのどんな型のエラーでも扱うのに対して、 <code>Exception</code>作用はJavaScriptの <code>Error</code>型というひとつ例外の型だけを扱います。つまり、 <code>ExceptT</code>では新たなエラー型を自由に定義できます。</li>
</ul><p>試しに <code>ExceptT</code>を使って <code>Writer</code>モナドを包んでみましょう。ここでもモナド変換子 <code>ExceptT e</code>のアクションは自由に使えますが、 <code>Writer</code>モナドの計算は <code>lift</code>を使って持ちあげなければなりません。</p><pre><code class="language-haskell"><span class="hljs-keyword">import</span> Control.Monad.Trans
<span class="hljs-keyword">import</span> Control.Monad.Writer
<span class="hljs-keyword">import</span> Control.Monad.Writer.Class
<span class="hljs-keyword">import</span> Control.Monad.Error.Class
<span class="hljs-keyword">import</span> Control.Monad.Except.Trans

<span class="hljs-title">writerAndExceptT</span> :: <span class="hljs-type">ExceptT</span> <span class="hljs-type">String</span> (<span class="hljs-type">Writer</span> (<span class="hljs-type">Array</span> <span class="hljs-type">String</span>)) <span class="hljs-type">String</span>
<span class="hljs-title">writerAndExceptT</span> = <span class="hljs-keyword">do</span>
  lift $ tell [<span class="hljs-string">"Before the error"</span>]
  throwError <span class="hljs-string">"Error!"</span>
  lift $ tell [<span class="hljs-string">"After the error"</span>]
  pure <span class="hljs-string">"Return value"</span>
</code></pre><p><code>PSCi</code>でこの関数を試すと、ログの蓄積とエラーの送出という２つの作用がどのように相互作用しているのかを見ることができます。まず、 <code>runExceptT</code>を使って外側の <code>ExceptT</code>計算を実行し、型 <code>Write String (Either String String)</code>の結果を残します。それから、 <code>runWriter</code>で内側の <code>Writer</code>計算を実行します。</p><pre><code class="language-text">> runWriter $ runExceptT writerAndExceptT
Tuple (Left "Error!") ["Before the error"]
</code></pre><p>実際に追加されるログは、エラーが投げられる前に書かれたログメッセージだけであることにも注目してください。</p><h2>11.9 モナド変換子スタック</h2><p>これまで見てきたように、モナド変換子を使うと既存のモナドの上に新しいモナドを構築することができます。任意のモナド変換子 <code>t1</code>と任意のモナド <code>m</code>について、その適用 <code>t1 m</code>もまたモナドになります。これは<strong>ふたつめの</strong>モナド変換子 <code>t2</code>を先ほどの結果 <code>t1 m</code>に適用すると、第３のモナド <code>t2 (t1 m)</code>を作れることを意味しています。このように、構成するモナドによって提供された副作用を組み合わせる、モナド変換子の<strong>スタック</strong>を構築することができます。</p><p>実際には、基本となるモナド <code>m</code>は、ネイティブの副作用が必要なら <code>Eff</code>モナド、さもなくば <code>Control.Monad.Identity</code>モジュールで定義されている <code>Identity</code>モナドになります。 <code>Identity</code>モナドは何の新しい副作用も追加しませんから、 <code>Identity</code>モナドの変換は、モナド変換子の作用だけを提供します。実際に、 <code>State</code>モナド、 <code>Reader</code>モナド、 <code>Writer</code>モナドは、 <code>Identity</code>モナドをそれぞれ <code>StateT</code>、 <code>ReaderT</code>、 <code>WriterT</code>で変換することによって実装されています。</p><p>それでは3つの副作用が組み合わされている例を見てみましょう。 <code>Identity</code>モナドをスタックの底にして、 <code>StateT</code>作用、 <code>WriterT</code>作用、 <code>ExceptT</code>作用を使います。このモナド変換子スタックは、ログの蓄積し、純粋なエラー、可変状態の副作用を提供します。</p><p>このモナド変換子スタックを使うと、ロギングの機能が追加された <code>split</code>アクションを作ることができます。</p><pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Errors</span> = <span class="hljs-type">Array</span> <span class="hljs-type">String</span></span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Log</span> = <span class="hljs-type">Array</span> <span class="hljs-type">String</span></span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Parser</span> = <span class="hljs-type">StateT</span> <span class="hljs-type">String</span> (<span class="hljs-type">WriterT</span> <span class="hljs-type">Log</span> (<span class="hljs-type">ExceptT</span> <span class="hljs-type">Errors</span> <span class="hljs-type">Identity</span>))</span>

<span class="hljs-title">split</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">String</span>
<span class="hljs-title">split</span> = <span class="hljs-keyword">do</span>
  s &lt;- get
  lift $ tell [<span class="hljs-string">"The state is "</span> &lt;&gt; show s]
  <span class="hljs-keyword">case</span> s <span class="hljs-keyword">of</span>
    <span class="hljs-string">""</span> -&gt; lift $ lift $ throwError [<span class="hljs-string">"Empty string"</span>]
    _ -&gt; <span class="hljs-keyword">do</span>
      put (drop <span class="hljs-number">1</span> s)
      pure (take <span class="hljs-number">1</span> s)
</code></pre><p>この計算を <code>PSCi</code>で試してみると、 <code>split</code>が実行されるたびに状態がログに追加されることがわかります。</p><p>モナド変換子スタックに現れる順序に従って、副作用を取り除いていかなければならないことに注意してください。最初に <code>StateT</code>型構築子を取り除くために <code>runStateT</code>を使い、それから <code>runtWriteT</code>を使い、その後 <code>runExceptT</code>を使います。最後に <code>runIdentity</code>を使用して <code>Identity</code>モナドの演算を実行します。</p><pre><code class="language-text">> runParser p s = runIdentity $ runExceptT $ runWriterT $ runStateT p s

> runParser split "test"
(Right (Tuple (Tuple "t" "est") ["The state is test"]))

> runParser ((<>) <$> split <*> split) "test"
(Right (Tuple (Tuple "te" "st") ["The state is test", "The state is est"]))
</code></pre><p>しかしながら解析が失敗した場合は、状態が空であるためログはまったく出力されません。</p><pre><code class="language-text">> runParser split ""
(Left ["Empty string"])
</code></pre><p>これは、 <code>ExceptT</code>モナド変換子が提供する副作用が、 <code>WriterT</code>モナド変換子が提供する副作用に影響を受けるためです。これはモナド変換子スタックが構成されている順序を変更することで解決することができます。スタックの最上部に <code>ExceptT</code>変換子を移動すると、先ほど <code>Writer</code>を <code>ExceptT</code>に変換したときと同じように、最初のエラーまでに書かれたすべてのメッセージが含まれるようになります。</p><p>このコードの問題のひとつは、複数のモナド変換子の上まで計算を持ち上げるために、 <code>lift</code>関数を複数回使わなければならないということです。たとえば、 <code>throwError</code>の呼び出しは、1回目は <code>WriteT</code>へ、2回目は <code>StateT</code>へと、2回持ちあげなければなりません。小さなモナド変換子スタックならなんとかなりますが、そのうち不便だと感じるようになるでしょう。</p><p>幸いなことに、これから見るような型クラス推論によって提供されるコードの自動生成を使うと、ほとんどの「多段持ち上げ」を行うことができます。</p><div class="exercise"><h2>演習</h2><ol>
<li>
<p>(簡単)　<code>Identity</code>関手の上の <code>ExceptT</code>モナド変換子を使って、分母がゼロの場合はエラーを投​​げる、2つの数の商を求める関数 <code>safeDivide</code>を書いてください。</p>
</li>
<li>
<p>(やや難しい) 現在の状態が接頭辞に適合するか、エラーメッセージとともに失敗する、次のような構文解析関数を書いてください。</p>
<pre><code class="language-haskell">string :: <span class="hljs-built_in">String</span> -&gt; Parser <span class="hljs-built_in">String</span>
</code></pre>
<p>この構文解析器は次のように動作しなくてはなりません。</p>
<pre><code class="language-text">> runParser (string "abc") "abcdef"
(Right (Tuple (Tuple "abc" "def") ["The state is abcdef"]))
</code></pre>
<p><strong>ヒント</strong>：出発点として <code>split</code>の実装を使うといいでしょう。<code>stripPrefix</code>関数も役に立ちます。</p>
</li>
<li>
<p>(難しい) 以前 <code>Reader</code>モナドを使用して書いた文書出力ライブラリを、 <code>ReaderT</code>と <code>WriterT</code>モナド変換子を使用して再実装してください。</p>
<p>文字列を出力する <code>line</code>や文字列を連結する <code>cat</code>を使うのではなく、 <code>WriteT</code>モナド変換子と一緒に <code>Array String</code>モノイドを使い、結果へ行を追加するのに <code>tell</code>を使ってください。</p>
</li>
</ol></div><h2>11.10 救済のための型クラス</h2><p>章の最初で扱った <code>State</code>モナドを見てみると、 <code>State</code>モナドのアクションには次のような型が与えられていました。</p><pre><code class="language-haskell"><span class="hljs-title">get</span>    :: <span class="hljs-keyword">forall</span> s.             <span class="hljs-type">State</span> s s
<span class="hljs-title">put</span>    :: <span class="hljs-keyword">forall</span> s. s        -&gt; <span class="hljs-type">State</span> s <span class="hljs-type">Unit</span>
<span class="hljs-title">modify</span> :: <span class="hljs-keyword">forall</span> s. (s -&gt; s) -&gt; <span class="hljs-type">State</span> s <span class="hljs-type">Unit</span>
</code></pre><p><code>Control.Monad.State.Class</code>モジュールで与えられている型は、実際には次のようにもっと一般的です。</p><pre><code class="language-haskell"><span class="hljs-title">get</span>    :: <span class="hljs-keyword">forall</span> m s. <span class="hljs-type">MonadState</span> s m =&gt;             m s
<span class="hljs-title">put</span>    :: <span class="hljs-keyword">forall</span> m s. <span class="hljs-type">MonadState</span> s m =&gt; s        -&gt; m <span class="hljs-type">Unit</span>
<span class="hljs-title">modify</span> :: <span class="hljs-keyword">forall</span> m s. <span class="hljs-type">MonadState</span> s m =&gt; (s -&gt; s) -&gt; m <span class="hljs-type">Unit</span>
</code></pre><p><code>Control.Monad.State.Class</code>モジュールには「純粋な変更可能な状態を提供するモナド」への抽象化を可能にする <code>MonadState</code>(多変数)型クラスが定義されています。予想できると思いますが、 <code>State s</code>型構築子は <code>MonadState s</code>型クラスのインスタンスになっており、このクラスには他にも興味深いインスタンスが数多くあります。</p><p>特に、 <code>purescript-transformers</code>パッケージではモナド変換子 <code>WriterT</code>、 <code>ReaderT</code>、 <code>ExceptT</code>についての <code>MonadState</code>のインスタンスが提供されています。実際に、 <code>StateT</code>がモナド変換子スタックのどこかに現れ、 <code>StateT</code>より上のすべてが <code>MonadState</code>のインスタンスであれば、 <code>get</code>、 <code>put</code>、 <code>modify</code>を直接自由に使用することができます。</p><p>実は、これまで扱ってきた <code>ReaderT</code>、 <code>WriterT</code>、 <code>ExceptT</code>変換子についても、同じことが成り立っています。 <code>purescript-transformers</code>では、それらの操作をサポートするモナドの上に抽象化することを可能にする、主な変換子それぞれについての型クラスが定義されています。</p><p>上の <code>split</code>関数の場合、構築されたこのモナドスタックは型クラス <code>MonadState</code>、 <code>MonadWriter</code>、 <code>MonadError</code>それぞれのインスタンスです。これはつまり、 <code>lift</code>をまったく呼び出す必要がないことを意味します！まるでモナドスタック自体に定義されていたかのように、アクション <code>get</code>、 <code>put</code>、 <code>tell</code>、 <code>throwError</code>をそのまま使用することができます。</p><pre><code class="language-haskell"><span class="hljs-title">split</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">String</span>
<span class="hljs-title">split</span> = <span class="hljs-keyword">do</span>
  s &lt;- get
  tell [<span class="hljs-string">"The state is "</span> &lt;&gt; show s]
  <span class="hljs-keyword">case</span> s <span class="hljs-keyword">of</span>
    <span class="hljs-string">""</span> -&gt; throwError <span class="hljs-string">"Empty string"</span>
    _ -&gt; <span class="hljs-keyword">do</span>
      put (drop <span class="hljs-number">1</span> s)
      pure (take <span class="hljs-number">1</span> s)
</code></pre><p>この計算はまるで、可変状態、ロギング、エラー処理という３つの副作用に対応した、独自のプログラミング言語を拡張したかのようにみえます。しかしながら、内部的にはすべてはあくまで純粋な関数と普通のデータを使って実装されているのです。</p><h2>11.11 Alternative型クラス</h2><p><code>purescript-control</code>パッケージでは失敗しうる計算を操作するための抽象化がいくつか定義されています。そのひとつは <code>Alternative</code>型クラスです。</p><pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Functor</span> f &lt;= <span class="hljs-type">Alt</span> f <span class="hljs-keyword">where</span></span>
  alt :: <span class="hljs-keyword">forall</span> a. f a -&gt; f a -&gt; f a
<span class="hljs-class">
<span class="hljs-keyword">class</span> <span class="hljs-type">Alt</span> f &lt;= <span class="hljs-type">Plus</span> f <span class="hljs-keyword">where</span></span>
  empty :: <span class="hljs-keyword">forall</span> a. f a
<span class="hljs-class">
<span class="hljs-keyword">class</span> (<span class="hljs-type">Applicative</span> <span class="hljs-title">f</span>, <span class="hljs-type">Plus</span> <span class="hljs-title">f</span>) &lt;= <span class="hljs-type">Alternative</span> f
</span></code></pre><p><code>Alternative</code>は、失敗しうる計算のプロトタイプを提供する <code>empty</code>値、
エラーが起きたときに<strong>代替</strong>(Alternative)計算へ戻ってやり直す機能を提供する <code><|></code>演算子 という、2つの新しいコンビネータを提供しています。</p><p><code>Data.List</code>モジュールでは <code>Alternative</code>型クラスで型構築子を操作する2つの便利な関数を提供します。</p><pre><code class="language-haskell"><span class="hljs-title">many</span> :: <span class="hljs-keyword">forall</span> f a. <span class="hljs-type">Alternative</span> f =&gt; <span class="hljs-type">Lazy</span> (f (<span class="hljs-type">List</span> a)) =&gt; f a -&gt; f (<span class="hljs-type">List</span> a)
<span class="hljs-title">some</span> :: <span class="hljs-keyword">forall</span> f a. <span class="hljs-type">Alternative</span> f =&gt; <span class="hljs-type">Lazy</span> (f (<span class="hljs-type">List</span> a)) =&gt; f a -&gt; f (<span class="hljs-type">List</span> a)
</code></pre><p><code>many</code>コンビネータは計算を<strong>ゼロ回以上</strong>繰り返し実行するために <code>Alternative</code>型クラスを使用しています。 <code>some</code>コンビネータも似ていますが、成功するために少なくとも１回の計算を必要とします。</p><p>今回の <code>Parser</code>モナド変換子スタックの場合は、 <code>ExceptT</code>コンポーネントから導かれた、明らかな方法で失敗をサポートする、 <code>Alternative</code>のインスタンスが存在します。これは、構文解析器を複数回実行するために <code>many</code>関数と <code>some</code>関数を使うことができることを意味します。</p><pre><code class="language-text">> import Split
> import Control.Alternative

> runParser (many split) "test"
(Right (Tuple (Tuple ["t", "e", "s", "t"] "")
              [ "The state is \"test\""
              , "The state is \"est\""
              , "The state is \"st\""
              , "The state is \"t\""
              ]))
</code></pre><p>ここで、入力文字列 <code>"test"</code>は、１文字の文字列４つの配列を返すように、繰り返し分割されています。残った状態は空文字列で、ログは <code>split</code>コンビネータが４回適用されたことを示しています。</p><p><code>Alternative</code>型構築子の他の例としては、 <code>Maybe</code>や、 <code>Array</code>つまり配列の型構築子があります。</p><h2>11.12 モナド内包表記</h2><p><code>Control.MonadPlus</code>モジュールには <code>MonadPlus</code>と呼ばれる <code>Alternative</code>型クラスの若干の変形が定義されています。 <code>MonadPlus</code>はモナドと <code>Alternative</code>のインスタンスの両方である型構築子を補足します。</p><pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> (<span class="hljs-type">Monad</span> <span class="hljs-title">m</span>, <span class="hljs-type">Alternative</span> <span class="hljs-title">m</span>) &lt;= <span class="hljs-type">MonadZero</span> m

<span class="hljs-keyword">class</span> <span class="hljs-type">MonadZero</span> m &lt;= <span class="hljs-type">MonadPlus</span> m
</span></code></pre><p>実際、 <code>Parser</code>モナドは <code>MonadPlus</code>のインスタンスです。</p><p>以前に本書中で配列内包表記を扱ったとき、不要な結果をフィルタリングするため使われる <code>guard</code>関数を導入しました。実際は <code>guard</code>関数はもっと一般的で、 <code>MonadPlus</code>のインスタンスであるすべてのモナドに対して使うことができます。</p><pre><code class="language-haskell"><span class="hljs-title">guard</span> :: <span class="hljs-keyword">forall</span> m. <span class="hljs-type">MonadZero</span> m =&gt; <span class="hljs-type">Boolean</span> -&gt; m <span class="hljs-type">Unit</span>
</code></pre><p><code><|></code>演算子は失敗時のバックトラッキングをできるようにします。これがどのように役立つかを見るために、大文字だけに適合する <code>split</code>コンビネータの亜種を定義してみましょう。</p><pre><code class="language-haskell"><span class="hljs-title">upper</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">String</span>
<span class="hljs-title">upper</span> = <span class="hljs-keyword">do</span>
  s &lt;- split
  guard $ toUpper s == s
  pure s
</code></pre><p>ここで、文字列が大文字でない場合に失敗するよう <code>guard</code>を使用しています。このコードは前に見た配列内包表記とよく似ていることに注目してください。このように <code>MonadPlus</code>が使われており<strong>モナド内包表記</strong>(monad comprehensions)を構築するために参照することがあります。</p><h2>11.13 バックトラッキング</h2><p><code><|></code>演算子を使うと、失敗したときに別の代替計算へとバックトラックすることができます。これを確かめるために、小文字に一致するもう一つの構文解析器を定義してみましょう。</p><pre><code class="language-haskell"><span class="hljs-title">lower</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">String</span>
<span class="hljs-title">lower</span> = <span class="hljs-keyword">do</span>
  s &lt;- split
  guard $ toLower s == s
  pure s
</code></pre><p>これにより、まずもし最初の文字が大文字なら複数の大文字に適合し、さもなくばもし最初の文字が小文字なら複数の小文字に適合する、という構文解析器を定義することができます。</p><pre><code class="language-text">> upperOrLower = some upper <|> some lower
</code></pre><p>この構文解析器は、大文字と小文字が切り替わるまで、文字に適合し続けます。</p><pre><code class="language-text">> runParser upperOrLower "abcDEF"
(Right (Tuple (Tuple ["a","b","c"] ("DEF"))
              [ "The state is \"abcDEF\""
              , "The state is \"bcDEF\""
              , "The state is \"cDEF\""
              ]))
</code></pre><p><code>many</code>を使うと、文字列を小文字と大文字の要素に完全に分割することもできます。</p><pre><code class="language-text">> components = many upperOrLower

> runParser components "abCDeFgh"
(Right (Tuple (Tuple [["a","b"],["C","D"],["e"],["F"],["g","h"]] "")
              [ "The state is \"abCDeFgh\""
              , "The state is \"bCDeFgh\""
              , "The state is \"CDeFgh\""
              , "The state is \"DeFgh\""
              , "The state is \"eFgh\""
              , "The state is \"Fgh\""
              , "The state is \"gh\""
              , "The state is \"h\""
              ]))
</code></pre><p>繰り返しになりますが、これはモナド変換子がもたらす再利用性の威力を示しています。標準的な抽象化を再利用することで、バックトラック構文解析器を宣言型のスタイルでわずか数行のコードで書くことができました！</p><div class="exercise"><h2>演習</h2><ol>
<li>
<p>(簡単)<code>string</code>構文解析器の実装から <code>lift</code>関数の呼び出しを取り除いてください。新しい実装の型が整合していることを確認し、なぜそのようになるのかをよく納得しておきましょう。</p>
</li>
<li>
<p>(やや難しい)<code>string</code>構文解析器と <code>many</code>コンビネータを使って、文字列 <code>"a"</code>の連続と、それに続く文字列 <code>"b"</code>の連続からなる文字列を認識する構文解析器を書いてください。</p>
</li>
<li>
<p>(やや難しい)<code><|></code>演算子を使って、文字 <code>a</code>と文字 <code>b</code>が任意の順序で現れるような文字列を認識する構文解析器を書いてください。</p>
</li>
<li>
<p>(難しい)<code>Parser</code>モナドは次のように定義されるかもしれません。</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Parser</span> = <span class="hljs-type">ExceptT</span> <span class="hljs-type">Errors</span> (<span class="hljs-type">StateT</span> <span class="hljs-type">String</span> (<span class="hljs-type">WriterT</span> <span class="hljs-type">Log</span> <span class="hljs-type">Identity</span>))</span>
</code></pre>
<p>このように変更すると、構文解析関数にどのような影響を与えるでしょうか。</p>
</li>
</ol></div><h2>11.14 RWSモナド</h2><p>モナド変換子のある特定の組み合わせは、 <code>purescript-transformers</code>パッケージ内の単一のモナド変換子として提供されるのが一般的です。 <code>Reader</code>、 <code>Writer</code>、 <code>State</code>のモナドは、<strong>Reader-Writer-State</strong>モナド(<code>RWS</code>モナド)へと結合されます。このモナドは <code>RWST</code>モナド変換子と呼ばれる、対応するモナド変換子を持っています。</p><p>ここでは <code>RWS</code>モナドを使ってテキストアドベンチャーゲームの処理を設計していきます。</p><p><code>RWS</code>モナドは(戻り値の型に加えて)3つの型変数で定義されています。</p><pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">RWS</span> r w s = <span class="hljs-type">RWST</span> r w s <span class="hljs-type">Identity</span></span>
</code></pre><p>副作用を提供しない <code>Identity</code>にベースモナドを設定することで、 <code>RWS</code>モナドが独自のモナド変換子の観点から定義されていることに注意してください。</p><p>第1型引数 <code>r</code>は大域的な設定の型を表します。第2型引数 <code>w</code>はログを蓄積するために使用するモノイド、第3型引数 <code>s</code>は可変状態の型を表しています。</p><p>このゲームの場合には、大域的な設定は <code>Data.GameEnvironment</code>モジュールの <code>GameEnvironment</code>と呼ばれる型で定義されています。</p><pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">PlayerName</span> = <span class="hljs-type">String</span></span>

<span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">GameEnvironment</span> = <span class="hljs-type">GameEnvironment</span></span>
  { playerName    :: <span class="hljs-type">PlayerName</span>
  , debugMode     :: <span class="hljs-type">Boolean</span>
  }
</code></pre><p><code>GameEnvironment</code>では、プレイヤー名と、ゲームがデバッグモードで動作しているか否かを示すフラグが定義されています。これらのオプションは、モナド変換子を実行するときにコマンドラインから設定されます。</p><p>可変状態は <code>Data.GameState</code>モジュールの <code>GameState</code>と呼ばれる型で定義されています。</p><pre><code class="language-haskell"><span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Data.Map <span class="hljs-keyword">as</span> M
<span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Data.Set <span class="hljs-keyword">as</span> S

<span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">GameState</span> = <span class="hljs-type">GameState</span></span>
  { items       :: <span class="hljs-type">M</span>.<span class="hljs-type">Map</span> <span class="hljs-type">Coords</span> (<span class="hljs-type">S</span>.<span class="hljs-type">Set</span> <span class="hljs-type">GameItem</span>)
  , player      :: <span class="hljs-type">Coords</span>
  , inventory   :: <span class="hljs-type">S</span>.<span class="hljs-type">Set</span> <span class="hljs-type">GameItem</span>
  }
</code></pre><p><code>Coords</code>データ型は2次元平面の点を表し、 <code>GameItem</code>データ型はゲーム内のアイテムです。</p><pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">GameItem</span> = <span class="hljs-type">Candle</span> | <span class="hljs-type">Matches</span></span>
</code></pre><p><code>GameState</code>型はソートされたマップを表す <code>Map</code>とソートされた集合を表す <code>Set</code>という2つの新しいデータ構造を使っています。 <code>items</code>プロパティは、そのゲーム平面上の座標と、ゲームアイテムの集合へのマッピングになっています。 <code>player</code>プロパティはプレイヤーの現在の座標を格納しており、 <code>inventory</code>プロパティは現在プレイヤーが保有するゲームアイテムの集合です。</p><p><code>Map</code>と <code>Set</code>のデータ構造はキーによってソートされ、 <code>Ord</code>型クラスの任意の型をキーとして使用することができます。これは今回のデータ構造のキーが完全に順序付けできることを意味します。</p><p>ゲームのアクションを書くために、 <code>Map</code>と <code>Set</code>構造がどのように使っていくのかを見ていきましょう。</p><p>ログとしては <code>List String</code>モノイドを使います。 <code>RWS</code>を使って <code>Game</code>モナドのための型同義語を定義しておきます。</p><pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Log</span> = <span class="hljs-type">L</span>.<span class="hljs-type">List</span> <span class="hljs-type">String</span></span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Game</span> = <span class="hljs-type">RWS</span> <span class="hljs-type">GameEnvironment</span> <span class="hljs-type">Log</span> <span class="hljs-type">GameState</span></span>
</code></pre><h2>11.15 ゲームロジックの実装</h2><p>今回は、 <code>Reader</code>モナド、 <code>Writer</code>モナド、 <code>State</code>モナドのアクションを再利用し、 <code>Game</code>モナドで定義されている単純なアクションを組み合わせてゲームを構築していきます。このアプリケーションの最上位では、 <code>Game</code>モナドで純粋な計算を実行しており、 <code>Eff</code>モナドはコンソールにテキストを出力するような追跡可能な副作用へと結果を変換するために使っています。</p><p>このゲームで最も簡単なアクションのひとつは <code>has</code>アクションです。このアクションはプレイヤーの持ち物に特定のゲームアイテムが含まれているかどうかを調べます。これは次のように定義されます。</p><pre><code class="language-haskell"><span class="hljs-title">has</span> :: <span class="hljs-type">GameItem</span> -&gt; <span class="hljs-type">Game</span> <span class="hljs-type">Boolean</span>
<span class="hljs-title">has</span> item = <span class="hljs-keyword">do</span>
  <span class="hljs-type">GameState</span> state &lt;- get
  pure $ item `<span class="hljs-type">S</span>.member` state.inventory
</code></pre><p>この関数は、現在のゲームの状態を読み取るために <code>Monad.State</code>型クラスで定義されている <code>get</code>アクションを使っており、指定した <code>GameItem</code>が持ち物の <code>Set</code>のなかに出現するかどうかを調べるために <code>Data.Set</code>で定義されている <code>member</code>関数を使っています。</p><p>他にも <code>pickUp</code>アクションがあります。現在の位置にゲームアイテムがある場合、プレイヤーの持ち物にそのアイテムを追加します。これには <code>MonadWriter</code>と <code>MonadState</code>型クラスのアクションを使っています。まず、現在のゲームの状態を読み取ります。</p><pre><code class="language-haskell"><span class="hljs-title">pickUp</span> :: <span class="hljs-type">GameItem</span> -&gt; <span class="hljs-type">Game</span> <span class="hljs-type">Unit</span>
<span class="hljs-title">pickUp</span> item = <span class="hljs-keyword">do</span>
  <span class="hljs-type">GameState</span> state &lt;- get
</code></pre><p>次に <code>pickUp</code>は現在の位置にあるアイテムの集合を検索します。これは <code>Data.Map</code>で定義された <code>lookup</code>関数を使って行います。</p><pre><code class="language-haskell">  <span class="hljs-keyword">case</span> state.player <span class="hljs-string">`M.lookup`</span> state.items <span class="hljs-keyword">of</span>
</code></pre><p><code>lookup</code>関数は <code>Maybe</code>型構築子で示されたオプショナルな結果を返します。 <code>lookup</code>関数は、キーがマップにない場合は <code>Nothing</code>を返し、それ以外の場合は <code>Just</code>構築子で対応する値を返します。</p><p>関心があるのは、指定されたゲームアイテムが対応するアイテムの集合に含まれている場合です。 <code>member</code>関数を使うとこれを調べることができます。</p><pre><code class="language-haskell">    <span class="hljs-type">Just</span> items | item `<span class="hljs-type">S</span>.member` items -&gt; <span class="hljs-keyword">do</span>
</code></pre><p>この場合、 <code>put</code>を使ってゲームの状態を更新し、 <code>tell</code>を使ってログにメッセージを追加します。</p><pre><code class="language-haskell">      <span class="hljs-keyword">let</span> newItems = M.update (Just &lt;&lt;<span class="xml"><span class="hljs-tag">&lt; <span class="hljs-attr">S.delete</span> <span class="hljs-attr">item</span>) <span class="hljs-attr">state.player</span> <span class="hljs-attr">state.items</span>
          <span class="hljs-attr">newInventory</span> = <span class="hljs-string">S.insert</span> <span class="hljs-attr">item</span> <span class="hljs-attr">state.inventory</span>
      <span class="hljs-attr">put</span> $ <span class="hljs-attr">GameState</span> <span class="hljs-attr">state</span> { <span class="hljs-attr">items</span>     = <span class="hljs-string">newItems</span>
                            , <span class="hljs-attr">inventory</span> = <span class="hljs-string">newInventory</span>
                            }
      <span class="hljs-attr">tell</span> (<span class="hljs-attr">L.singleton</span> ("<span class="hljs-attr">You</span> <span class="hljs-attr">now</span> <span class="hljs-attr">have</span> <span class="hljs-attr">the</span> " &lt;&gt;</span> show item))
</span></code></pre><p>ここで、 <code>MonadState</code>と <code>MonadWriter</code>の両方について <code>Game</code>モナド変換子スタックについての適切なインスタンスが存在するので、２つの計算はどちらも <code>lift</code>は必要ないことに注意してください。</p><p><code>put</code>の引数では、レコード更新を使ってゲームの状態の <code>items</code>と <code>inventory</code>フィールドを変更しています。特定のキーの値を変更するには <code>Data.Map</code>の <code>update</code>関数を使います。このとき、 <code>delete</code>関数を使い指定したアイテムを集合から取り除くことで、プレイヤーの現在の位置にあるアイテムの集合を変更します。</p><p>最後に、 <code>pickUp</code>関数は <code>tell</code>を使ってユーザに次のように通知することにより、残りの場合を処理します。</p><pre><code class="language-haskell">    _ -&gt; tell (<span class="hljs-type">L</span>.singleton <span class="hljs-string">"I don't see that item here."</span>)
</code></pre><p><code>Reader</code>モナドを使う例として、 <code>debug</code>コマンドのコードを見てみましょう。ゲームがデバッグモードで実行されている場合、このコマンドを使うとユーザは実行時にゲームの状態を調べることができます。</p><pre><code class="language-haskell">  <span class="hljs-type">GameEnvironment</span> env &lt;- ask
  <span class="hljs-keyword">if</span> env.debugMode
    <span class="hljs-keyword">then</span> <span class="hljs-keyword">do</span>
      state &lt;- get
      tell (<span class="hljs-type">L</span>.singleton (show state))
    <span class="hljs-keyword">else</span> tell (<span class="hljs-type">L</span>.singleton <span class="hljs-string">"Not running in debug mode."</span>)
</code></pre><p>ここでは、ゲームの設定を読み込むために <code>ask</code>アクションを使用しています。繰り返しますが、どんな計算の <code>lift</code>も必要なく、同じdo記法ブロック内で <code>MonadState</code>、 <code>MonadReader</code>、 <code>MonadWriter</code>型クラスで定義されているアクションを使うことができることに注意してください。</p><p><code>debugMode</code>フラグが設定されている場合、 <code>tell</code>アクションを使ってログに状態が追加されます。そうでなければ、エラーメッセージが追加されます。</p><p><code>Game.purs</code>モジュールでは、 <code>MonadState</code>型クラス、 <code>MonadReader</code>型クラス、 <code>MonadWriter</code>型クラスでそれぞれ定義されたアクションだけを使って、同様のアクションが定義されています。</p><h2>11.16 計算の実行</h2><p>このゲームロジックは <code>RWS</code>モナドで動くため、ユーザのコマンドに応答するためには計算を実行する必要があります。</p><p>このゲームのフロントエンドは、 <code>yargs</code>コマンドライン構文解析ライブラリへのApplicativeなインターフェイスを提供する <code>purescript-yargs</code>パッケージと、対話的なコンソールベースのアプリケーションを書くことを可能にするNodeJSの <code>readline</code>モジュールをラップする <code>purescript-node-readline</code>パッケージという２つのパッケージで構成されています。</p><p>このゲームロジックへのインタフェースは <code>Game</code>モジュール内の関数 <code>game</code>によって提供されます。</p><pre><code class="language-haskell">game :: <span class="hljs-built_in">Array</span> <span class="hljs-built_in">String</span> -&gt; Game Unit
</code></pre><p>この計算を実行するには、ユーザが入力した単語のリストを文字列の配列として渡してから、 <code>runRWS</code>を使って <code>RWS</code>の計算を実行します。</p><pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">RWSResult</span> state result writer = <span class="hljs-type">RWSResult</span> state result writer</span>

<span class="hljs-title">runRWS</span> :: <span class="hljs-keyword">forall</span> r w s a. <span class="hljs-type">RWS</span> r w s a -&gt; r -&gt; s -&gt; <span class="hljs-type">RWSResult</span> s a w
</code></pre><p><code>runRWS</code>は <code>runReader</code>、 <code>runWriter</code>、 <code>runState</code>を組み合わせたように見えます。これは、引数として大域的な設定および初期状態をとり、ログ、結果、最的な終状態を含むレコードを返します。</p><p>このアプリケーションのフロントエンドは、次の型シグネチャを持つ関数 <code>runGame</code>によって定義されます。</p><pre><code class="language-haskell"><span class="hljs-title">runGame</span> :: <span class="hljs-keyword">forall</span> eff . <span class="hljs-type">GameEnvironment</span>
  -&gt; <span class="hljs-type">Eff</span> ( exception :: <span class="hljs-type">EXCEPTION</span>
         , readline :: <span class="hljs-type">RL</span>.<span class="hljs-type">READLINE</span>
         , console :: <span class="hljs-type">CONSOLE</span>
         | eff
         ) <span class="hljs-type">Unit</span>
</code></pre><p><code>Console</code>作用は、この関数が <code>purescript-node-readline</code>パッケージを使ってコンソールを介してユーザと対話することを示しています。 <code>runGame</code>は関数の引数としてのゲームの設定とります。</p><p><code>purescript-node-readline</code>パッケージでは、端末からのユーザ入力を扱う <code>Eff</code>モナドのアクションを表す <code>LineHandler</code>型が提供されています。対応するAPIは次のとおりです。</p><pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">LineHandler</span> eff a = <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Eff</span> eff a</span>

<span class="hljs-title">setLineHandler</span> :: <span class="hljs-keyword">forall</span> eff a. <span class="hljs-type">Interface</span>
                -&gt; <span class="hljs-type">LineHandler</span> (readline :: <span class="hljs-type">READLINE</span> | eff) a
                -&gt; <span class="hljs-type">Eff</span> (readline :: <span class="hljs-type">READLINE</span> | eff) <span class="hljs-type">Unit</span>
</code></pre><p><code>Interface</code>型はコンソールのハンドルを表しており、コンソールと対話する関数への引数として渡されます。 <code>createInterface</code>関数を使用すると <code>Interface</code>を作成することができます。</p><pre><code class="language-haskell"><span class="hljs-title">runGame</span> env = <span class="hljs-keyword">do</span>
  interface &lt;- createConsoleInterface noCompletion
</code></pre><p>最初の手順はコンソールにプロンプトを設定することです。 <code>interface</code>ハンドルを渡し、プロンプト文字列とインデントレベルを提供します。</p><pre><code class="language-haskell"><span class="hljs-title">setPrompt</span> <span class="hljs-string">"&gt; "</span> <span class="hljs-number">2</span> interface
</code></pre><p>今回は <code>lineHandler</code>関数を実装してみましょう。 <code>lineHandler</code>は <code>let</code>宣言内の補助関数を使って次のように定義されています。</p><pre><code class="language-haskell"><span class="hljs-title">lineHandler</span> :: <span class="hljs-type">GameState</span> -&gt; <span class="hljs-type">String</span>
             -&gt; <span class="hljs-type">Eff</span> ( exception :: <span class="hljs-type">EXCEPTION</span>
                    , console :: <span class="hljs-type">CONSOLE</span>
                    , readline :: <span class="hljs-type">RL</span>.<span class="hljs-type">READLINE</span>
                    | eff
                    ) <span class="hljs-type">Unit</span>
<span class="hljs-title">lineHandler</span> currentState input = <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">case</span> runRWS (game (split <span class="hljs-string">" "</span> input)) env currentState <span class="hljs-keyword">of</span>
    <span class="hljs-type">RWSResult</span> state _ written -&gt; <span class="hljs-keyword">do</span>
      for_ written log
      setLineHandler interface $ lineHandler state
  prompt interface
  pure unit
</code></pre><p><code>lineHandler</code>では <code>env</code>という名前のゲーム構成や、 <code>interface</code>という名前のコンソールハンドルを参照しています。</p><p>このハンドラは追加の最初の引数としてゲームの状態を取ります。ゲームのロジックを実行するために <code>runRWS</code>にゲームの状態を渡さなければならないので、これは必要となっています。</p><p>このアクションが最初に行うことは、 <code>Data.String</code>モジュールの <code>split</code>関数を使用して、ユーザーの入力を単語に分割することです。それから、ゲーム環境と現在のゲームの状態を渡し、 <code>runRWS</code>を使用して(<code>RWS</code>モナドで)<code>game</code>アクションを実行しています。</p><p>純粋な計算であるゲームロジックを実行し、画面にすべてのログメッセージを出力して、ユーザに次のコマンドのプロンプトを表示する必要があります。 <code>for_</code>アクションは(<code>List String</code>型の)ログを走査し、コンソールにその内容を出力するために使われています。そして <code>setLineHandler</code>を使って <code>lineHandler</code>関数を更新することで、ゲームの状態を更新します。最後に <code>prompt</code>アクションを使ってプロンプトが再び表示しています。</p><p><code>runGame</code>関数ではコンソールインターフェイスに最初のlineHandlerを設定して、最初のプロンプトを表示します。</p><pre><code class="language-haskell">  setLineHandler interface $ lineHandler initialGameState
  prompt interface
</code></pre><div class="exercise"><h2>演習</h2><ol>
<li>
<p>(やや難しい) ゲームフィールド上にあるすべてのゲームアイテムをユーザの持ちものに移動する新しいコマンド <code>cheat</code>を実装してください。</p>
</li>
<li>
<p>(難しい) <code>RWS</code>モナドの <code>Writer</code>コンポーネントは、エラーメッセージと情報メッセージの２つの種類のメッセージのために使われています。このため、コードのいくつかの箇所では、エラーの場合を扱うためにcase式を使用しています。</p>
<p>エラーメッセージを扱うのに <code>ExceptT</code>モナド変換子を使うようにし、情報メッセージを扱うのに <code>RWS</code>を使うようにするよう、コードをリファクタリングしてください。</p>
</li>
</ol></div><h2>11.17 コマンドラインオプションの扱い</h2><p>このアプリケーションの最後の部品は、コマンドラインオプションの解析と <code>GameEnvironment</code>レコードを作成する役目にあります。このためには <code>purescript-yargs</code>パッケージを使用します。</p><p><code>purescript-yargs</code>は<strong>Applicativeなコマンドラインオプション構文解析器</strong>の例です。Applicative関手を使うと、いろいろな副作用の型を表す型構築子まで任意個数の引数の関数をを持ち上げられることを思い出してください。 <code>purescript-yargs</code>パッケージの場合には、コマンドラインオプションからの読み取りの副作用を追加する <code>Y</code>関手が興味深い関手になっています。これは次のようなハンドラを提供しています。</p><pre><code class="language-haskell"><span class="hljs-title">runY</span> :: <span class="hljs-keyword">forall</span> a eff. <span class="hljs-type">YargsSetup</span> -&gt;
                      <span class="hljs-type">Y</span> (<span class="hljs-type">Eff</span> (exception :: <span class="hljs-type">EXCEPTION</span>, console :: <span class="hljs-type">CONSOLE</span> | eff) a) -&gt;
                      <span class="hljs-type">Eff</span> (exception :: <span class="hljs-type">EXCEPTION</span>, console :: <span class="hljs-type">CONSOLE</span> | eff) a
</code></pre><p>この関数の使いかたは、例で示すのが最も適しているでしょう。このアプリケーションの <code>main</code>関数は <code>runY</code>を使って次のように定義されています。</p><pre><code class="language-haskell"><span class="hljs-title">main</span> = runY (usage <span class="hljs-string">"$0 -p &lt;player name&gt;"</span>) $ map runGame env
</code></pre><p>最初の引数は <code>yargs</code>ライブラリを設定するために使用されます。今回の場合、使用方法のメッセージだけを提供していますが、 <code>Node.Yargs.Setup</code>モジュールには他にもいくつかのオプションを提供しています。</p><p>2番目の引数では、 <code>Y</code>型構築子まで <code>runGame</code>関数を持ち上げるために <code><$></code>コンビネータを使用しています。引数 <code>env</code>は <code>where</code>節でApplicative演算子 <code><$></code>、 <code><*></code>を使って構築されています。</p><pre><code class="language-haskell">  <span class="hljs-keyword">where</span>
  env :: <span class="hljs-type">Y</span> <span class="hljs-type">GameEnvironment</span>
  env = gameEnvironment
          &lt;$&gt; yarg <span class="hljs-string">"p"</span> [<span class="hljs-string">"player"</span>]
                   (<span class="hljs-type">Just</span> <span class="hljs-string">"Player name"</span>)
                   (<span class="hljs-type">Right</span> <span class="hljs-string">"The player name is required"</span>)
                   false
          &lt;*&gt; flag <span class="hljs-string">"d"</span> [<span class="hljs-string">"debug"</span>]
                   (<span class="hljs-type">Just</span> <span class="hljs-string">"Use debug mode"</span>)
</code></pre><p><code>PlayerName -> Boolean -> GameEnvironment</code>という型を持つこの <code>gameEnvironment</code>関数は、 <code>Y</code>まで持ち上げられています。このふたつの引数は、コマンドラインオプションからプレイヤー名とデバッグフラグを読み取る方法を指定しています。最初の引数は <code>-p</code>もしくは <code>--player</code>オプションで指定されるプレイヤー名オプションについて記述しており、２つ目の引数は <code>-d</code>もしくは <code>--debug</code>オプションで指定されるデバッグモードフラグについて記述しています。</p><p>これは <code>Node.Yargs.Applicative</code>モジュールで定義されているふたつの基本的な関数について示しています。 <code>yarg</code>は(型 <code>String</code>、 <code>Number</code>、 <code>Boolean</code>の)オプショナルな引数を取りコマンドラインオプションを定義し、 <code>flag</code>は型 <code>Boolean</code>のコマンドラインフラグを定義しています。</p><p>Applicative演算子によるこの記法を使うことで、コマンドラインインターフェイスに対してコンパクトで宣言的な仕様を与えることが可能になったことに注意してください。また、 <code>env</code>の定義で <code>runGame</code>関数に新しい引数を追加し、 <code><*></code>を使って追加の引数まで <code>runGame</code>を持ち上げるだけで、簡単に新しいコマンドライン引数を追加することができます。</p><div class="exercise"><h2>演習</h2><ol>
<li>(やや難しい)<code>GameEnvironment</code>レコードに新しい真偽値のプロパティ <code>cheatMode</code>を追加してください。 また、 <code>yargs</code>設定に、チートモードを有効にする新しいコマンドラインフラグ <code>-c</code>を追加してください。チートモードが有効になっていない場合、 <code>cheat</code>コマンドは禁止されなければなりません。</li>
</ol></div><h2>まとめ</h2><p>モナド変換子を使用したゲームの純粋な定義、コンソールを使用したフロントエンドを構築するための <code>Eff</code>モナドなと、この章ではこれまで学んできた手法を実用的に使いました。</p><p>ユーザインターフェイスからの実装を分離したので、ゲームの別のフロントエンドを作成することも可能でしょう。例えば、 <code>Eff</code>モナドでCanvas APIやDOMを使用して、ブラウザでゲームを描画するようなことができるでしょう。</p><p>モナド変換子によって、型システムによって作用が追跡される命令型のスタイルで、安全なコードを書くことができることを見てきました。また、型クラスは、コードの再利用を可能にするモナドによって提供される、アクション上の抽象化の強力な方法を提供します。標準的なモナド変換子を組み合わせることにより、 <code>Alternative</code>や <code>MonadPlus</code>のような標準的な抽象化を使用して、役に立つモナドを構築することができました。</p><p>モナド変換子は、高階多相や多変数型クラスなどの高度な型システムの機能を利用することによって記述することができ、表現力の高いコードの優れた実演となっています。</p><p>次の章では、非同期なJavaScriptのコードにありがちな不満、<strong>コールバック地獄</strong>の問題に対して、モナド変換子がどのような洗練された解決策を与えるのかを見ていきます。</p><a href="chapter12.html"><div class="next">次の第12章を読む</div></a><p class="home"><a href="index.html">目次に戻る</a></p></div>
  </div>


</body></html>