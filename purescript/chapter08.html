<!DOCTYPE html>
<meta charset="UTF-8">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>実例によるPureScript</title>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="icon" type="image/png" href="favicon-96x96.png" sizes="96x96">
  <link rel="stylesheet" href="github-markdown.css" type="text/css"/>
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Roboto"/>
  <style>
    body {
      background-color: #f5f5f5;
    }

    div.main {
        min-width: 540px;
        max-width: 980px;
        margin: 0 auto;
        
        background-color: white;
        border: solid 1px #cbcbcb;
        box-shadow: 0 0 15px rgba(0,0,0,0.1);

        font-family: 'Roboto', 'Meiryo UI', sans-serif !important;
    }

    div.header img.logo:hover {
      background-color: rgba(255, 255, 255, 0.3);
    }

    div.header {
      background-color: #1d222d;
      color: white;
      padding: 50px;
    }

    div.header a {
      color: white;
      text-decoration: none;
    }

    div.header a:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }

    div.header h1 {
      letter-spacing: 0.2em;
      border-bottom: solid 1px rgba(255, 255, 255, 0.4);
      padding: 0.4em;
    }

    div.header p.author {
      font-family: 'Roboto', sans-serif;
    }

    div.content {
        padding: 30px;

        font-family: 'Roboto', 'Meiryo UI', sans-serif !important;
    }

    div.content a {
      color: #c4953a;
      text-decoration: none;
    }



    .main ol {
        list-style-type: decimal;
    }
    .main ol ol {
        list-style-type: decimal;
    }
    .main ol ol ol {
        list-style-type: decimal;
    }

    .main blockquote {
      color: #333;
    }

    .markdown code {
      white-space: pre;
      word-wrap: keep-all !important;  
    }

    /* Bug Workaround for Readium */
    .main h1, h2, h3, h4, h5, h6 {
      position: static !important;
      font-family: serif;
      font-weight: bold;
      letter-spacing: 0.12em;
    }

    .columns2 {
      -webkit-column-count: 2; /* Chrome, Safari, Opera */
      -moz-column-count: 2; /* Firefox */
      column-count: 2;
    }

    .columns3 {
      -webkit-column-count: 3; /* Chrome, Safari, Opera */
      -moz-column-count: 3; /* Firefox */
      column-count: 3;
    }    

    table.sourceCode tr {
      padding: 0;
      border: none;
    }

    table.sourceCode td {
      padding: 0;
      border: none;
    }

    table.sourceCode pre {
      margin: 0;
      border: none;
    }

    @media print {
      body {
        background-color: transparent;
      }

      .previous {
        visibility: hidden;
      }

      .main {
        font-family: 'MS PMincho', Serif;
        text-justify: inter-cluster;

        background-color: transparent;
        border: none 0px transparent;
        box-shadow: none;
      }
      .main h1, h2, h3, h4, h5, h6 {
        position: static !important;
      
      }
      pre {
        overflow: visible !important;
      }
    }

    .sourceCode, .shell {
      font-family: 'Courier New', Monospace;
      
    }

  </style>



</head>

<body>
  <div class="main">
    <div class="header" style="position:relative;">
      <a href="/purescript/">
          <img class="logo" src="logo-shadow.png"  style="display:block; position:absolute; left:50px;">
      </a>
      <div class="title" style="margin-left: 220px; position:relative; left:0px; right:0px;">
          <h1 id="実例によるpurescript">実例によるPureScript</h1>
          <p>ウェブのための関数型プログラミング</p>
          <p class="author"><a href="https://leanpub.com/purescript/read">Phil Freeman, &quot;PureScript by Example - Functional Programming for the Web&quot;</a></p>
      </div>
      <div style="clear:both;"></div>
    </div>

    <div class="markdown-body content">
      <p class="previous" style="visibility:hidden;"><a href="index.html">&lt; 目次に戻る</a></p>
<h1 id="effモナド"><span class="header-section-number">8</span> Effモナド</h1>
<h2 id="この章の目標"><span class="header-section-number">8.1</span> この章の目標</h2>
<p>第7章では、オプショナルな型やエラーメッセージ、データの検証など、<strong>副作用</strong>を扱いを抽象化するApplicative関手を導入しました。この章では、より表現力の高い方法で副作用を扱うための別の抽象化、<strong>モナド</strong>を導入します。</p>
<p>この章の目的は、なぜモナドが便利な抽象化なのか、<strong>do記法</strong>とどう関係するのかについて説明することです。ブラウザでユーザインターフェイスを構築する副作用を扱うためのある種のモナドを使って、前の章の住所録の例を作ることにしましょう。これから扱うEffモナドは、PureScriptにおけるとても重要なモナドです。Effモナドはいわゆる<strong>ネイティブな</strong>作用をカプセル化するのに使われます。</p>
<h2 id="プロジェクトの準備"><span class="header-section-number">8.2</span> プロジェクトの準備</h2>
<p>このプロジェクトのソースコードは前の章のソースコードの上に構築しますが、そのソースファイルを含めるようにGruntビルドスクリプトを使用しています。</p>
<p>コー​​ドは3つのモジュールに分かれています。</p>
<ul>
<li><code>Main</code> - アプリケーションへのエントリポイントを提供します。</li>
<li><code>Data.AddressBook.UI</code> - ブラウザのユーザインターフェースをレンダリングするための関数を提供します。</li>
<li><code>Control.Monad.Eff.DOM</code> - DOMを操作する関数の簡単なライブラリを提供します。</li>
</ul>
<p>このプロジェクトを実行するには、Gruntでビルドし、<code>html/index.html</code>ファイルをウェブブラウザで開いてください。</p>
<h2 id="モナドとdo記法"><span class="header-section-number">8.3</span> モナドとdo記法</h2>
<p>do記法は<strong>配列内包表記</strong>を扱うときに最初に導入されました。配列内包表記は <code>Data.Array</code>モジュールの<code>concatMap</code>関数の構文糖として提供されています。</p>
<p>次の例を考えてみましょう。２つのサイコロを振って出た目を数え、出た目の合計が<code>n</code>のときそれを得点とすることを考えます。次のような非決定的なアルゴリズムを使うとこれを実現することができます。</p>
<ul>
<li>最初の投擲で値<code>x</code>を<strong>選択</strong>します</li>
<li>２回め投擲で値<code>y</code>を<strong>選択</strong>します</li>
<li>もし<code>x</code>と <code>y</code>の和が<code>n</code>なら組<code>{x, y}</code>を返し、そうでなければ失敗します</li>
</ul>
<p>配列内包表記を使うと、この非決定的アルゴリズムを自然に書くことができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">countThrows ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> [[<span class="dt">Number</span>]]
countThrows n <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> range <span class="dv">1</span> <span class="dv">6</span>
  y <span class="ot">&lt;-</span> range <span class="dv">1</span> <span class="dv">6</span>
  <span class="kw">if</span> x <span class="fu">+</span> y <span class="fu">==</span> n <span class="kw">then</span> return [x, y] <span class="kw">else</span> empty</code></pre>
<p><code>psci</code>で動作を見てみましょう。</p>
<pre class="text"><code>&gt; countThrows 10
[[4,6],[5,5],[6,4]]

&gt; countThrows 12  
[[6,6]]</code></pre>
<p>前の章では、<strong>オプショナルな値</strong>に対応したより大きなプログラミング言語へとPureScriptの関数を埋め込む、<code>Maybe</code>Applicative関手についての直感的理解を養いました。同様に<strong>配列モナド</strong>についても、<strong>非決定選択</strong>に対応したより大きなプログラミング言語へPureScriptの関数を埋め込む、というような直感的理解を得ることができます。</p>
<p>一般に、ある型構築子<code>m</code>のモナドは、型<code>m a</code>の値を持つdo記法を使う方法を提供します。上の配列内包表記では、すべての行に何らかの型<code>a</code>についての型<code>[a]</code>の計算が含まれていることに注目してください。一般に、do記法ブロックのすべての行は、何らかの型<code>a</code>とモナド<code>m</code>について、型<code>m a</code>の計算を含んでいます。モナド<code>m</code>はすべての行で同じでなければなりません(つまり、副作用の種類は固定されます)が、型<code>a</code>は異なることもあります(言い換えると、ここの計算は異なる型の結果を持つことができます)。</p>
<p>型構築子<code>Maybe</code>が適用された、do記法の別の例を見てみましょう。XMLノードを表す型<code>XML</code>と演算子があるとします。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&lt;/&gt;) ::</span> <span class="dt">XML</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">XML</span></code></pre>
<p>この演算子はノードの子の要素を探し、もしそのような要素が存在しなければ<code>Nothing</code>を返します。</p>
<p>この場合、do記法を使うと深い入れ子になった要素を検索することができます。XML文書として符号化された利用者情報から、利用者の住んでいる市町村を読み取りたいとします。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">userCity ::</span> <span class="dt">XML</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">XML</span>
userCity root <span class="fu">=</span> <span class="kw">do</span>
  prof <span class="ot">&lt;-</span> root <span class="fu">&lt;/&gt;</span> <span class="st">&quot;profile&quot;</span>
  addr <span class="ot">&lt;-</span> prof <span class="fu">&lt;/&gt;</span> <span class="st">&quot;address&quot;</span>
  city <span class="ot">&lt;-</span> addr <span class="fu">&lt;/&gt;</span> <span class="st">&quot;city&quot;</span>
  return city</code></pre>
<p><code>userCity</code>関数は子の要素である<code>profile</code>を探し、<code>profile</code>要素の中にある<code>address</code>要素、最後に<code>address</code>要素から<code>city</code>要素を探します。これらの要素のいずれかが欠落している場合は、返り値は<code>Nothing</code>になります。そうでなければ、返り値は <code>city</code>ノードから<code>Just</code>を使って構築されています。</p>
<p>最後の行の <code>return</code>関数は予約語ではないことを思い出してください。<code>return</code>は実際にすべての <code>Applicative</code>関手について定義されている<code>pure</code>関数の別名です。JavaScriptのreturn文を連想するかもしれませんが、関数の途中での復帰とはまったく関係がありません。最後の行を<code>Just city</code>へ変更しても同じように正しく動きます。</p>
<h2 id="モナド型クラス"><span class="header-section-number">8.4</span> モナド型クラス</h2>
<p><code>Monad</code>型クラスは次のように定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Apply</span> m) <span class="fu">&lt;=</span> <span class="dt">Bind</span> m <span class="kw">where</span>
<span class="ot">  (&gt;&gt;=) ::</span> forall a b<span class="fu">.</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b

<span class="kw">class</span> (<span class="dt">Applicative</span> m, <span class="dt">Bind</span> m) <span class="fu">&lt;=</span> <span class="dt">Monad</span> m</code></pre>
<p>ここで鍵となる関数は<code>Bind</code>型クラスで定義されている演算子<code>=&gt;&gt;</code>で、これは「束縛」(bind)と呼ばれています。<code>Monad</code>型クラスは、すでに見てきた<code>Applicative</code>型クラスの操作で<code>Bind</code>を拡張します。</p>
<p><code>Bind</code>型クラスの例をいくつか見てみるのがわかりやすいでしょう。配列についての<code>Bind</code>の妥当な定義は次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> bindArray ::</span> <span class="dt">Bind</span> [] <span class="kw">where</span>
  (<span class="fu">&gt;&gt;=</span>) xs f <span class="fu">=</span> f <span class="ot">`concatMap`</span> xs</code></pre>
<p>これは以前にほのめかした配列内包表記と<code>concatMap</code>関数の関係を説明しています。</p>
<p><code>Maybe</code>型構築子についての<code>Bind</code>の実装は次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> bindMaybe ::</span> <span class="dt">Bind</span> <span class="dt">Maybe</span> <span class="kw">where</span>
  (<span class="fu">&gt;&gt;=</span>) <span class="dt">Nothing</span>  _ <span class="fu">=</span> <span class="dt">Nothing</span>
  (<span class="fu">&gt;&gt;=</span>) (<span class="dt">Just</span> a) f <span class="fu">=</span> f a</code></pre>
<p>この定義はdo記法ブロックを通じて伝播された欠落した値についての直感的理解を補強するものです。</p>
<p><code>Bind</code>型クラスとdo記法がどのように関係しているかを見て行きましょう。最初に何らかの計算結果から値を束縛するような、簡単などdo記法ブロックについて考えてみましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span> value <span class="ot">&lt;-</span> someComputation
   whatToDoNext</code></pre>
<p>PureScriptコンパイラはこのようなパターンを見つけるたびにコードを次にように置き換えます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">someComputation <span class="fu">&gt;&gt;=</span> \value <span class="ot">-&gt;</span> whatToDoNext</code></pre>
<p>この計算<code>whatToDoNext</code>は<code>value</code>に依存することができます。</p>
<p>連続した複数の束縛がある場合でも、この規則が先頭のほうから複数回適用されます。例えば、先ほど見た<code>userCity</code>の例では次のように構文糖が脱糖されます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">userCity ::</span> <span class="dt">XML</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">XML</span>
userCity root <span class="fu">=</span> 
  root <span class="fu">&lt;/&gt;</span> <span class="st">&quot;profile&quot;</span> <span class="fu">&gt;&gt;=</span> \prof <span class="ot">-&gt;</span>
    prof <span class="fu">&lt;/&gt;</span> <span class="st">&quot;address&quot;</span> <span class="fu">&gt;&gt;=</span> \addr <span class="ot">-&gt;</span>
      addr <span class="fu">&lt;/&gt;</span> <span class="st">&quot;city&quot;</span> <span class="fu">&gt;&gt;=</span> \city <span class="ot">-&gt;</span>
        return city</code></pre>
<p>do記法を使って表現されたコードは、<code>&gt;&gt;=</code>演算子を使って書かれた同じ意味のコードよりしばしば読みやすくなることも特筆すべき点です。一方で、明示的に<code>&gt;&gt;=</code>を使って束縛が書くと、<strong>point-free</strong>形式でコードを書く機会を増やすことになります。ただし、通常は読みやすさを優先すべきでしょう。</p>
<h2 id="モナド則"><span class="header-section-number">8.5</span> モナド則</h2>
<p><code>Monad</code>型クラスは<strong>モナド則</strong>(monad laws)と呼ばれる3つの規則を持っています。これらは<code>Monad</code>型クラスの理にかなった実装から何を期待できるかを教えてくれます。</p>
<p>do記法を使用してこれらの規則を説明していくのが最も簡単でしょう。</p>
<h3 id="identity律"><span class="header-section-number">8.5.1</span> Identity律</h3>
<p><strong>右単位元則</strong>(right-identity law)が３つの規則の中で最も簡単です。この規則はdo記法ブロックの最後の式であれば、<code>return</code>の呼び出しを排除することが できると言っています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span> 
  x <span class="ot">&lt;-</span> expr
  return x</code></pre>
<p>右単位元則は、この式は単なる<code>expr</code>と同じだと言っています。</p>
<p><strong>左単位元則</strong>(left-identity law)は、もしそれがdo記法ブロックの最初の式であれば、<code>return</code>の呼び出しを除去することができると述べています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span> 
  x <span class="ot">&lt;-</span> return y
  next</code></pre>
<p>このコードの名前<code>x</code>を式<code>y</code>で置き換えたものと<code>next</code>は同じです。</p>
<p>最後の規則は<strong>結合則</strong>(associativity law)です。これは入れ子になったdo記法ブロックをどう扱うのかについて教えてくれます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">c1 <span class="fu">=</span> <span class="kw">do</span> 
  y <span class="ot">&lt;-</span> <span class="kw">do</span> 
    x <span class="ot">&lt;-</span> m1
    m2
  m3</code></pre>
<p>上記のコード片は、次のコードと同じです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">c2 <span class="fu">=</span> <span class="kw">do</span> 
  x <span class="ot">&lt;-</span> m1
  y <span class="ot">&lt;-</span> m2
  m3</code></pre>
<p>これら計算にはそれぞれ、3つのモナドの式 <code>m1</code>、<code>m2</code>、 <code>m3</code>が含まれています。どちらの場合でも<code>m1</code> の結果は名前 <code>x</code>に束縛され、<code>m2</code>の結果は名前 <code>y</code>に束縛されます。</p>
<p><code>c1</code>では２つの式<code>m1</code>と<code>m2</code>がそれぞれのdo記法ブロック内にグループ化されています。</p>
<p><code>c2</code>では<code>m1</code>、<code>m2</code>、<code>m3</code>の３つすべての式が同じdo記法ブロックに現れています。</p>
<p>結合規則は　入れ子になったdo記法ブロックをこのように単純化しても安全であるということを言っています。</p>
<p><strong>注意</strong>: do記法がどのように<code>&gt;&gt;=</code>の呼び出しへと脱糖されるかの定義により、<code>c1</code>と<code>c2</code>はいずれも次のコードと同じです。`</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">c3 <span class="fu">=</span> <span class="kw">do</span> 
  x <span class="ot">&lt;-</span> m1
  <span class="kw">do</span>
    y <span class="ot">&lt;-</span> m2
    m3</code></pre>
<h2 id="モナドと畳み込み"><span class="header-section-number">8.6</span> モナドと畳み込み</h2>
<p>抽象的にモナドを扱う例として、この節では<code>Monad</code>型クラスの何らかの型構築子と一緒に機能するある関数を示していきます。これはモナドによるコードが副作用を伴う「より大きな言語」でのプログラミングと対応しているという直感的理解を補強しますし、モナドによるプログラミングがもたらす一般性も示しています。</p>
<p>これから<code>foldM</code>と呼ばれる関数を書いてみます。これは以前扱った<code>foldl</code>関数をモナドの文脈へと一般化します。型シグネチャは次のようになっています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foldM ::</span> forall m a b<span class="fu">.</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> m a </code></pre>
<p>モナド<code>m</code>が現れている点を除いて、<code>foldl</code>の型と同じであることに注意しましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foldl<span class="ot"> ::</span> forall a b<span class="fu">.</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> a</code></pre>
<p>直感的には、<code>foldM</code>はさまざまな副作用の組み合わせに対応した文脈での配列の畳み込みを行うと捉えることができます。</p>
<p>例として<code>m</code>が<code>Maybe</code>であるとすると、この畳み込みはそれぞれの段階で<code>Nothing</code>を返すことで失敗することができます。それぞれの段階ではオプショナルな結果を返しますから、それゆえ畳み込みの結果もオプショナルになります。</p>
<p>もし<code>m</code>として配列の型構築子<code>[]</code>を選ぶとすると、畳み込みのそれぞれの段階で複数の結果を返すことができ、畳み込みは結果それぞれに対して次の手順を継続します。最後に、結果の集まりは、可能な経路すべての畳み込みから構成されることになります。これはグラフの走査と対応しています！</p>
<p><code>foldM</code>を書くには、単に入力の配列について場合分けをするだけです。</p>
<p>配列が空なら、型<code>a</code>の結果を生成するための選択肢はひとつしかありません。第２引数を返します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foldM _ a [] <span class="fu">=</span> return a</code></pre>
<p><code>a</code>をモナド<code>m</code>まで持ち上げるために<code>return</code>を使わなくてはいけないことも忘れないようにしてください。</p>
<p>配列が空でない場合はどうでしょうか？その場合、型<code>a</code>の値、型<code>b</code>の値、型<code>a -&gt; b -&gt; m a</code>の関数があります。もしこの関数を適用すると、型<code>m a</code>のモナドの結果を手に入れることになります。この計算の結果を逆向きの矢印<code>&lt;-</code>で束縛することができます。</p>
<p>あとは配列の残りに対して再帰するだけです。実装は簡単です。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foldM f a (b <span class="fu">:</span> bs) <span class="fu">=</span> <span class="kw">do</span>
  a&#39; <span class="ot">&lt;-</span> f a b
  foldM f a&#39; bs</code></pre>
<p>do記法を除けば、この実装は配列に対する<code>foldl</code>の実装とほとんど同じであることにも注意してください。</p>
<p><code>psci</code>でこれを定義し、試してみましょう。除算可能かどうかを調べて、失敗を示すために<code>Maybe</code>型構築子を使う、整数の「安全な除算」関数を定義するとしましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">safeDivide ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Number</span>
safeDivide a b <span class="fu">|</span> a <span class="fu">%</span> b <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Just</span> (a <span class="fu">/</span> b)
safeDivide _ _ <span class="fu">=</span> <span class="dt">Nothing</span></code></pre>
<p>これで、<code>foldM</code>で安全な除算の繰り返しを表現することができます。</p>
<pre class="text"><code>&gt; foldM safeDivide 100 [5, 2, 2]
Just (5)

&gt; foldM safeDivide 100 [2, 3, 4]
Nothing</code></pre>
<p>もしいずれかの時点で整数にならない除算が行われようとしたら、<code>foldM safeDivide</code>関数は<code>Nothing</code>を返します。そうでなければ、<code>Just</code>構築子に包まれた除算の繰り返した累積の結果を返します。</p>
<h2 id="モナドとapplicative"><span class="header-section-number">8.7</span> モナドとApplicative</h2>
<p>クラス間に上位クラス関係があるため、<code>Monad</code>型クラスのすべてのインスタンスは<code>Applicative</code>型クラスのインスタンスでもあります。</p>
<p>しかしながら、どんな<code>Monad</code>のインスタンスについても<code>Applicative</code>型クラスの実装が、それ以上の条件なしで存在し、次のような<code>ap</code>が与えられます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ap ::</span> forall m<span class="fu">.</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> m (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b
ap mf ma <span class="fu">=</span> <span class="kw">do</span>
  f <span class="ot">&lt;-</span> mf
  a <span class="ot">&lt;-</span> ma
  return (f a)</code></pre>
<p>もし<code>m</code>が<code>Monad</code>型クラスの規則に従っているなら、<code>pure</code>が<code>return</code>で与えられ、<code>&lt;*&gt;</code>が<code>ap</code>で与えられるような、妥当な<code>Applicative</code>インスタンスが存在します。　　　　</p>
<p>興味のある読者は、これまで登場した<code>[]</code>、<code>Maybe</code>、<code>Either e</code>、<code>V e</code>といったモナドについて、この<code>ap</code>が<code>&lt;*&gt;</code>と一致することを確かめてみてください。</p>
<p>もしすべてのモナドがApplicative関手でもあるなら、Applicative関手についての直感的理解をすべてのモナドについても適用することができるはずです。特に、更なる副作用の組み合わせで増強された「より大きな言語」でのプログラミングとモナドがいろいろな意味で一致することを当然に期待することができます。<code>&lt;$&gt;</code>と<code>&lt;*&gt;</code>を使って、引数が任意個の関数をこの新しい言語へと持ち上げることができるはずです。</p>
<p>しかし、モナドはApplicative関手で可能な以上のことを行うことができ、重要な違いはdo記法の構文で強調されています。利用者情報を符号化したXML文書から利用者の都市を検索する、<code>userCity</code>の例についてもう一度考えてみましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">userCity ::</span> <span class="dt">XML</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">XML</span>
userCity root <span class="fu">=</span> <span class="kw">do</span>
  prof <span class="ot">&lt;-</span> root <span class="fu">&lt;/&gt;</span> <span class="st">&quot;profile&quot;</span>
  addr <span class="ot">&lt;-</span> prof <span class="fu">&lt;/&gt;</span> <span class="st">&quot;address&quot;</span>
  city <span class="ot">&lt;-</span> addr <span class="fu">&lt;/&gt;</span> <span class="st">&quot;city&quot;</span>
  return city</code></pre>
<p>２番目の計算が最初の結果<code>prof</code>に依存し、３番目の計算が２番目の計算の結果<code>addr</code>に依存するというようなことをdo記法は可能にします。<code>Applicative</code>型クラスのインターフェイスだけを使うのでは、このような以前の値への依存は不可能です。</p>
<p><code>pure</code>と<code>&lt;*&gt;</code>だけを使って<code>userCity</code>を書こうとしてみれば、これが不可能であることがわかるでしょう。Applicativeは関数の互いに独立した引数を持ち上げることだけを可能にしますが、モナドはもっと興味深いデータ依存関係に関わる計算を書くことを可能にします。</p>
<p>前の章では<code>Applicative</code>型クラスは並列処理を表現できることを見ました。持ち上げられた関数の引数は互いに独立していますから、これはまさにその通りです。<code>Monad</code>型クラスは計算が前の計算の結果に依存できるようにしますから、同じようにはなりません。モナドはその副作用を順番に組み合わせしなければいけません。</p>
<blockquote>
<h2 id="演習" class="unnumbered">演習</h2>
<ol type="1">
<li>（簡単）　<code>purescript-arrays</code>パッケージの<code>Data.Array</code>モジュールから<code>head</code>関数と<code>tail</code>関数の型を探してください。<code>Maybe</code>モナドとdo記法を使い、<code>head</code>と<code>tail</code>を組み合わせて、３要素以上の配列の3番目の要素を返すような関数を作ってください。その関数は適当な<code>Maybe</code>型を返さなければいけません。</li>
<li><p>（やや難しい） 与えられた幾つかの硬貨を組み合わせてできる可能性のあるすべての合計を決定する関数<code>sum</code>を、<code>foldM</code>を使って書いてみましょう。入力の硬貨は、硬貨の価値の配列として与えられます。この関数は次のような結果にならなくてはいけません。</p>
<pre class="text"><code>&gt; sums []
[0]

&gt; sums [1, 2, 10]
[0,1,2,3,10,11,12,13]</code></pre>
<p><strong>ヒント</strong>：<code>foldM</code>を使うと１行でこの関数を書くことが可能です。重複する要素を取り除いたり、結果を昇順に並び替えたりするのに、<code>nub</code>関数や<code>sort</code>関数を使いたくなるかもしれません。</p></li>
<li><p>（やや難しい） <code>Maybe</code>型構築子について、<code>ap</code>関数と<code>&lt;*&gt;</code>演算子が一致することを確認してください。</p></li>
<li><p>（やや難しい） <code>purescript-maybe</code>パッケージで定義されている<code>Maybe</code>型についての<code>Monad</code>インスタンスが、モナド則を満たしていることを検証してください。</p></li>
<li><p>（やや難しい） 配列上の<code>filter</code>の関数を一般化した関数<code>filterM</code>を書いてください。この関数は次の型シグネチャを持つ必要があります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">filterM ::</span> forall m a<span class="fu">.</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Boolean</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</code></pre>
<p><code>psci</code>で<code>Maybe</code>と<code>[]</code>モナドを使ってその関数を試してみてください。</p></li>
<li><p>（難しい） すべてのモナドは、次で与えられるような既定の<code>Functor</code>インスタンスがあります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="fu">&lt;$&gt;</span>) f a <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> a
  return (f a)</code></pre>
<p>モナド則を使って、すべてのモナドが次を満たすことを証明してください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">lift2 f (return a) (return b) <span class="fu">=</span> return (f a b)</code></pre>
<p>ここで、 <code>Applicative</code>インスタンスは上で定義された<code>ap</code>関数を使用しています。<code>lift2</code>が次のように定義されていたことを思い出してください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lift2 ::</span> forall f a b c<span class="fu">.</span> (<span class="dt">Applicative</span> f)<span class="fu">.</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c
lift2 f a b <span class="fu">=</span> f <span class="fu">&lt;$&gt;</span> a <span class="fu">&lt;*&gt;</span> b</code></pre></li>
</ol>
</blockquote>
<h2 id="ネイティブな作用"><span class="header-section-number">8.8</span> ネイティブな作用</h2>
<p>ここではPureScriptの中核となる重要なモナド、<code>Eff</code>モナドについて見ていきます。</p>
<p><code>Eff</code>モナドは<code>Control.Monad.Eff</code>モジュール、およびPreludeで定義されています。これはいわゆる<strong>ネイティブな作用</strong>を扱うために使います。</p>
<p>ネイティブな副作用とは何でしょうか。ネイティブな副作用とは、従来のJavaScriptの式が持つ副作用と、PureScript特有の式が持つ副作用を区別するものです。ネイティブな作用には次のようなものがあります。</p>
<ul>
<li>コンソール入出力</li>
<li>乱数生成</li>
<li>例外</li>
<li>変更可能な状態の読み書き</li>
</ul>
<p>また、ブラウザでは次のようなものがあります。</p>
<ul>
<li>DOM操作</li>
<li>XMLHttpRequest / AJAX呼び出し</li>
<li>WebSocketによる相互作用</li>
<li>Local Storageの読み書き</li>
</ul>
<p>すでに「ネイティブでない」副作用の例については数多く見てきています。</p>
<ul>
<li><code>Maybe</code>データ型で表現される省略可能な値</li>
<li><code>Either</code>データ型で表現されるエラー</li>
<li>配列やリストで表現される多価関数</li>
</ul>
<p>これらの区別はわかりにくいので注意してください。エラーメッセージは例外の形でJavaScriptの式の副作用となることがあります。その意味では例外はネイティブな副作用を表していて、<code>Eff</code>を使用して表現することができます。しかし、<code>Either</code>を使用して実装されたエラーメッセージはJavaScriptランタイムの副作用ではなく、<code>Eff</code>を使うスタイルでエラーメッセージを実装するのは適切ではありません。そのため、ネイティブなのは作用自体というより、実行時にどのように実装されているかです。</p>
<h2 id="副作用と純粋性"><span class="header-section-number">8.9</span> 副作用と純粋性</h2>
<p>PureScriptのような言語が純粋であるとすると、疑問が浮かんできます。副作用がないなら、どうやって役に立つ実際のコードを書くことができるというのでしょうか。</p>
<p>その答えはPureScriptの目的は副作用を排除することではないということです。これは、純粋な計算と副作用のある計算とを型システムにおいて区別することができるような方法で、副作用を表現することを目的としているのです。この意味で、言語はあくまで純粋だということです。</p>
<p>副作用のある値は、純粋な値とは異なる型を持っています。このように、例えば副作用のある引数を関数に渡すことはできず、予期せず副作用持つようなことが起こらなくなります。</p>
<p><code>Eff</code>モナドで管理された副作用を実行する唯一の方法は、型<code>Eff eff a</code>の計算をJavaScriptから実行することです。</p>
<p>PureScriptコンパイラは、<code>--main</code>コンパイラオプションを与えることで、アプリケーションの起動時に <code>main</code>計算を呼び出すためのJavaScriptコードを簡単に追加で生成できるようにしています。<code>main</code>は<code>Eff</code>モナドでの計算であることが要求されます。</p>
<p>このように、<code>main</code>によって使われる副作用が期待されることを、開発者は正確に知ることができます。加えて、<code>main</code>がどのような種類の副作用を持つかを制限するのに<code>Eff</code>モナドを使うことができるので、例えば、アプリケーションはコンソールと相互作用するが、それ以外は何もしない、ということを確実に言うことができます。</p>
<h2 id="effモナド-1"><span class="header-section-number">8.10</span> Effモナド</h2>
<p><code>Eff</code>モナドの目的は、副作用のある計算に型付けされたAPIを提供すると同時に、効率的なJavascriptを生成することにあります。これは<strong>拡張可能作用</strong>(extensible effects)のモナドとも呼ばれており、これについては後述します。</p>
<p>例を示しましょう。次のコードでは乱数を生成するための関数が定義されている<code>purescript-random</code>モジュールを使用しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Monad.Eff</span>
<span class="kw">import </span><span class="dt">Control.Monad.Eff.Random</span>

<span class="kw">import </span><span class="dt">Debug.Trace</span>

main <span class="fu">=</span> <span class="kw">do</span>
  n <span class="ot">&lt;-</span> random
  print n</code></pre>
<p>このファイルが<code>Main.purs</code> という名前で保存されているなら、次のコマンドでコンパイルすることができます。</p>
<pre class="text"><code>psc --main Main Main.purs</code></pre>
<p>コンパイルされたJavaScriptを実行すると、コンソールに出力<code>0</code>と <code>1</code>の間で無作為に選ばれた数が表示されるでしょう。</p>
<p>このプログラムは、乱数生成とコンソール入出力というJavaScriptランタイムが提供する２種類のネイティブな作用を、do記法で組み合わせて使っています。</p>
<h2 id="拡張可能作用"><span class="header-section-number">8.11</span> 拡張可能作用</h2>
<p><code>psci</code>でモジュールを読み込み、<code>main</code>の型を調べてみましょう。</p>
<pre class="text"><code>&gt; :t Main.main

forall eff. Eff (trace :: Trace, random :: Random | eff) Unit</code></pre>
<p>この型はかなり複雑そうに見えますが、PureScriptのレコードの比喩で簡単に説明することができます。</p>
<p>レコード型を使った簡単な関数を考えてみましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">fullName person <span class="fu">=</span> person<span class="fu">.</span>firstName <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> person<span class="fu">.</span>lastName</code></pre>
<p>この関数は <code>firstName</code>と<code>lastName</code>というプロパティを含むレコードから完全な名前の文字列を作成します。もし<code>psci</code>でこの関数の型を同様に調べたとすると、次のように表示されるでしょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">forall r<span class="fu">.</span> {<span class="ot"> firstName ::</span> <span class="dt">String</span>,<span class="ot"> lastName ::</span> <span class="dt">String</span> <span class="fu">|</span> r } <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre>
<p>この型は「<strong>少なくとも</strong><code>fullName</code>は<code>firstName</code>と<code>lastName</code>という2つのフィールドを持つようなレコードをとり、<code>String</code>を返す.」というように読みます。</p>
<p>渡したレコードが <code>firstName</code>と<code>lastName</code>いうプロパティさえ持っていれば、その他に余計なフィールドを持っていたとしても<code>fullName</code>は気にしません。</p>
<pre class="text"><code>&gt; firstName { firstName: &quot;Phil&quot;, lastName: &quot;Freeman&quot;, location: &quot;Los Angeles&quot; }

Phil Freeman</code></pre>
<p>同様に、上の<code>main</code>の型は「<code>main</code>は<strong>副作用のある計算</strong>で、乱数生成とコンソール入出力、<strong>およびそれ以外の任意の種類の副作用</strong>を備えた任意の環境で実行することができ、型<code>Unit</code>の値を返す」というように解釈できます。</p>
<p>これは 「拡張可能作用」という名前の由来になっています。必要な副作用さえ備えていれば、その副作用の集まりをいつでも拡張できるということです。</p>
<h2 id="作用の混在"><span class="header-section-number">8.12</span> 作用の混在</h2>
<p>拡張可能作用は<code>Eff</code>モナドで異なる型の副作用を<strong>混在</strong>(interleave)させることを可能にします。</p>
<p>先ほど使った<code>random</code>関数は次のような型を持っています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">forall eff1<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">random ::</span> <span class="dt">Random</span> <span class="fu">|</span> eff1) <span class="dt">Number</span></code></pre>
<p>この作用の集まり<code>(random :: Random | eff1)</code>は<code>main</code>で見たものと同じ<strong>ではありません</strong>。</p>
<p>しかし、作用が一致するように<code>random</code>の型を特殊化できます。<code>eff1</code> に <code>(trace :: Trace | eff)</code>を選べば、これらの２つの作用の集合は同じになります。</p>
<p>同様に <code>trace</code>は<code>main</code>の作用に合わせて特殊化できる型を持っています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">forall eff2<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">trace ::</span> <span class="dt">Trace</span> <span class="fu">|</span> eff2) <span class="dt">Unit</span></code></pre>
<p>この場合は、<code>eff2</code>に<code>(random :: Random | eff)</code>を選ばなくてはなりません。</p>
<p>それが含む副作用を示す<code>random</code>と<code>print</code>の型がポイントで、より大きな副作用の集まりを持ったより大きな計算を構築するために、他の副作用を<strong>混ぜ合わせる</strong>ことができるのです。</p>
<p><code>main</code>の型注釈を与えなくてもよいことに注意してください。<code>psc</code>は<code>random</code>と<code>trace</code>の多相的な型が与えられた<code>main</code>の最も一般的な型を見つけることができます。</p>
<h2 id="effの種"><span class="header-section-number">8.13</span> Effの種</h2>
<p><code>main</code>の型は今まで見てきた他の型とは異なります。それを説明するためには、まず<code>Eff</code> の<strong>種</strong>について考える必要があります。値がその型によって分類されるように、型がその種によって分類されることを思い出してください。これまでは<code>*</code>（型の種）と<code>-&gt;</code>（型構築子のための種を構築する）だけから構築された種のみを見てきました。</p>
<p><code>Eff</code>の種を見るには、<code>psci</code>で<code>:k</code> コマンドを使います。</p>
<pre class="text"><code>&gt; :k Control.Monad.Eff.Eff

 # ! -&gt; * -&gt; *</code></pre>
<p>今まで見たことのない記号が２つあります。</p>
<p><code>!</code>は副作用の型についての<strong>型レベルのラベル</strong>を表す<strong>作用</strong>の種です。これを理解するためには、上の<code>main</code>で見た2つのラベルがいずれも種<code>!</code>を持っていることに注目してください。</p>
<pre class="text"><code>&gt; :k Debug.Trace.Trace

  !

&gt; :k Control.Monad.Eff.Random.Random

  !</code></pre>
<p><code>#</code>種構築子は<strong>行</strong>の種を構築するのに使われます。行とは順序なしラベル付きの集合のことです。</p>
<p>そして、<code>Eff</code>は作用の行と作用の返り値の型という２つの引数を持っています。つまり、 <code>Eff</code>の最初の引数は、作用の型の順序なしラベル付きの集合であり、２つめの引数は返り値の型だということです。</p>
<p>これで、先ほどの<code>main</code>の型を読むことができるようになりました。</p>
<pre class="text"><code>forall eff. Eff (trace :: Trace, random :: Random | eff) Unit</code></pre>
<p><code>Eff</code>の最初の引数は<code>(trace :: Trace, random :: Random | eff)</code>です。これは<code>Trace</code>作用と<code>Random</code>作用を含む行です。パイプ記号<code>|</code>は、ラベルが付けられた作用と、それに混ぜあわせたい<strong>それ以外の任意の作用</strong>を表す<strong>行変数</strong>(row variable)<code>eff</code>を区切っています。</p>
<p><code>Eff</code>の2番目の引数は、計算の戻り値の型<code>Unit</code>です。</p>
<h2 id="オブジェクトと行"><span class="header-section-number">8.14</span> オブジェクトと行</h2>
<p>拡張可能作用とレコードに深いつながりをもたらしている<code>Eff</code>の種を考えてみましょう。</p>
<p>上で定義した関数<code>fullName</code>を考えます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fullName ::</span> forall r<span class="fu">.</span> {<span class="ot"> firstName ::</span> <span class="dt">String</span>,<span class="ot"> lastName ::</span> <span class="dt">String</span> <span class="fu">|</span> r } <span class="ot">-&gt;</span> <span class="dt">String</span>
fullName person <span class="fu">=</span> person<span class="fu">.</span>firstName <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> person<span class="fu">.</span>lastName</code></pre>
<p>種<code>*</code>の型だけが値を持つので、関数の矢印の左辺にある型の種は<code>*</code>でなければなりません。</p>
<p>中括弧は実際には構文糖であり、PureScriptコンパイラによって理解されている完全な型は次のようなものです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fullName ::</span> forall r<span class="fu">.</span> <span class="dt">Object</span> (<span class="ot">firstName ::</span> <span class="dt">String</span>,<span class="ot"> lastName ::</span> <span class="dt">String</span> <span class="fu">|</span> r) <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre>
<p>中括弧がなくなっており、<code>Object</code>構築子が追加されていることに注意してください。<code>Object</code>は<code>Prim</code>モジュールで定義されている組み込みの型構築子です。<code>Object</code>の種を調べてみると、次のようになっています。</p>
<pre class="text"><code>&gt; :k Object

  # * -&gt; *</code></pre>
<p>つまり、<code>Object</code>は<strong>型の行</strong>をとり型を構築する型構築子なのです。これがレコードについての行多相関数を書くことを可能にしているのです。</p>
<p>この型システムでは、拡張可能作用を扱うのに、行多相レコード(拡張可能レコード)を使うときと同じ機構が使われています。唯一の違いは、ラベルに現れる型の<strong>種</strong>です。レコードは型の行によってパラメータ化され、<code>Eff</code>は作用の行によってパラメータ化されるのです。</p>
<p>これと同じ型システムの機能は、型構築子の行や、行の行でパラメータ化される型を構築するのにさえ使われることがあります！</p>
<h2 id="きめ細かな作用"><span class="header-section-number">8.15</span> きめ細かな作用</h2>
<p>作用の行は推論されるので、大抵の場合は<code>Eff</code>を使うときに型注釈は必須ではありませんが、計算でどの作用が期待されるのかをコンパイラに示すために型注釈が使われることがあります。</p>
<p>先ほどの例を、作用の<strong>閉じた</strong>行で注釈すると次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">Eff</span> (<span class="ot">trace ::</span> <span class="dt">Trace</span>,<span class="ot"> random ::</span> <span class="dt">Random</span>) <span class="dt">Unit</span>
main <span class="fu">=</span> <span class="kw">do</span>
  n <span class="ot">&lt;-</span> random
  print n</code></pre>
<p>行変数<code>eff</code>がないことに注意してください。こうすると、異なった作用の型を使う計算を誤って含めることはできません。このように、コードが持つことを許される副作用を制御することができるのです。</p>
<h2 id="ハンドラとアクション"><span class="header-section-number">8.16</span> ハンドラとアクション</h2>
<p><code>trace</code>や<code>random</code>のような関数は<strong>アクション</strong>と呼ばれます。アクションはそれらの関数の右辺に<code>Eff</code>型を持っており、その目的は新たな効果を<strong>導入</strong>することにあります。</p>
<p>これは<code>Eff</code>型が関数の引数の型として現れる<strong>ハンドラ</strong>とは対照的です。アクションが集合へ必要な作用を<strong>追加</strong>するのに対し、ハンドラは集合から作用を<strong>除去</strong>します。</p>
<p>例として、<code>purescript-exceptions</code>パッケージを考えてみます。このパッケージでは<code>throwException</code>と<code>catchException</code>という二つの関数が定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">throwException ::</span> forall a eff<span class="fu">.</span> <span class="dt">Error</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">err ::</span> <span class="dt">Exception</span> <span class="fu">|</span> eff) a

<span class="ot">catchException ::</span> forall a eff<span class="fu">.</span> (<span class="dt">Error</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> eff a) <span class="ot">-&gt;</span> 
                                <span class="dt">Eff</span> (<span class="ot">err ::</span> <span class="dt">Exception</span> <span class="fu">|</span> eff) a <span class="ot">-&gt;</span> 
                                <span class="dt">Eff</span> eff a</code></pre>
<p><code>throwException</code>はアクションです。 <code>Eff</code>は右辺に現れていて、新しく<code>Exception</code>作用を導入します。</p>
<p><code>catchException</code>はハンドラです。 <code>Eff</code>は関数の第２引数の型として出現しており、作用全体としては<code>Exception</code>作用を<strong>除去</strong>します。</p>
<p>特定の作用を必要とするコードの部分を限定するために型システムを使うことができるので、これは便利です。作用のあるコードをハンドラで包むことにより、その作用を許さないコードブロックの中に埋め込むことができます。</p>
<p>例えば、<code>Exception</code>作用を使って例外を投げるコード片を書き、それからそのコードを<code>catchException</code>で包むことによって、例外を許さないコード片の中にその計算を埋め込むことができるのです。</p>
<p>JSONドキュメントからアプリケーションの設定を読みたいとしましょう。文書を構文解析する過程で例外を投げることがあります。設定を読み構文解析するこの処理は、次のような型シグネチャを持つ関数として書くことができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readConfig ::</span> forall eff<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">err ::</span> <span class="dt">Exception</span> <span class="fu">|</span> eff) <span class="dt">Config</span></code></pre>
<p>それから、<code>main</code>関数で<code>catchException</code>を使用して<code>Exception</code>作用を処理することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> catchException printException <span class="fu">$</span> <span class="kw">do</span>
  config <span class="ot">&lt;-</span> readConfig
  runApplication config
  
  <span class="kw">where</span>
  printException e <span class="fu">=</span> trace (stackTrace e)</code></pre>
<p>Preludeでも、副作用<strong>なし</strong>の計算を取り、それを純粋な値として安全に評価する<code>runPure</code>ハンドラが定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Pure</span> a <span class="fu">=</span> forall e<span class="fu">.</span> <span class="dt">Eff</span> e a

<span class="ot">runPure ::</span> forall a<span class="fu">.</span> <span class="dt">Pure</span> a <span class="ot">-&gt;</span> a</code></pre>
<h2 id="可変状態"><span class="header-section-number">8.17</span> 可変状態</h2>
<p>Preludeには<code>ST</code>作用というまた別の作用も定義されています。</p>
<p><code>ST</code>作用は変更可能な状態を操作するために使われます。純粋関数プログラミングを知っているなら、共有される変更可能な状態は問題を引き起こしやすいということも知っているでしょう。しかしながら、<code>ST</code>作用は型システムを使って安全で<strong>局所的な</strong>状態変化を可能にし、状態の共有を制限するのです。</p>
<p><code>ST</code>作用は<code>Control.Monad.ST</code>モジュールで定義されています。これがどのように動作するかを確認するには、そのアクションの型を見る必要があります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">newSTRef ::</span> forall a h eff<span class="fu">.</span> a <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">st ::</span> <span class="dt">ST</span> h <span class="fu">|</span> eff) (<span class="dt">STRef</span> h a)

<span class="ot">readSTRef ::</span> forall a h eff<span class="fu">.</span> <span class="dt">STRef</span> h a <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">st ::</span> <span class="dt">ST</span> h <span class="fu">|</span> eff) a

<span class="ot">writeSTRef ::</span> forall a h eff<span class="fu">.</span> <span class="dt">STRef</span> h a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">st ::</span> <span class="dt">ST</span> h <span class="fu">|</span> eff) a

<span class="ot">modifySTRef ::</span> forall a h eff<span class="fu">.</span> <span class="dt">STRef</span> h a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">st ::</span> <span class="dt">ST</span> h <span class="fu">|</span> eff) a</code></pre>
<p><code>newSTRef</code>は型<code>STRef h a</code>の変更可能な参照領域を新しく作るのに使われます。<code>STRef h a</code>は<code>readSTRef</code>アクションを使って状態を読み取ったり、<code>writeSTRef</code>アクションや<code>modifySTRef</code>アクションで状態を変更するのに使われます。型<code>a</code>は領域に格納された値の型で、型<code>h</code>は型システムの<strong>メモリ領域</strong>を表しています。</p>
<p>例を示します。小さな時間刻みで簡単な更新関数の実行を何度も繰り返すことによって、重力に従って落下する粒子の落下の動きをシミュレートしたいとしましょう。</p>
<p>粒子の位置と速度を保持する変更可能な参照領域を作成し、領域に格納された値を更新するのにforループ(<code>Control.Monad.Eff</code>の<code>forE</code>アクション)を使うことでこれを実現することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Eff</span>
<span class="kw">import </span><span class="dt">Control.Monad.ST</span>

<span class="ot">simulate ::</span> forall eff h<span class="fu">.</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">st ::</span> <span class="dt">ST</span> h <span class="fu">|</span> eff) <span class="dt">Number</span>
simulate x0 v0 time <span class="fu">=</span> <span class="kw">do</span>
  ref <span class="ot">&lt;-</span> newSTRef { x<span class="fu">:</span> x0, v<span class="fu">:</span> v0 }
  forE <span class="dv">0</span> (time <span class="fu">*</span> <span class="dv">1000</span>) <span class="fu">$</span> \i <span class="ot">-&gt;</span> <span class="kw">do</span>
    modifySTRef ref (\o <span class="ot">-&gt;</span>
      { v<span class="fu">:</span> o<span class="fu">.</span>v <span class="fu">-</span> <span class="fl">9.81</span> <span class="fu">*</span> <span class="fl">0.001</span>
      , x<span class="fu">:</span> o<span class="fu">.</span>x <span class="fu">+</span> o<span class="fu">.</span>v <span class="fu">*</span> <span class="fl">0.001</span>
      })
    return unit
  final <span class="ot">&lt;-</span> readSTRef ref
  return final<span class="fu">.</span>x</code></pre>
<p>計算の最後では、参照領域の最終的な値を読み取り、粒子の位置を返しています。</p>
<p>この関数が変更可能な状態を使っていても、その参照区画<code>ref</code>がプログラムの他の部分で使われるのが許されない限り、これは純粋な関数のままであることに注意してください。<code>ST</code>作用が禁止するものが正確には何であるのかについては後ほど見ます。</p>
<p><code>ST</code>作用で計算を実行するには、<code>runST</code>関数を使用する必要があります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runST ::</span> forall a eff<span class="fu">.</span> (forall h<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">st ::</span> <span class="dt">ST</span> h <span class="fu">|</span> eff) a) <span class="ot">-&gt;</span> <span class="dt">Eff</span> eff a</code></pre>
<p>ここで注目して欲しいのは、領域型<code>h</code>が関数矢印の左辺にある<strong>括弧の内側で</strong>量化されているということです。<code>runST</code>に渡したどんなアクションでも、 <strong>任意の領域</strong><code>h</code>がなんであれ動作するということを意味しています。</p>
<p>しかしながら、ひとたび参照領域が<code>newSTRef</code>によって作成されると、その領域の型はすでに固定されており、<code>runST</code>によって限定されたコードの外側で参照領域を使おうとしても型エラーになるでしょう。<code>runST</code>が安全に<code>ST</code>作用を除去できるのはこれが理由なのです！</p>
<p>実際に、<code>ST</code>はこの例の唯一の作用なので、<code>runPure</code>と<code>runST</code>を併用すると<code>simulate</code>を純粋な関数に変えることができます、</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">simulate&#39; ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span>
simulate&#39; x0 v0 time <span class="fu">=</span> runPure (runST (simulate x0 v0 time))</code></pre>
<p><code>psci</code> でこの関数を実行してみてください。</p>
<pre class="text"><code>&gt; Main.simulate&#39; 100 0 0.0
100.00

&gt; Main.simulate&#39; 100 0 1.0
95.10

&gt; Main.simulate&#39; 100 0 2.0
80.39

&gt; Main.simulate&#39; 100 0 3.0
55.87

&gt; Main.simulate&#39; 100 0 4.0
21.54</code></pre>
<p>もし<code>simulate</code>の定義を<code>runST</code>の呼び出しのところへ埋め込むとすると、次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">simulate ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span>
simulate x0 v0 time <span class="fu">=</span> runPure (runST (<span class="kw">do</span>
  ref <span class="ot">&lt;-</span> newSTRef { x<span class="fu">:</span> x0, v<span class="fu">:</span> v0 }
  forE <span class="dv">0</span> (time <span class="fu">*</span> <span class="dv">1000</span>) <span class="fu">$</span> \i <span class="ot">-&gt;</span> <span class="kw">do</span>
    modifySTRef ref (\o <span class="ot">-&gt;</span>  
      { v<span class="fu">:</span> o<span class="fu">.</span>v <span class="fu">-</span> <span class="fl">9.81</span> <span class="fu">*</span> <span class="fl">0.001</span>
      , x<span class="fu">:</span> o<span class="fu">.</span>x <span class="fu">+</span> o<span class="fu">.</span>v <span class="fu">*</span> <span class="fl">0.001</span>  
      })
    return unit  
  final <span class="ot">&lt;-</span> readSTRef ref
  return final<span class="fu">.</span>x))</code></pre>
<p>参照区画はそのスコープから逃れることができないことが<code>psc</code>コンパイラにわかりますし、安全に<code>var</code>に変換することができます。<code>runST</code>の呼び出しの本体に対して生成されたJavaScriptは次のようになります。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> ref = { <span class="dt">x</span>: x0, <span class="dt">v</span>: v0 };

<span class="ot">Control_Monad_Eff</span>.<span class="fu">forE</span>(<span class="dv">0</span>)(time * <span class="dv">1000</span>)(<span class="kw">function</span> (i) {
  <span class="kw">return</span> <span class="kw">function</span> <span class="fu">__do</span>() {
    ref = (<span class="kw">function</span> (o) {
      <span class="kw">return</span> {
        <span class="dt">v</span>: <span class="ot">o</span>.<span class="fu">v</span> - <span class="fl">9.81</span> * <span class="fl">1.0e-3</span>, 
        <span class="dt">x</span>: <span class="ot">o</span>.<span class="fu">x</span> + <span class="ot">o</span>.<span class="fu">v</span> * <span class="fl">1.0e-3</span>
      };
    })(ref);
    <span class="kw">return</span> <span class="ot">Prelude</span>.<span class="fu">unit</span>;
  };
})();

<span class="kw">return</span> <span class="ot">ref</span>.<span class="fu">x</span>;</code></pre>
<p>局所的な変更可能状態を扱うとき、特に<code>Eff</code>モナドで効率のよいループを生成する<code>forE</code>、<code>foreachE</code>、<code>whileE</code>、<code>untilE</code>のようなアクションを一緒に使うときには、<code>ST</code>作用は短いJavaScriptを生成できる良い方法となります。</p>
<blockquote>
<h2 id="演習-1" class="unnumbered">演習</h2>
<ol type="1">
<li><p>（やや難しい） もし分母で分子を割り切れないなら<code>throwException</code>を使って例外を投げるように<code>safeDivide</code>関数を書き直してください。</p></li>
<li><p>（難しい） PIを推定するには次のような簡単な方法があります。単位正方形内にある多数の<code>N</code>個の点を無作為に選び、内接する円に含まれるものの個数<code>n</code>を数えます。このとき<code>4n/N</code>が円周率<code>pi</code>の概算となります。<code>forE</code>関数、<code>Random</code>作用、<code>ST</code>作用を使って、この方法で円周率<code>pi</code>を推定する関数を書いてください。</p></li>
</ol>
</blockquote>
<h2 id="dom作用"><span class="header-section-number">8.18</span> DOM作用</h2>
<p>この章の最後の節では、<code>Eff</code>モナドでの作用についてこれまで学んだことを、実際のDOM操作の問題に応用します。</p>
<p>DOMを直接扱ったり、オープンソースのDOMライブラリを扱う、自由に利用可能なPureScriptパッケージが幾つかあります。</p>
<ul>
<li><a href="http://github.com/aktowns/purescript-simple-dom"><code>purescript-simple-dom</code></a> - JavaScript DOM APIのバインディング</li>
<li><a href="http://github.com/purescript-contrib/purescript-jquery"><code>purescript-jquery</code></a> - <a href="http://jquery.org">jQuery</a>ライブラリのバインディング</li>
<li><a href="http://github.com/purescript-contrib/purescript-react"><code>purescript-react</code></a> - <a href="http://facebook.github.io/react/">React</a>ライブラリへのバインディング</li>
<li><a href="http://github.com/purescript-contrib/purescript-angular"><code>purescript-angular</code></a> - <a href="http://angularjs.org/">AngularJS</a>ライブラリのバインディング</li>
<li><a href="http://github.com/purescript-contrib/purescript-virtual-dom"><code>purescript-virtual-dom</code></a> - <a href="http://github.com/Matt-Esch/virtual-dom">virtual-dom</a>ライブラリの最小限のラッパ</li>
</ul>
<p>しかしながら、これらのライブラリのほとんどはまだ非常に新しくAPIが安定なため、この章の内容を安定させられるように、この章のソースコードの<code>Control.Monad.DOM</code>モジュールにはDOM要素を操作するための最小限の関数群が含まれています。</p>
<p>DOM要素を作成や操作をするための次のようなアクションが含まれています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">body ::</span> forall eff<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Node</span>
<span class="ot">createElement ::</span> forall eff<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Node</span>
<span class="ot">querySelector ::</span> forall eff<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) (<span class="dt">Maybe</span> <span class="dt">Node</span>)</code></pre>
<p>既存の要素の内容やスタイルを変更するためのアクションも用意されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">setText ::</span> forall eff<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Node</span>
<span class="ot">setInnerHTML ::</span> forall eff<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Node</span>
<span class="ot">appendChild ::</span> forall eff<span class="fu">.</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Node</span>
<span class="ot">addClass ::</span> forall eff<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Node</span></code></pre>
<p>そして、DOMイベントを処理するためのアクションがあります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">addEventListener ::</span> forall eff<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> 
                                <span class="dt">Eff</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Unit</span> <span class="ot">-&gt;</span> 
                                <span class="dt">Node</span> <span class="ot">-&gt;</span> 
                                <span class="dt">Eff</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Node</span></code></pre>
<p>これらが住所録アプリケーションのユーザインターフェイスを作るのに必要なアクションです。</p>
<h2 id="住所録のユーザーインタフェース"><span class="header-section-number">8.19</span> 住所録のユーザーインタフェース</h2>
<p>これから構築しようとしているユーザ·インタフェースは、HTMLとPureScriptファイルに分かれています。HTMLはページ上の要素の配置を定義し、PureScriptのコードはフォームの動的な振る舞いを制御する方法を定義します。</p>
<p>まずは利用者が住所録に新しい項目を追加できるフォームを構築することにしましょう。フォームには、さまざまなフィールド（姓、名前、都市、州など）を入力するテキストボックス、および検証エラーが表示される領域が含まれます。テキストボックスに利用者がテキストを入力すると、検証エラーが更新されます。</p>
<p>シンプルさを保つために、フォームは固定の形状とします。電話番号は種類（自宅、携帯電話、仕事、その他）ごとに別々のテキストボックスへ分けることにします。</p>
<p><code>head</code>要素内の次のようなコードを除いて、HTMLファイルは完全に静的です。</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;script</span><span class="ot"> type=</span><span class="st">&quot;text/javascript&quot;</span><span class="ot"> src=</span><span class="st">&quot;../dist/Main.js&quot;</span><span class="kw">&gt;&lt;/script&gt;</span>
<span class="kw">&lt;script</span><span class="ot"> type=</span><span class="st">&quot;text/javascript&quot;</span><span class="kw">&gt;</span>
  onload = <span class="ot">PS</span>.<span class="ot">Main</span>.<span class="fu">main</span>;
&lt;<span class="ot">/script&gt;  </span></code></pre>
<p>最初の行では<code>psc</code>によって生成されるJavaScriptコードを読み込み、2行目ではページがロードされたときに<code>PS.Main.main</code>関数が確実に実行されるようにしています。</p>
<p><code>Main</code>モジュールはとても単純です。<code>Data.AddressBook.UI</code>モジュールには<code>setupEventHandlers</code>関数に処理をそのまま移譲する<code>main</code>関数だけが定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> forall eff<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">trace ::</span> <span class="dt">Trace</span>,<span class="ot"> dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Unit</span>
main <span class="fu">=</span> <span class="kw">do</span>
  trace <span class="st">&quot;Attaching event handlers&quot;</span>
  setupEventHandlers </code></pre>
<p>これは混在した作用の一例になっていることに注目してください。下で見るように、<code>trace</code>関数は<code>Trace</code>作用を使い、<code>setupEventHandlers</code>関数は<code>Trace</code>作用と<code>DOM</code>作用の両方を使っています(<code>DOM</code>作用は<code>Control.Monad.Eff.DOM</code>で定義されています)。</p>
<p><code>setupEventHandlers</code>関数もとても簡単です（単一の目的を持った小​​さな関数それぞれに分割することによって、コードについて理解するのが簡単になっていることに注目してください）​​。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">setupEventHandlers ::</span> forall eff<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">trace ::</span> <span class="dt">Trace</span>,<span class="ot"> dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Unit</span>
setupEventHandlers <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- Listen for changes on form fields</span>
  body <span class="fu">&gt;&gt;=</span> addEventListener <span class="st">&quot;change&quot;</span> validateAndUpdateUI </code></pre>
<p><code>setupEventHandlers</code>はまず文書のbodyへの参照を取得するために<code>body</code>アクションを使い、<code>&gt;&gt;=</code>を使ってその結果を<code>addEventListener</code>アクションに渡しています。<code>addEventListener</code>は<code>change</code>イベントを監視して、イベントが発生するとその度に<code>validateAndUpdateUI</code>アクションを呼び出します。</p>
<p>do記法の定義により、これを次のようにも書けることに注意してください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">setupEventHandlers <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- Listen for changes on form fields</span>
  b <span class="ot">&lt;-</span> body
  addEventListener <span class="st">&quot;change&quot;</span> validateAndUpdateUI b</code></pre>
<p>どちらが読みやすいかどうかは個人の好みの問題です。前者は名前が付けられた関数の引数がなく、<strong>point-free</strong>形式の一例となっています。その一方で、後者では文書のbodyの名前として<code>b</code>が使われています。</p>
<p><code>validateAndUpdateUI</code>アクションの役目は、フォーム検証器を実行し、必要に応じて利用者にエラーのリストを表示することです。この場合も、他の関数へ処理を委譲することによってこれを行います。最初に、<code>querySelector</code>アクションを使用してページの<code>validationErrors</code>要素を選択しています。それから、その要素の内容を消去するために<code>setInnerHTML</code>アクションを使用しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">validateAndUpdateUI ::</span> forall eff<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">trace ::</span> <span class="dt">Trace</span>,<span class="ot"> dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Unit</span>
validateAndUpdateUI <span class="fu">=</span> <span class="kw">do</span>
  <span class="dt">Just</span> validationErrors <span class="ot">&lt;-</span> querySelector <span class="st">&quot;#validationErrors&quot;</span>        
  setInnerHTML <span class="st">&quot;&quot;</span> validationErrors </code></pre>
<p>次に<code>validateAndUpdateUI</code>が<code>validateControls</code>アクションを呼び出し、フォームの検証を実行しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  errorsOrResult <span class="ot">&lt;-</span> validateControls</code></pre>
<p>後ほどすぐに見るように、<code>errorsOrResult</code>はエラーのリストか<code>Person</code>レコードのどちらかを表す型<code>Either [String] Person</code>を持っています。</p>
<p>最後に、もし入​​力の検証に失敗すると、<code>validateAndUpdateUI</code>はページ上のエラーを表示するために <code>displayValidationErrors</code>アクションに処理を委譲します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">case</span> errorsOrResult <span class="kw">of</span>
    <span class="dt">Left</span> errs <span class="ot">-&gt;</span> displayValidationErrors errs
    <span class="dt">Right</span> result <span class="ot">-&gt;</span> print result

  return unit</code></pre>
<p>検証が成功した場合、コードは単にコンソールに検証結果を出力します。当然のことながら、実際のアプリケーションでは、次の手順でデータベースまたは同様のものにデータを保存することになるでしょう。</p>
<p><code>validateControls</code>関数はより興味深いものです。<code>validateControls</code>の役割は、フォームの検証を実行し、成功または失敗のいずれかを示す結果を返すことであることを思い出してください。最初に行うことは、コンソールにデバッグメッセージを出力することです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">validateControls ::</span> forall eff<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">trace ::</span> <span class="dt">Trace</span>,<span class="ot"> dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) 
                                    (<span class="dt">Either</span> [<span class="dt">String</span>] <span class="dt">Person</span>)  
validateControls <span class="fu">=</span> <span class="kw">do</span>
  trace <span class="st">&quot;Running validators&quot;</span></code></pre>
<p><code>Data.AddressBook.UI</code>モジュールでは、フォームフィールドから値を読み込む関数 <code>valueOf</code>が定義されています。ここでは型シグネチャだけを示し、実装については議論しません。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">valueOf ::</span> forall eff<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">String</span></code></pre>
<p><code>valueOf</code>はフォーム要素のIDをとり、利用者がそのテキストボックスに入力した値を返します。</p>
<p>次に、<code>validateControls</code>はページ上のフォームフィールドからいろいろな文字列を読み取って<code>Data.AddressBook.Person</code>データ構造体を構築します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  p <span class="ot">&lt;-</span> person 
    <span class="fu">&lt;$&gt;</span> valueOf <span class="st">&quot;#inputFirstName&quot;</span>
    <span class="fu">&lt;*&gt;</span> valueOf <span class="st">&quot;#inputLastName&quot;</span>
    <span class="fu">&lt;*&gt;</span> (address <span class="fu">&lt;$&gt;</span> valueOf <span class="st">&quot;#inputStreet&quot;</span>
                 <span class="fu">&lt;*&gt;</span> valueOf <span class="st">&quot;#inputCity&quot;</span>
                 <span class="fu">&lt;*&gt;</span> valueOf <span class="st">&quot;#inputState&quot;</span>)
    <span class="fu">&lt;*&gt;</span> sequence [ phoneNumber <span class="dt">HomePhone</span> <span class="fu">&lt;$&gt;</span> valueOf <span class="st">&quot;#inputHomePhone&quot;</span>
                 , phoneNumber <span class="dt">CellPhone</span> <span class="fu">&lt;$&gt;</span> valueOf <span class="st">&quot;#inputCellPhone&quot;</span>
                 ]</code></pre>
<p>この計算では <code>person</code>、<code>address</code>、<code>phoneNumber</code>関数を持ち上げるために、<code>Eff</code>をApplicative関手として使用していることに注意してください。また、<code>Person</code>データ構造体の電話番号配列をまとめるために必要な<code>Eff</code>の配列を連鎖させるために、<code>Data.Traversable</code>の<code>sequense</code>関数を使っています。</p>
<p>最後に、<code>validateControls</code>は前の章で書いた検証関数を実行し、その結果を返します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  return <span class="fu">$</span> validatePerson&#39; p</code></pre>
<p>残りのコー​​ドは<code>displayValidationErrors</code>関数です。<code>displayValidationErrors</code>はエラーの配列をとり、ページ上にそれらの文字列を出力します。</p>
<p>この関数が最初に行うことは、エラーを表示するための新しい<code>div</code>要素を作成することです。フォームのレイアウトを制御するために<a href="http://getbootstrap.com/">Bootstrap library</a>を使っているので、<code>addClass</code>アクションを使って新しい要素に適切なCSSクラスを設定しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">displayValidationErrors ::</span> forall eff<span class="fu">.</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Unit</span>
displayValidationErrors errs <span class="fu">=</span> <span class="kw">do</span>
  alert <span class="ot">&lt;-</span> createElement <span class="st">&quot;div&quot;</span>
    <span class="fu">&gt;&gt;=</span> addClass <span class="st">&quot;alert&quot;</span> 
    <span class="fu">&gt;&gt;=</span> addClass <span class="st">&quot;alert-danger&quot;</span></code></pre>
<p>このコードがpoint-free形式であることに改めて注意してください。興味のある読者は、これを<code>&gt;&gt;=</code>を使わないように書き換えてみることをおすすめします。</p>
<p>次のコードは<code>ul</code>要素を作成し先ほどの<code>div</code>に追加します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  ul <span class="ot">&lt;-</span> createElement <span class="st">&quot;ul&quot;</span>
  ul <span class="ot">`appendChild`</span> alert</code></pre>
<p>配列内の各エラーそれぞれについて<code>li</code>要素を作成して、リストに追加します。<code>setText</code>アクションは、エラーメッセージを<code>li</code>要素のテキストコンテンツを設定するために使用されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  foreachE errs <span class="fu">$</span> \err <span class="ot">-&gt;</span> <span class="kw">do</span>
    li <span class="ot">&lt;-</span> createElement <span class="st">&quot;li&quot;</span> <span class="fu">&gt;&gt;=</span> setText err
    li <span class="ot">`appendChild`</span> ul
    return unit</code></pre>
<p>配列の要素について繰り返しを行うために、このコードでは<code>foreachE</code>アクションを使っています。これは以前に見た<code>traverse</code>関数に似ていますが、<code>Eff</code>モナドだけで使うように特殊化されています。</p>
<p>最後に、<code>querySelector</code>アクションを使って<code>validationErrors</code>要素を検索し、それに先ほどの<code>div</code>を追加します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="dt">Just</span> validationErrors <span class="ot">&lt;-</span> querySelector <span class="st">&quot;#validationErrors&quot;</span>
  alert <span class="ot">`appendChild`</span> validationErrors
  
  return unit</code></pre>
<p>以上です！<code>grunt</code>を実行して、それからWebブラウザで <code>html/index.html</code>を開き、ユーザインターフェイスを試してみてください。</p>
<p>フォームフィールドにいろいろな値を入力すると、ページ上に出力された検証エラーを見ることができるでしょう。検証エラーをすべて修正すると、ブラウザのコンソール上に検証の結果が表示されるはずです。</p>
<p>このユーザインタフェースには明らかに改善すべき点がたくさんあります。演習ではアプリケーションがより使いやすくなるような方法を追究していきます。</p>
<blockquote>
<h2 id="演習-2" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単) このアプリケーションを変更し、職場の電話番号のテキストボックスを追加してください。</p></li>
<li><p>(やや難しい) 検証エラーを<code>ul</code>要素を使ってリストで表示するかわりに、それぞれのエラーについてひとつづつ<code>alert</code>スタイルで<code>div</code>を作成するように、コードを変更してください。</p></li>
<li>(やや難しい) <code>&gt;&gt;=</code>の明示的な呼び出しを使わないように、<code>Data.AddressBook.UI</code>モジュールのコードを書き直してください。</li>
<li><p>(難しい、拡張) このユーザーインターフェイスの問題のひとつは、検証エラーがその発生源であるフォームフィールドの隣に表示されていないことです。コードを変更してこの問題を解決してください。</p>
<p><strong>ヒント</strong>：検証器によって返されるエラーの型は、エラーの原因となっているフィールドを示すために拡張する必要があります。次のようなエラー型を使用したくなるかもしれません。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ValidationError</span> <span class="fu">=</span> <span class="dt">ValidationError</span> <span class="dt">String</span> <span class="dt">Field</span>

<span class="kw">data</span> <span class="dt">Field</span> <span class="fu">=</span> <span class="dt">FirstNameField</span>
           <span class="fu">|</span> <span class="dt">LastNameField</span> 
           <span class="fu">|</span> <span class="dt">StreetField</span>
           <span class="fu">|</span> <span class="dt">CityField</span>
           <span class="fu">|</span> <span class="dt">StateField</span>
           <span class="fu">|</span> <span class="dt">PhoneField</span> <span class="dt">PhoneType</span></code></pre>
<p>適切なフォーム要素を選択するように、<code>Field</code>を<code>querySelector</code>アクションの呼び出しに変更する関数を書くする必要があるでしょう。</p></li>
</ol>
</blockquote>
<h2 id="まとめ"><span class="header-section-number">8.20</span> まとめ</h2>
<p>この章ではPureScriptでの副作用の扱いについての多くの考え方を導入しました。</p>
<ul>
<li><code>Monad</code>型クラスと、それに関連するdo記法の導入しました。</li>
<li>モナド則を導入し、do記法使って書かれたコードを変換する方法を説明しました</li>
<li>異なる副作用で動作するコードを書くために、モナドを抽象的に扱う方法を説明しました。</li>
<li>モナドがApplicative関手の一例であること、両者がどのように副作用のある計算を可能にするのか、2つの手法の違いを説明しました。</li>
<li>ネイティブな作用の概念を定義し、ネイティブな副作用を処理するために使用する<code>Eff</code>モナドを導入しました。</li>
<li>どのように<code>Eff</code>モナドが拡張可能作用を提供するか、複数の種類のネイティブな作用を同じ計算に混在させる方法を説明しました。</li>
<li>作用やレコードが種システムでどのように扱われるか、拡張可能なレコードと拡張可能作用の関連を見ました。</li>
<li>乱数生成、例外、コンソール入出力、変更可能な状態、およびDOM操作といった、さまざまな作用を扱うために <code>Eff</code>モナドを使いました。</li>
</ul>
<p><code>Eff</code>モナドは現実のPureScriptコードにおける基本的なツールです。本書ではこのあとも、様々な場面で副作用を処理するために<code>Eff</code>モナドを使っていきます。</p>
      <p class="previous" style="visibility:hidden;"><a href="index.html">&lt; 目次に戻る</a></p>
    </div>

    <script>
        if(location.pathname !== "/purescript/" && location.pathname !== "/purescript/index.html"){
            Array.prototype.forEach.call(document.querySelectorAll(".previous"), function(elem){
                elem.style.visibility = "visible";
            });
        }
    </script>
  </div>
</body>
</html>
