<!DOCTYPE html><html><head><meta charset="UTF-8">

  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="実例によるPureScript">
  <meta name="twitter:description" content="純粋関数型プログラミング言語 PureScriptの入門書、"PureScript by Example"の日本語訳">
  <meta name="twitter:いまげ" content="http://aratama.github.io/purescript/card.png">    
  <meta property="og:url" content="http://aratama.github.io/purescript/">
  <meta property="og:title" content="実例によるPureScript">
  <meta property="og:description" content="純粋関数型プログラミング言語 PureScriptの入門書、"PureScript by Example"の日本語訳">
  <meta property="og:image" content="http://aratama.github.io/purescript/card.png">
  
  <title>実例によるPureScript</title>

  <link rel="icon" type="image/png" href="favicon-96x96.png" sizes="96x96">
  <link rel="stylesheet" href="github-markdown.css" type="text/css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Roboto">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/agate.min.css">
</head>

<body>
  <div class="main">
    <header>
      <a class="logo" href="/purescript/">
          <img class="logo" src="logo-shadow.png">
      </a>
      <div class="title">
          <h1 id="実例によるpurescript">実例による<wbr>PureScript</h1>
          <p>ウェブのための<wbr>関数型<wbr>プログラミング</p>
          <p class="author">
            <a href="https://leanpub.com/purescript/read">
              Phil Freeman, "PureScript by Example - Functional Programming for the Web"
            </a>
          </p>
      </div>
    </header>

    <div class="markdown-body content">
    <p class="home"><a href="index.html">目次に戻る</a></p><h1>第8章 Effモナド</h1><h2>8.1 この章の目標</h2><p>第7章では、オプショナルな型やエラーメッセージ、データの検証など、<strong>副作用</strong>を扱いを抽象化するApplicative関手を導入しました。この章では、より表現力の高い方法で副作用を扱うための別の抽象化、<strong>モナド</strong>を導入します。</p><p>この章の目的は、なぜモナドが便利な抽象化なのか、<strong>do記法</strong>とどう関係するのかについて説明することです。ブラウザでユーザインターフェイスを構築する副作用を扱うためのある種のモナドを使って、前の章の住所録の例を作ることにしましょう。これから扱うEffモナドは、PureScriptにおけるとても重要なモナドです。Effモナドはいわゆる<strong>ネイティブな</strong>作用をカプセル化するのに使われます。</p><h2>8.2 プロジェクトの準備</h2><p>このプロジェクトのソースコードは前の章のソースコードの上に構築しますが、以前のプロジェクトのモジュールは、このプロジェクトの <code>src</code>ディレクトリに含まれています。</p><p>このプロジェクトでは、以下のBowerの依存関係が追加されています。</p><ul>
<li><code>purescript-eff</code> - Effモナドを提供します。</li>
<li><code>purescript-react</code> - Reactユーザインターフェイスへ接続するライブラリを提供します。</li>
</ul><p>前章のモジュールに加えて、この章では<code>Main</code>モジュールを使用します。このモジュールはエントリポイントであるとともに、UIの描写も行います。</p><p>このプロジェクトをコンパイルするには、まずReactをインストールするため<code>npm install</code>を実行し、それから<code>pulp browserify --to dist/Main.js</code>でビルドを行います。このプロジェクトを実行するには、<code>html/index.html</code>ファイルをウェブブラウザで開いてください。</p><h2>8.3 モナドとdo記法</h2><p>do記法は<strong>配列内包表記</strong>を扱うときに最初に導入されました。配列内包表記は <code>Data.Array</code>モジュールの <code>concatMap</code>関数の構文糖として提供されています。</p><p>次の例を考えてみましょう。２つのサイコロを振って出た目を数え、出た目の合計が <code>n</code>のときそれを得点とすることを考えます。次のような非決定的なアルゴリズムを使うとこれを実現することができます。</p><ul>
<li>最初の投擲で値 <code>x</code>を<strong>選択</strong>します。</li>
<li>２回目の投擲で値 <code>y</code>を<strong>選択</strong>します。</li>
<li>もし <code>x</code>と <code>y</code>の和が <code>n</code>なら組 <code>{x, y}</code>を返し、そうでなければ失敗します。</li>
</ul><p>配列内包表記を使うと、この非決定的アルゴリズムを自然に書くことができます。</p><pre><code class="language-haskell"><span class="hljs-keyword">import</span> Prelude

<span class="hljs-keyword">import</span> Control.Plus (<span class="hljs-title">empty</span>)
<span class="hljs-keyword">import</span> Data.Array ((..))

<span class="hljs-title">countThrows</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Array</span> (<span class="hljs-type">Array</span> <span class="hljs-type">Int</span>)
<span class="hljs-title">countThrows</span> n = <span class="hljs-keyword">do</span>
  x &lt;- <span class="hljs-number">1</span> .. <span class="hljs-number">6</span>
  y &lt;- <span class="hljs-number">1</span> .. <span class="hljs-number">6</span>
  <span class="hljs-keyword">if</span> x + y == n
    <span class="hljs-keyword">then</span> pure [x, y]
    <span class="hljs-keyword">else</span> empty
</code></pre><p><code>PSCi</code>で動作を見てみましょう。</p><pre><code class="language-text">> countThrows 10
[[4,6],[5,5],[6,4]]

> countThrows 12  
[[6,6]]
</code></pre><p>前の章では、<strong>オプショナルな値</strong>に対応したより大きなプログラミング言語へとPureScriptの関数を埋め込む、 <code>Maybe</code> Applicative関手についての直感的理解を養いました。同様に<strong>配列モナド</strong>についても、<strong>非決定選択</strong>に対応したより大きなプログラミング言語へPureScriptの関数を埋め込む、というような直感的理解を得ることができます。</p><p>一般に、ある型構築子 <code>m</code>のモナドは、型 <code>m a</code>の値を持つdo記法を使う方法を提供します。上の配列内包表記では、すべての行に何らかの型 <code>a</code>についての型 <code>Array a</code>の計算が含まれていることに注目してください。一般に、do記法ブロックのすべての行は、何らかの型 <code>a</code>とモナド <code>m</code>について、型 <code>m a</code>の計算を含んでいます。モナド <code>m</code>はすべての行で同じでなければなりません(つまり、副作用の種類は固定されます)が、型 <code>a</code>は異なることもあります(言い換えると、ここの計算は異なる型の結果を持つことができます)。</p><p>型構築子 <code>Maybe</code>が適用された、do記法の別の例を見てみましょう。XMLノードを表す型 <code>XML</code>と演算子があるとします。</p><pre><code class="language-haskell"><span class="hljs-title">child</span> :: <span class="hljs-type">XML</span> -&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">XML</span>
</code></pre><p>この演算子はノードの子の要素を探し、もしそのような要素が存在しなければ <code>Nothing</code>を返します。</p><p>この場合、do記法を使うと深い入れ子になった要素を検索することができます。XML文書として符号化された利用者情報から、利用者の住んでいる市町村を読み取りたいとします。</p><pre><code class="language-haskell"><span class="hljs-title">userCity</span> :: <span class="hljs-type">XML</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">XML</span>
<span class="hljs-title">userCity</span> root = <span class="hljs-keyword">do</span>
  prof &lt;- child root <span class="hljs-string">"profile"</span>
  addr &lt;- child prof <span class="hljs-string">"address"</span>
  city &lt;- child addr <span class="hljs-string">"city"</span>
  pure city
</code></pre><p><code>userCity</code>関数は子の要素である <code>profile</code>を探し、 <code>profile</code>要素の中にある <code>address</code>要素、最後に <code>address</code>要素から <code>city</code>要素を探します。これらの要素のいずれかが欠落している場合は、返り値は <code>Nothing</code>になります。そうでなければ、返り値は <code>city</code>ノードから <code>Just</code>を使って構築されています。</p><p>最後の行にある<code>pure</code>関数は、すべての<code>Applicative</code>関手について定義されているのでした。<code>Maybe</code>の<code>Applicative</code>関手の<code>pure</code>関数は<code>Just</code>として定義されており、最後の行を <code>Just city</code>へ変更しても同じように正しく動きます。</p><h2>8.4 モナド型クラス</h2><p><code>Monad</code>型クラスは次のように定義されています。</p><pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Apply</span> m &lt;= <span class="hljs-type">Bind</span> m <span class="hljs-keyword">where</span></span>
  bind :: <span class="hljs-keyword">forall</span> a b. m a -&gt; (a -&gt; m b) -&gt; m b
<span class="hljs-class"><span class="hljs-keyword">class</span> (<span class="hljs-type">Applicative</span> <span class="hljs-title">m</span>, <span class="hljs-type">Bind</span> <span class="hljs-title">m</span>) &lt;= <span class="hljs-type">Monad</span> m
</span></code></pre><p>ここで鍵となる関数は <code>Bind</code>型クラスで定義されている演算子 <code>bind</code>で、 <code>Functor</code>及び <code>Apply</code>型クラスにある <code><$></code>や <code><*></code>などの演算子と同じ様に <code>Prelude</code>では <code>>>=</code>として <code>bind</code>の別名が定義されています。</p><p><code>Monad</code>型クラスは、すでに見てきた <code>Applicative</code>型クラスの操作で <code>Bind</code>を拡張します。</p><p><code>Bind</code>型クラスの例をいくつか見てみるのがわかりやすいでしょう。配列についての <code>Bind</code>の妥当な定義は次のようになります。</p><pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> bindArray :: <span class="hljs-type">Bind</span> <span class="hljs-type">Array</span> <span class="hljs-keyword">where</span></span>
  bind xs f = concatMap f xs
</code></pre><p>これは以前にほのめかした配列内包表記と <code>concatMap</code>関数の関係を説明しています。</p><p><code>Maybe</code>型構築子についての <code>Bind</code>の実装は次のようになります。</p><pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> bindMaybe :: <span class="hljs-type">Bind</span> <span class="hljs-type">Maybe</span> <span class="hljs-keyword">where</span></span>
  bind <span class="hljs-type">Nothing</span>  _ = <span class="hljs-type">Nothing</span>
  bind (<span class="hljs-type">Just</span> a) f = f a
</code></pre><p>この定義はdo記法ブロックを通じて伝播された欠落した値についての直感的理解を補強するものです。</p><p><code>Bind</code>型クラスとdo記法がどのように関係しているかを見て行きましょう。最初に何らかの計算結果から値を束縛するような、簡単などdo記法ブロックについて考えてみましょう。</p><pre><code class="language-haskell"><span class="hljs-title">do</span> value &lt;- someComputation
   whatToDoNext
</code></pre><p>PureScriptコンパイラはこのようなパターンを見つけるたびにコードを次にように置き換えます。</p><pre><code class="language-haskell"><span class="hljs-title">bind</span> someComputation \value -&gt; whatToDoNext
</code></pre><p>下記のように表記することもできます。</p><pre><code class="language-haskell"><span class="hljs-title">someComputation</span> &gt;&gt;= \value -&gt; whatToDoNext
</code></pre><p>この計算 <code>whatToDoNext</code>は <code>value</code>に依存することができます。</p><p>連続した複数の束縛がある場合でも、この規則が先頭のほうから複数回適用されます。例えば、先ほど見た <code>userCity</code>の例では次のように構文糖が脱糖されます。</p><pre><code class="language-haskell"><span class="hljs-title">userCity</span> :: <span class="hljs-type">XML</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">XML</span>
<span class="hljs-title">userCity</span> root =
  child root <span class="hljs-string">"profile"</span> &gt;&gt;= \prof -&gt;
    child prof <span class="hljs-string">"address"</span> &gt;&gt;= \addr -&gt;
      child addr <span class="hljs-string">"city"</span> &gt;&gt;= \city -&gt;
        pure city
</code></pre><p>do記法を使って表現されたコードは、 <code>>>=</code>演算子を使って書かれた同じ意味のコードよりしばしば読みやすくなることも特筆すべき点です。一方で、明示的に <code>>>=</code>を使って束縛が書くと、<strong>point-free</strong>形式でコードを書く機会を増やすことになります。ただし、通常は読みやすさを優先すべきでしょう。</p><h2>8.5 モナド則</h2><p><code>Monad</code>型クラスは<strong>モナド則</strong>(monad laws)と呼ばれる3つの規則を持っています。これらは <code>Monad</code>型クラスの理にかなった実装から何を期待できるかを教えてくれます。</p><p>do記法を使用してこれらの規則を説明していくのが最も簡単でしょう。</p><h3>Identity律</h3><p><strong>右単位元則</strong>(right-identity law)が３つの規則の中で最も簡単です。この規則はdo記法ブロックの最後の式であれば、 <code>pure</code>の呼び出しを排除することができると言っています。</p><pre><code class="language-haskell"><span class="hljs-title">do</span>
  x &lt;- expr
  pure x
</code></pre><p>右単位元則は、この式は単なる <code>expr</code>と同じだと言っています。</p><p><strong>左単位元則</strong>(left-identity law)は、もしそれがdo記法ブロックの最初の式であれば、 <code>pure</code>の呼び出しを除去することができると述べています。</p><pre><code class="language-haskell"><span class="hljs-title">do</span>
  x &lt;- pure y
  next
</code></pre><p>このコードの名前 <code>x</code>を式 <code>y</code>で置き換えたものと <code>next</code>は同じです。</p><p>最後の規則は<strong>結合則</strong>(associativity law)です。これは入れ子になったdo記法ブロックをどう扱うのかについて教えてくれます。</p><pre><code class="language-haskell"><span class="hljs-title">c1</span> = <span class="hljs-keyword">do</span>
  y &lt;- <span class="hljs-keyword">do</span>
    x &lt;- m1
    m2
  m3
</code></pre><p>上記のコード片は、次のコードと同じです。</p><pre><code class="language-haskell"><span class="hljs-title">c2</span> = <span class="hljs-keyword">do</span>
  x &lt;- m1
  y &lt;- m2
  m3
</code></pre><p>これら計算にはそれぞれ、3つのモナドの式 <code>m1</code>、 <code>m2</code>、 <code>m3</code>が含まれています。どちらの場合でも <code>m1</code>の結果は名前 <code>x</code>に束縛され、 <code>m2</code>の結果は名前 <code>y</code>に束縛されます。</p><p><code>c1</code>では２つの式 <code>m1</code>と <code>m2</code>がそれぞれのdo記法ブロック内にグループ化されています。</p><p><code>c2</code>では <code>m1</code>、 <code>m2</code>、 <code>m3</code>の３つすべての式が同じdo記法ブロックに現れています。</p><p>結合規則は　入れ子になったdo記法ブロックをこのように単純化しても安全であるということを言っています。</p><p><strong>注意</strong>: do記法がどのように <code>bind</code>の呼び出しへと脱糖されるかの定義により、 <code>c1</code>と <code>c2</code>はいずれも次のコードと同じです。 `</p><pre><code class="language-haskell"><span class="hljs-title">c3</span> = <span class="hljs-keyword">do</span>
  x &lt;- m1
  <span class="hljs-keyword">do</span>
    y &lt;- m2
    m3
</code></pre><h2>8.6 モナドと畳み込み</h2><p>抽象的にモナドを扱う例として、この節では <code>Monad</code>型クラスの何らかの型構築子と一緒に機能するある関数を示していきます。これはモナドによるコードが副作用を伴う「より大きな言語」でのプログラミングと対応しているという直感的理解を補強しますし、モナドによるプログラミングがもたらす一般性も示しています。</p><p>これから <code>foldM</code>と呼ばれる関数を書いてみます。これは以前扱った <code>foldl</code>関数をモナドの文脈へと一般化します。型シグネチャは次のようになっています。</p><pre><code class="language-haskell"><span class="hljs-title">foldM</span> :: <span class="hljs-keyword">forall</span> m a b
       . <span class="hljs-type">Monad</span> m
      =&gt; (a -&gt; b -&gt; m a)
      -&gt; a
      -&gt; <span class="hljs-type">List</span> b
      -&gt; m a
</code></pre><p>モナド <code>m</code>が現れている点を除いて、 <code>foldl</code>の型と同じであることに注意しましょう。</p><pre><code class="language-haskell"><span class="hljs-title">foldl</span> :: <span class="hljs-keyword">forall</span> a b
       . (a -&gt; b -&gt; a)
      -&gt; a
      -&gt; <span class="hljs-type">List</span> b
      -&gt; a
</code></pre><p>直感的には、 <code>foldM</code>はさまざまな副作用の組み合わせに対応した文脈での配列の畳み込みを行うと捉えることができます。</p><p>例として <code>m</code>が <code>Maybe</code>であるとすると、この畳み込みはそれぞれの段階で <code>Nothing</code>を返すことで失敗することができます。それぞれの段階ではオプショナルな結果を返しますから、それゆえ畳み込みの結果もオプショナルになります。</p><p>もし <code>m</code>として配列の型構築子 <code>Array</code>を選ぶとすると、畳み込みのそれぞれの段階で複数の結果を返すことができ、畳み込みは結果それぞれに対して次の手順を継続します。最後に、結果の集まりは、可能な経路すべての畳み込みから構成されることになります。これはグラフの走査と対応しています！</p><p><code>foldM</code>を書くには、単に入力の配列について場合分けをするだけです。</p><p>配列が空なら、型 <code>a</code>の結果を生成するための選択肢はひとつしかありません。第２引数を返します。</p><pre><code class="language-haskell">foldM _ a Nil = pure a
</code></pre><p><code>a</code>をモナド <code>m</code>まで持ち上げるために <code>pure</code>を使わなくてはいけないことも忘れないようにしてください。</p><p>配列が空でない場合はどうでしょうか？その場合、型 <code>a</code>の値、型 <code>b</code>の値、型 <code>a -> b -> m a</code>の関数があります。もしこの関数を適用すると、型 <code>m a</code>のモナドの結果を手に入れることになります。この計算の結果を逆向きの矢印 <code><-</code>で束縛することができます。</p><p>あとは配列の残りに対して再帰するだけです。実装は簡単です。</p><pre><code class="language-haskell"><span class="hljs-title">foldM</span> f a (b : bs) = <span class="hljs-keyword">do</span>
  a' &lt;- f a b
  foldM f a' bs
</code></pre><p>do記法を除けば、この実装は配列に対する <code>foldl</code>の実装とほとんど同じであることにも注意してください。</p><p><code>PSCi</code>でこれを定義し、試してみましょう。除算可能かどうかを調べて、失敗を示すために <code>Maybe</code>型構築子を使う、整数の「安全な除算」関数を定義するとしましょう。</p><pre><code class="language-haskell"><span class="hljs-title">safeDivide</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">Int</span>
<span class="hljs-title">safeDivide</span> _ <span class="hljs-number">0</span> = <span class="hljs-type">Nothing</span>
<span class="hljs-title">safeDivide</span> a b = <span class="hljs-type">Just</span> (a / b)
</code></pre><p>これで、 <code>foldM</code>で安全な除算の繰り返しを表現することができます。</p><pre><code class="language-text">> import Data.List

> foldM safeDivide 100 (fromFoldable [5, 2, 2])
(Just 5)

> foldM safeDivide 100 (fromFoldable [2, 0, 4])
Nothing
</code></pre><p>もしいずれかの時点で整数にならない除算が行われようとしたら、 <code>foldM safeDivide</code>関数は <code>Nothing</code>を返します。そうでなければ、 <code>Just</code>構築子に包まれた除算の繰り返した累積の結果を返します。</p><h2>8.7 モナドとApplicative</h2><p>クラス間に上位クラス関係があるため、 <code>Monad</code>型クラスのすべてのインスタンスは <code>Applicative</code>型クラスのインスタンスでもあります。</p><p>しかしながら、どんな <code>Monad</code>のインスタンスについても <code>Applicative</code>型クラスの実装が、それ以上の条件なしで存在し、次のような <code>ap</code>が与えられます。</p><pre><code class="language-haskell"><span class="hljs-title">ap</span> :: <span class="hljs-keyword">forall</span> m a b. <span class="hljs-type">Monad</span> m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b
<span class="hljs-title">ap</span> mf ma = <span class="hljs-keyword">do</span>
  f &lt;- mf
  a &lt;- ma
  pure (f a)
</code></pre><p>もし <code>m</code>が <code>Monad</code>型クラスの規則に従っているなら、 <code>m</code>が <code>ap</code>で与えられるような、妥当な <code>Applicative</code>インスタンスが存在します。</p><p>興味のある読者は、これまで登場した <code>Array</code>、 <code>Maybe</code>、 <code>Either e</code>といったモナドについて、この <code>ap</code>が <code>apply</code>と一致することを確かめてみてください。</p><p>もしすべてのモナドがApplicative関手でもあるなら、Applicative関手についての直感的理解をすべてのモナドについても適用することができるはずです。特に、更なる副作用の組み合わせで増強された「より大きな言語」でのプログラミングとモナドがいろいろな意味で一致することを当然に期待することができます。 <code>map</code>と <code>apply</code>を使って、引数が任意個の関数をこの新しい言語へと持ち上げることができるはずです。</p><p>しかし、モナドはApplicative関手で可能な以上のことを行うことができ、重要な違いはdo記法の構文で強調されています。利用者情報を符号化したXML文書から利用者の都市を検索する、 <code>userCity</code>の例についてもう一度考えてみましょう。</p><pre><code class="language-haskell"><span class="hljs-title">userCity</span> :: <span class="hljs-type">XML</span> -&gt; <span class="hljs-type">Maybe</span> <span class="hljs-type">XML</span>
<span class="hljs-title">userCity</span> root = <span class="hljs-keyword">do</span>
  prof &lt;- child root <span class="hljs-string">"profile"</span>
  addr &lt;- child prof <span class="hljs-string">"address"</span>
  city &lt;- child addr <span class="hljs-string">"city"</span>
  pure city
</code></pre><p>２番目の計算が最初の結果 <code>prof</code>に依存し、３番目の計算が２番目の計算の結果 <code>addr</code>に依存するというようなことをdo記法は可能にします。 <code>Applicative</code>型クラスのインターフェイスだけを使うのでは、このような以前の値への依存は不可能です。</p><p><code>pure</code>と <code>apply</code>だけを使って <code>userCity</code>を書こうとしてみれば、これが不可能であることがわかるでしょう。Applicativeは関数の互いに独立した引数を持ち上げることだけを可能にしますが、モナドはもっと興味深いデータ依存関係に関わる計算を書くことを可能にします。</p><p>前の章では <code>Applicative</code>型クラスは並列処理を表現できることを見ました。持ち上げられた関数の引数は互いに独立していますから、これはまさにその通りです。 <code>Monad</code>型クラスは計算が前の計算の結果に依存できるようにしますから、同じようにはなりません。モナドはその副作用を順番に組み合わせしなければいけません。</p><div class="exercise"><h2>演習</h2><ol>
<li>
<p>（簡単）　<code>purescript-arrays</code>パッケージの <code>Data.Array</code>モジュールから <code>head</code>関数と <code>tail</code>関数の型を探してください。 <code>Maybe</code>モナドとdo記法を使い、 <code>head</code>と <code>tail</code>を組み合わせて、３要素以上の配列の3番目の要素を返すような関数を作ってください。その関数は適当な <code>Maybe</code>型を返さなければいけません。</p>
</li>
<li>
<p>（やや難しい） 与えられた幾つかの硬貨を組み合わせてできる可能性のあるすべての合計を決定する関数 <code>sum</code>を、 <code>foldM</code>を使って書いてみましょう。入力の硬貨は、硬貨の価値の配列として与えられます。この関数は次のような結果にならなくてはいけません。</p>
<pre><code class="language-text">> sums []
[0]

> sums [1, 2, 10]
[0,1,2,3,10,11,12,13]
</code></pre>
<p><strong>ヒント</strong>：<code>foldM</code>を使うと１行でこの関数を書くことが可能です。重複する要素を取り除いたり、結果を昇順に並び替えたりするのに、 <code>nub</code>関数や <code>sort</code>関数を使いたくなるかもしれません。</p>
</li>
<li>
<p>（やや難しい） <code>Maybe</code>型構築子について、 <code>ap</code>関数と <code>apply</code>演算子が一致することを確認してください。</p>
</li>
<li>
<p>（やや難しい） <code>purescript-maybe</code>パッケージで定義されている <code>Maybe</code>型についての <code>Monad</code>インスタンスが、モナド則を満たしていることを検証してください。</p>
</li>
<li>
<p>（やや難しい） 配列上の <code>filter</code>の関数を一般化した関数 <code>filterM</code>を書いてください。この関数は次の型シグネチャを持つ必要があります。</p>
<pre><code class="language-haskell"><span class="hljs-title">filterM</span> :: <span class="hljs-keyword">forall</span> m a. <span class="hljs-type">Monad</span> m =&gt; (a -&gt; m <span class="hljs-type">Boolean</span>) -&gt; <span class="hljs-type">List</span> a -&gt; m (<span class="hljs-type">List</span> a)
</code></pre>
<p><code>PSCi</code>で <code>Maybe</code>と <code>Array</code>モナドを使ってその関数を試してみてください。</p>
</li>
<li>
<p>（難しい） すべてのモナドは、次で与えられるような既定の <code>Functor</code>インスタンスがあります。</p>
<pre><code class="language-haskell"><span class="hljs-title">map</span> f a = <span class="hljs-keyword">do</span>
  x &lt;- a
  pure (f x)
</code></pre>
<p>モナド則を使って、すべてのモナドが次を満たすことを証明してください。</p>
<pre><code class="language-haskell">lift2 f (pure a) (pure b) = pure (f a b)
</code></pre>
<p>ここで、 <code>Applicative</code>インスタンスは上で定義された <code>ap</code>関数を使用しています。 <code>lift2</code>が次のように定義されていたことを思い出してください。</p>
<pre><code class="language-haskell"><span class="hljs-title">lift2</span> :: <span class="hljs-keyword">forall</span> f a b c. <span class="hljs-type">Applicative</span> f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
<span class="hljs-title">lift2</span> f a b = f &lt;$&gt; a &lt;*&gt; b
</code></pre>
</li>
</ol></div><h2>8.8 ネイティブな作用</h2><p>ここではPureScriptの中核となる重要なモナド、 <code>Eff</code>モナドについて見ていきます。</p><p><code>Eff</code>モナドは <code>Control.Monad.Eff</code>モジュール、およびPreludeで定義されています。これはいわゆる<strong>ネイティブな作用</strong>を扱うために使います。</p><p>ネイティブな副作用とは何でしょうか。ネイティブな副作用とは、従来のJavaScriptの式が持つ副作用と、PureScript特有の式が持つ副作用を区別するものです。ネイティブな作用には次のようなものがあります。</p><ul>
<li>コンソール入出力</li>
<li>乱数生成</li>
<li>例外</li>
<li>変更可能な状態の読み書き</li>
</ul><p>また、ブラウザでは次のようなものがあります。</p><ul>
<li>DOM操作</li>
<li>XMLHttpRequest / AJAX呼び出し</li>
<li>WebSocketによる相互作用</li>
<li>Local Storageの読み書き</li>
</ul><p>すでに「ネイティブでない」副作用の例については数多く見てきています。</p><ul>
<li><code>Maybe</code>データ型で表現される省略可能な値</li>
<li><code>Either</code>データ型で表現されるエラー</li>
<li>配列やリストで表現される多価関数</li>
</ul><p>これらの区別はわかりにくいので注意してください。エラーメッセージは例外の形でJavaScriptの式の副作用となることがあります。その意味では例外はネイティブな副作用を表していて、 <code>Eff</code>を使用して表現することができます。しかし、 <code>Either</code>を使用して実装されたエラーメッセージはJavaScriptランタイムの副作用ではなく、 <code>Eff</code>を使うスタイルでエラーメッセージを実装するのは適切ではありません。そのため、ネイティブなのは作用自体というより、実行時にどのように実装されているかです。</p><h2>8.9 副作用と純粋性</h2><p>PureScriptのような言語が純粋であるとすると、疑問が浮かんできます。副作用がないなら、どうやって役に立つ実際のコードを書くことができるというのでしょうか。</p><p>その答えはPureScriptの目的は副作用を排除することではないということです。これは、純粋な計算と副作用のある計算とを型システムにおいて区別することができるような方法で、副作用を表現することを目的としているのです。この意味で、言語はあくまで純粋だということです。</p><p>副作用のある値は、純粋な値とは異なる型を持っています。このように、例えば副作用のある引数を関数に渡すことはできず、予期せず副作用持つようなことが起こらなくなります。</p><p><code>Eff</code>モナドで管理された副作用を実行する唯一の方法は、型 <code>Eff eff a</code>の計算をJavaScriptから実行することです。</p><p>ビルドツールPulp(や他のツール)は、オプションを与えることで、アプリケーションの起動時に <code>main</code>計算を呼び出すためのJavaScriptコードを簡単に追加で生成できるようにしています。 <code>main</code>は <code>Eff</code>モナドでの計算であることが要求されます。</p><p>このように、 <code>main</code>によって使われる副作用が期待されることを、開発者は正確に知ることができます。加えて、 <code>main</code>がどのような種類の副作用を持つかを制限するのに <code>Eff</code>モナドを使うことができるので、例えば、アプリケーションはコンソールと相互作用するが、それ以外は何もしない、ということを確実に言うことができます。</p><h2>8.10 Effモナド</h2><p><code>Eff</code>モナドの目的は、副作用のある計算に型付けされたAPIを提供すると同時に、効率的なJavaScriptを生成することにあります。これは<strong>拡張可能作用</strong>(extensible effects)のモナドとも呼ばれており、これについては後述します。</p><p>例を示しましょう。次のコードでは乱数を生成するための関数が定義されている <code>purescript-random</code>モジュールを使用しています。</p><pre><code class="language-haskell"><span class="hljs-keyword">module</span> Main <span class="hljs-keyword">where</span>

<span class="hljs-keyword">import</span> Prelude

<span class="hljs-keyword">import</span> Control.Monad.Eff.Random (<span class="hljs-title">random</span>)
<span class="hljs-keyword">import</span> Control.Monad.Eff.Console (<span class="hljs-title">logShow</span>)

<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
  n &lt;- random
  logShow n
</code></pre><p>このファイルが <code>Main.purs</code>という名前で保存されているなら、次のコマンドでコンパイルすることができます。</p><pre><code class="language-text">$ pulp run
</code></pre><p>コンパイルされたJavaScriptを実行すると、コンソールに出力 <code>0</code>と <code>1</code>の間で無作為に選ばれた数が表示されるでしょう。</p><p>このプログラムは、乱数生成とコンソール入出力というJavaScriptランタイムが提供する２種類のネイティブな作用を、do記法で組み合わせて使っています。</p><h2>8.11 拡張可能作用</h2><p><code>PSCi</code>でモジュールを読み込み、 <code>main</code>の型を調べてみましょう。</p><pre><code class="language-text">> import Main

> :type main
forall eff. Eff (console :: CONSOLE, random :: RANDOM | eff) Unit
</code></pre><p>この型はかなり複雑そうに見えますが、PureScriptのレコードの比喩で簡単に説明することができます。</p><p>レコード型を使った簡単な関数を考えてみましょう。</p><pre><code class="language-haskell"><span class="hljs-title">fullName</span> person = person.firstName &lt;&gt; <span class="hljs-string">" "</span> &lt;&gt; person.lastName
</code></pre><p>この関数は <code>firstName</code>と <code>lastName</code>というプロパティを含むレコードから完全な名前の文字列を作成します。もし <code>PSCi</code>でこの関数の型を同様に調べたとすると、次のように表示されるでしょう。</p><pre><code class="language-haskell">forall r. { <span class="hljs-attr">firstName</span> :: <span class="hljs-built_in">String</span>, <span class="hljs-attr">lastName</span> :: <span class="hljs-built_in">String</span> | r } -&gt; <span class="hljs-built_in">String</span>
</code></pre><p>この型は「<strong>少なくとも</strong><code>fullName</code>は <code>firstName</code>と <code>lastName</code>という2つのフィールドを持つようなレコードをとり、 <code>String</code>を返す。」というように読みます。</p><p>渡したレコードが <code>firstName</code>と <code>lastName</code>いうプロパティさえ持っていれば、その他に余計なフィールドを持っていたとしても <code>fullName</code>は気にしません。</p><pre><code class="language-text">> firstName { firstName: "Phil", lastName: "Freeman", location: "Los Angeles" }
Phil Freeman
</code></pre><p>同様に、上の <code>main</code>の型は「 <code>main</code>は<strong>副作用のある計算</strong>で、乱数生成とコンソール入出力、<strong>およびそれ以外の任意の種類の副作用</strong>を備えた任意の環境で実行することができ、型 <code>Unit</code>の値を返す」というように解釈できます。</p><p>これは 「拡張可能作用」という名前の由来になっています。必要な副作用さえ備えていれば、その副作用の集まりをいつでも拡張できるということです。</p><h2>8.12 作用の混在</h2><p>拡張可能作用は <code>Eff</code>モナドで異なる型の副作用を<strong>混在</strong>(interleave)させることを可能にします。</p><p>先ほど使った <code>random</code>関数は次のような型を持っています。</p><pre><code class="language-haskell">forall eff1. Eff (random :: RANDOM | eff1) <span class="hljs-built_in">Number</span>
</code></pre><p>この作用の集まり <code>(random :: RANDOM | eff1)</code>は <code>main</code>で見たものと同じ<strong>ではありません</strong>。</p><p>しかし、作用が一致するように <code>random</code>の型を特殊化できます。 <code>eff1</code>に <code>(console :: CONSOLE | eff)</code>を選べば、これらの２つの作用の集合は同じになります。</p><p>同様に <code>logShow</code>は <code>main</code>の作用に合わせて特殊化できる型を持っています。</p><pre><code class="language-haskell"><span class="hljs-title">forall</span> eff2. <span class="hljs-type">Show</span> a =&gt; a -&gt; <span class="hljs-type">Eff</span> (console :: <span class="hljs-type">CONSOLE</span> | eff2) <span class="hljs-type">Unit</span>
</code></pre><p>この場合は、 <code>eff2</code>に <code>(random :: Random | eff)</code>を選ばなくてはなりません。</p><p>それが含む副作用を示す <code>random</code>と <code>logShow</code>の型がポイントで、より大きな副作用の集まりを持ったより大きな計算を構築するために、他の副作用を<strong>混ぜ合わせる</strong>ことができるのです。</p><p><code>main</code>の型注釈を与えなくてもよいことに注意してください。コンパイラは <code>random</code>と <code>logShow</code>の多相的な型が与えられた <code>main</code>について、最も一般的な型を見つけることができます。</p><h2>8.13 Effの種</h2><p><code>main</code>の型は今まで見てきた他の型とは異なります。それを説明するためには、まず <code>Eff</code>の<strong>種</strong>について考える必要があります。値がその型によって分類されるように、型がその種によって分類されることを思い出してください。これまでは <code>Type</code>（型の種）と <code>-></code>（型構築子のための種を構築する）だけから構築された種のみを見てきました。</p><p><code>Eff</code>の種を見るには、 <code>PSCi</code>で <code>:kind</code>コマンドを使います。</p><pre><code class="language-text">> import Control.Monad.Eff

> :kind Eff
# Control.Monad.Eff.Effect -> Type -> Type
</code></pre><p>今まで見たことのない記号が２つあります。</p><p><code>Control.Monad.Eff.Effect</code>は副作用の型についての<strong>型レベルのラベル</strong>を表す<strong>作用</strong>の種です。これを理解するためには、上の <code>main</code>で見た2つのラベルがいずれも種 <code>Control.Monad.Eff.Effect</code>を持っていることに注目してください。</p><pre><code class="language-text">> import Control.Monad.Eff.Console
> import Control.Monad.Eff.Random

> :kind CONSOLE
Control.Monad.Eff.Effect

> :kind RANDOM
Control.Monad.Eff.Effect
</code></pre><p><code>#</code>種構築子は<strong>行</strong>の種を構築するのに使われます。行とは順序なしラベル付きの集合のことです。</p><p>そして、 <code>Eff</code>は作用の行と作用の返り値の型という２つの引数を持っています。つまり、 <code>Eff</code>の最初の引数は、作用の型の順序なしラベル付きの集合であり、２つめの引数は返り値の型だということです。</p><p>これで、先ほどの <code>main</code>の型を読むことができるようになりました。</p><pre><code class="language-text">forall eff. Eff (console :: CONSOLE, random :: RANDOM | eff) Unit
</code></pre><p><code>Eff</code>の最初の引数は <code>(console :: CONSOLE, random :: RANDOM | eff)</code>です。これは <code>CONSOLE</code>作用と <code>Random</code>作用を含む行です。パイプ記号 <code>|</code>は、ラベルが付けられた作用と、それに混ぜあわせたい<strong>それ以外の任意の作用</strong>を表す<strong>行変数</strong>(row variable)<code>eff</code>を区切っています。</p><p><code>Eff</code>の2番目の引数は、計算の戻り値の型 <code>Unit</code>です。</p><h2>8.14 オブジェクトと行</h2><p>拡張可能作用とレコードに深いつながりをもたらしている <code>Eff</code>の種を考えてみましょう。</p><p>上で定義した関数 <code>fullName</code>を考えます。</p><pre><code class="language-haskell">fullName :: forall r. { <span class="hljs-attr">firstName</span> :: <span class="hljs-built_in">String</span>, <span class="hljs-attr">lastName</span> :: <span class="hljs-built_in">String</span> | r } -&gt; <span class="hljs-built_in">String</span>
fullName person = person.firstName &lt;&gt; <span class="hljs-string">" "</span> &lt;&gt; person.lastName
</code></pre><p>種 <code>Type</code>の型だけが値を持つので、関数の矢印の左辺にある型の種は <code>Type</code>でなければなりません。</p><p>中括弧は実際には構文糖であり、PureScriptコンパイラによって理解されている完全な型は次のようなものです。</p><pre><code class="language-haskell">fullName :: forall r. Record (firstName :: <span class="hljs-built_in">String</span>, <span class="hljs-attr">lastName</span> :: <span class="hljs-built_in">String</span> | r) -&gt; <span class="hljs-built_in">String</span>
</code></pre><p>中括弧がなくなっており、 <code>Record</code>構築子が追加されていることに注意してください。 <code>Record</code>は <code>Prim</code>モジュールで定義されている組み込みの型構築子です。 <code>Record</code>の種を調べてみると、次のようになっています。</p><pre><code class="language-text">> :kind Record
# Type -> Type
</code></pre><p>つまり、 <code>Record</code>は<strong>型の行</strong>をとり型を構築する型構築子なのです。これがレコードについての行多相関数を書くことを可能にしているのです。</p><p>この型システムでは、拡張可能作用を扱うのに、行多相レコード(<strong>拡張可能レコード</strong>)を使うときと同じ機構が使われています。唯一の違いは、ラベルに現れる型の<strong>種</strong>です。レコードは型の行によってパラメータ化され、 <code>Eff</code>は作用の行によってパラメータ化されるのです。</p><p>これと同じ型システムの機能は、型構築子の行や、行の行でパラメータ化される型を構築するのにさえ使われることがあります！</p><h2>8.15 きめ細かな作用</h2><p>作用の行は推論されるので、大抵の場合は <code>Eff</code>を使うときに型注釈は必須ではありませんが、計算でどの作用が期待されるのかをコンパイラに示すために型注釈が使われることがあります。</p><p>先ほどの例を、作用の<strong>閉じた</strong>行で注釈すると次のようになります。</p><pre><code class="language-haskell"><span class="hljs-title">main</span> :: <span class="hljs-type">Eff</span> (console :: <span class="hljs-type">CONSOLE</span>, random :: <span class="hljs-type">RANDOM</span>) <span class="hljs-type">Unit</span>
<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
  n &lt;- random
  logShow n
</code></pre><p>行変数 <code>eff</code>がないことに注意してください。こうすると、異なった作用の型を使う計算を誤って含めることはできません。このように、コードが持つことを許される副作用を制御することができるのです。</p><h2>8.16 ハンドラとアクション</h2><p><code>logShow</code>や <code>random</code>のような関数は<strong>アクション</strong>と呼ばれます。アクションはそれらの関数の右辺に <code>Eff</code>型を持っており、その目的は新たな効果を<strong>導入</strong>することにあります。</p><p>これは <code>Eff</code>型が関数の引数の型として現れる<strong>ハンドラ</strong>とは対照的です。アクションが集合へ必要な作用を<strong>追加</strong>するのに対し、ハンドラは集合から作用を<strong>除去</strong>します。</p><p>例として、 <code>purescript-exceptions</code>パッケージを考えてみます。このパッケージでは <code>throwException</code>と <code>catchException</code>という二つの関数が定義されています。</p><pre><code class="language-haskell"><span class="hljs-title">throwException</span> :: <span class="hljs-keyword">forall</span> a eff
                . <span class="hljs-type">Error</span>
               -&gt; <span class="hljs-type">Eff</span> (exception :: <span class="hljs-type">EXCEPTION</span> | eff) a

<span class="hljs-title">catchException</span> :: <span class="hljs-keyword">forall</span> a eff
                . (<span class="hljs-type">Error</span> -&gt; <span class="hljs-type">Eff</span> eff a)
               -&gt; <span class="hljs-type">Eff</span> (exception :: <span class="hljs-type">EXCEPTION</span> | eff) a
               -&gt; <span class="hljs-type">Eff</span> eff a
</code></pre><p><code>throwException</code>はアクションです。 <code>Eff</code>は右辺に現れていて、新しく <code>Exception</code>作用を導入します。</p><p><code>catchException</code>はハンドラです。 <code>Eff</code>は関数の第２引数の型として出現しており、作用全体としては <code>Exception</code>作用を<strong>除去</strong>します。</p><p>特定の作用を必要とするコードの部分を限定するために型システムを使うことができるので、これは便利です。作用のあるコードをハンドラで包むことにより、その作用を許さないコードブロックの中に埋め込むことができます。</p><p>例えば、 <code>Exception</code>作用を使って例外を投げるコード片を書き、それからそのコードを <code>catchException</code>で包むことによって、例外を許さないコード片の中にその計算を埋め込むことができるのです。</p><p>JSONドキュメントからアプリケーションの設定を読みたいとしましょう。文書を構文解析する過程で例外を投げることがあります。設定を読み構文解析するこの処理は、次のような型シグネチャを持つ関数として書くことができます。</p><pre><code class="language-haskell"><span class="hljs-title">readConfig</span> :: <span class="hljs-keyword">forall</span> eff. <span class="hljs-type">Eff</span> (exception :: <span class="hljs-type">EXCEPTION</span> | eff) <span class="hljs-type">Config</span>
</code></pre><p>それから、 <code>main</code>関数で <code>catchException</code>を使用して <code>Exception</code>作用を処理することができます。</p><pre><code class="language-haskell"><span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
    config &lt;- catchException printException readConfig
    runApplication config
  <span class="hljs-keyword">where</span>
    printException e = <span class="hljs-keyword">do</span>
      log (message e)
      pure defaultConfig
</code></pre><p><code>purescript-eff</code>パッケージでも、副作用<strong>なし</strong>の計算を取り、それを純粋な値として安全に評価する <code>runPure</code>ハンドラが定義されています。</p><pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Pure</span> a = <span class="hljs-type">Eff</span> () a</span>

<span class="hljs-title">runPure</span> :: <span class="hljs-keyword">forall</span> a. <span class="hljs-type">Pure</span> a -&gt; a
</code></pre><h2>8.17 可変状態</h2><p>Preludeには <code>ST</code>作用というまた別の作用も定義されています。</p><p><code>ST</code>作用は変更可能な状態を操作するために使われます。純粋関数プログラミングを知っているなら、共有される変更可能な状態は問題を引き起こしやすいということも知っているでしょう。しかしながら、 <code>ST</code>作用は型システムを使って安全で<strong>局所的な</strong>状態変化を可能にし、状態の共有を制限するのです。</p><p><code>ST</code>作用は <code>Control.Monad.ST</code>モジュールで定義されています。これがどのように動作するかを確認するには、そのアクションの型を見る必要があります。</p><pre><code class="language-haskell"><span class="hljs-title">newSTRef</span> :: <span class="hljs-keyword">forall</span> a h eff. a -&gt; <span class="hljs-type">Eff</span> (st :: <span class="hljs-type">ST</span> h | eff) (<span class="hljs-type">STRef</span> h a)

<span class="hljs-title">readSTRef</span> :: <span class="hljs-keyword">forall</span> a h eff. <span class="hljs-type">STRef</span> h a -&gt; <span class="hljs-type">Eff</span> (st :: <span class="hljs-type">ST</span> h | eff) a

<span class="hljs-title">writeSTRef</span> :: <span class="hljs-keyword">forall</span> a h eff. <span class="hljs-type">STRef</span> h a -&gt; a -&gt; <span class="hljs-type">Eff</span> (st :: <span class="hljs-type">ST</span> h | eff) a

<span class="hljs-title">modifySTRef</span> :: <span class="hljs-keyword">forall</span> a h eff. <span class="hljs-type">STRef</span> h a -&gt; (a -&gt; a) -&gt; <span class="hljs-type">Eff</span> (st :: <span class="hljs-type">ST</span> h | eff) a
</code></pre><p><code>newSTRef</code>は型 <code>STRef h a</code>の変更可能な参照領域を新しく作るのに使われます。 <code>STRef h a</code>は <code>readSTRef</code>アクションを使って状態を読み取ったり、 <code>writeSTRef</code>アクションや <code>modifySTRef</code>アクションで状態を変更するのに使われます。型 <code>a</code>は領域に格納された値の型で、型 <code>h</code>は型システムの<strong>メモリ領域</strong>を表しています。</p><p>例を示します。小さな時間刻みで簡単な更新関数の実行を何度も繰り返すことによって、重力に従って落下する粒子の落下の動きをシミュレートしたいとしましょう。</p><p>粒子の位置と速度を保持する変更可能な参照領域を作成し、領域に格納された値を更新するのにforループ(<code>Control.Monad.Eff</code>の <code>forE</code>アクション)を使うことでこれを実現することができます。</p><pre><code class="language-haskell"><span class="hljs-keyword">import</span> Prelude

<span class="hljs-keyword">import</span> Control.Monad.Eff (<span class="hljs-type">Eff</span>, <span class="hljs-title">forE</span>)
<span class="hljs-keyword">import</span> Control.Monad.ST (<span class="hljs-type">ST</span>, <span class="hljs-title">newSTRef</span>, <span class="hljs-title">readSTRef</span>, <span class="hljs-title">modifySTRef</span>)

<span class="hljs-title">simulate</span> :: <span class="hljs-keyword">forall</span> eff h. <span class="hljs-type">Number</span> -&gt; <span class="hljs-type">Number</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Eff</span> (st :: <span class="hljs-type">ST</span> h | eff) <span class="hljs-type">Number</span>
<span class="hljs-title">simulate</span> x0 v0 time = <span class="hljs-keyword">do</span>
  ref &lt;- newSTRef { x: x0, v: v0 }
  forE <span class="hljs-number">0</span> (time * <span class="hljs-number">1000</span>) \_ -&gt; <span class="hljs-keyword">do</span>
    modifySTRef ref \o -&gt;
      { v: o.v - <span class="hljs-number">9.81</span> * <span class="hljs-number">0.001</span>
      , x: o.x + o.v * <span class="hljs-number">0.001</span>
      }
    pure unit
  final &lt;- readSTRef ref
  pure final.x
</code></pre><p>計算の最後では、参照領域の最終的な値を読み取り、粒子の位置を返しています。</p><p>この関数が変更可能な状態を使っていても、その参照区画 <code>ref</code>がプログラムの他の部分で使われるのが許されない限り、これは純粋な関数のままであることに注意してください。 <code>ST</code>作用が禁止するものが正確には何であるのかについては後ほど見ます。</p><p><code>ST</code>作用で計算を実行するには、 <code>runST</code>関数を使用する必要があります。</p><pre><code class="language-haskell"><span class="hljs-title">runST</span> :: <span class="hljs-keyword">forall</span> a eff. (<span class="hljs-keyword">forall</span> h. <span class="hljs-type">Eff</span> (st :: <span class="hljs-type">ST</span> h | eff) a) -&gt; <span class="hljs-type">Eff</span> eff a
</code></pre><p>ここで注目して欲しいのは、領域型 <code>h</code>が関数矢印の左辺にある<strong>括弧の内側で</strong>量化されているということです。 <code>runST</code>に渡したどんなアクションでも、 <strong>任意の領域</strong><code>h</code>がなんであれ動作するということを意味しています。</p><p>しかしながら、ひとたび参照領域が <code>newSTRef</code>によって作成されると、その領域の型はすでに固定されており、 <code>runST</code>によって限定されたコードの外側で参照領域を使おうとしても型エラーになるでしょう。 <code>runST</code>が安全に <code>ST</code>作用を除去できるのはこれが理由なのです！</p><p>実際に、 <code>ST</code>はこの例の唯一の作用なので、 <code>runPure</code>と <code>runST</code>を併用すると <code>simulate</code>を純粋な関数に変えることができます、</p><pre><code class="language-haskell"><span class="hljs-title">simulate'</span> :: <span class="hljs-type">Number</span> -&gt; <span class="hljs-type">Number</span> -&gt; <span class="hljs-type">Number</span> -&gt; <span class="hljs-type">Number</span>
<span class="hljs-title">simulate'</span> x0 v0 time = runPure (runST (simulate x0 v0 time))
</code></pre><p><code>PSCi</code>でこの関数を実行してみてください。</p><pre><code class="language-text">> import Main

> simulate' 100.0 0.0 0.0
100.00

> simulate' 100.0 0.0 1.0
95.10

> simulate' 100.0 0.0 2.0
80.39

> simulate' 100.0 0.0 3.0
55.87

> simulate' 100.0 0.0 4.0
21.54
</code></pre><p>もし <code>simulate</code>の定義を <code>runST</code>の呼び出しのところへ埋め込むとすると、次のようになります。</p><pre><code class="language-haskell"><span class="hljs-title">simulate</span> :: <span class="hljs-type">Number</span> -&gt; <span class="hljs-type">Number</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Number</span>
<span class="hljs-title">simulate</span> x0 v0 time = runPure $ runST <span class="hljs-keyword">do</span>
  ref &lt;- newSTRef { x: x0, v: v0 }
  forE <span class="hljs-number">0</span> (time * <span class="hljs-number">1000</span>) \_ -&gt; <span class="hljs-keyword">do</span>
    modifySTRef ref \o -&gt;  
      { v: o.v - <span class="hljs-number">9.81</span> * <span class="hljs-number">0.001</span>
      , x: o.x + o.v * <span class="hljs-number">0.001</span>  
      }
    pure unit  
  final &lt;- readSTRef ref
  pure final.x
</code></pre><p>参照区画はそのスコープから逃れることができないことがコンパイラにわかりますし、安全に <code>var</code>に変換することができます。 <code>runST</code>の呼び出しの本体に対して生成されたJavaScriptは次のようになります。</p><pre><code class="language-javascript"><span class="hljs-keyword">var</span> ref = { <span class="hljs-attr">x</span>: x0, <span class="hljs-attr">v</span>: v0 };

Control_Monad_Eff.forE(<span class="hljs-number">0</span>)(time * <span class="hljs-number">1000</span> | <span class="hljs-number">0</span>)(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__do</span>(<span class="hljs-params"></span>) </span>{
    ref = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o</span>) </span>{
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">v</span>: o.v - <span class="hljs-number">9.81</span> * <span class="hljs-number">1.0e-3</span>,
        <span class="hljs-attr">x</span>: o.x + o.v * <span class="hljs-number">1.0e-3</span>
      };
    })(ref);
    <span class="hljs-keyword">return</span> Prelude.unit;
  };
})();

<span class="hljs-keyword">return</span> ref.x;
</code></pre><p>局所的な変更可能状態を扱うとき、特に <code>Eff</code>モナドで効率のよいループを生成する <code>forE</code>、 <code>foreachE</code>、 <code>whileE</code>、 <code>untilE</code>のようなアクションを一緒に使うときには、 <code>ST</code>作用は短いJavaScriptを生成できる良い方法となります。</p><div class="exercise"><h2>演習</h2><ol>
<li>
<p>（やや難しい） もし分母で分子を割り切れないなら <code>throwException</code>を使って例外を投げるように <code>safeDivide</code>関数を書き直してください。</p>
</li>
<li>
<p>（難しい） PIを推定するには次のような簡単な方法があります。単位正方形内にある多数の <code>N</code>個の点を無作為に選び、内接する円に含まれるものの個数 <code>n</code>を数えます。このとき <code>4n/N</code>が円周率 <code>pi</code>の概算となります。 <code>forE</code>関数、 <code>Random</code>作用、 <code>ST</code>作用を使って、この方法で円周率 <code>pi</code>を推定する関数を書いてください。</p>
</li>
</ol></div><h2>8.18 DOM作用</h2><p>この章の最後の節では、 <code>Eff</code>モナドでの作用についてこれまで学んだことを、実際のDOM操作の問題に応用します。</p><p>DOMを直接扱ったり、オープンソースのDOMライブラリを扱う、自由に利用可能なPureScriptパッケージが幾つかあります。</p><ul>
<li><a href="http://github.com/purescript-contrib/purescript-dom"><code>purescript-dom</code></a> - 低レベルなJavaScript DOM APIのバインディング</li>
<li><a href="http://github.com/paf31/purescript-jquery"><code>purescript-jquery</code></a> - <a href="http://jquery.org">jQuery</a>ライブラリのバインディング</li>
</ul><p>上記のライブラリを抽象化するPureScript向けのライブラリもあります。</p><ul>
<li><a href="http://github.com/paf31/purescript-thermite"><code>purescript-thermite</code></a> - <code>purescript-react</code>上で構築されるライブラリ</li>
<li><a href="http://github.com/slamdata/purescript-halogen"><code>purescript-halogen</code></a> - 仮想DOMを抽象的する型安全なライブラリ</li>
</ul><p>この章では <code>purescript-react</code>を使用し、住所簿にインターフェイスを追加しますが、興味のあるユーザは異なるアプローチで進めることをおすすめします。</p><h2>8.19 住所録のユーザーインタフェース</h2><p><code>purescript-react</code>を使用するために<strong>Reactコンポーネント</strong>と同じ様にアプリケーションを定義します。Reactコンポーネントは、コード内のHTML要素を純粋なデータ構造体として記述し、効率的にDOMにレンダリングします。さらに、コンポーネントはボタンのクリックなどのイベントに応答できます。 <code>purescript-react</code>ライブラリは <code>Eff</code>モナドを使ってこれらのイベントをどのように扱うかを記述します。</p><p>Reactライブラリの完全なチュートリアルはこの章の範囲をはるかに超えていますが、読者は必要に応じてマニュアルを参照することをお勧めします。目的に応じて、Reactは <code>Eff</code>モナドの実用的な例を提供してくれます。</p><p>まずは利用者が住所録に新しい項目を追加できるフォームを構築することにしましょう。フォームには、さまざまなフィールド（姓、名前、都市、州など）を入力するテキストボックス、および検証エラーが表示される領域が含まれます。テキストボックスに利用者がテキストを入力すると、検証エラーが更新されます。</p><p>シンプルさを保つために、フォームは固定の形状とします。電話番号は種類（自宅、携帯電話、仕事、その他）ごとに別々のテキストボックスへ分けることにします。</p><p>次の行を除いて、HTMLファイルは基本的に空です。</p><pre><code class="language-html"><script type="text/javascript" src="../dist/Main.js"></script>
</code></pre><p>この行には、Pulpによって生成されたJavaScriptコードが含まれています。これをファイルの最後に配置して、コードからアクセスしようとする関連要素が上にあることを確認します。 <code>Main.js</code>ファイルを再構築するには、 <code>pulp browserify</code>コマンドを使うことができます。最初に <code>dist</code>ディレクトリが存在し、ReactをNPM依存関係としてインストールしたことを確認してください。</p><pre><code class="language-text">$ npm install # Install React
$ mkdir dist/
$ pulp browserify --to dist/Main.js
</code></pre><p><code>Main</code>モジュールは住所録コンポーネントを作成して画面に表示する <code>main</code>関数を定義しています。 <code>main</code>関数は <code>CONSOLE</code>作用と <code>DOM</code>作用のみを使用しており、型シグニチャは次のことを示します。</p><pre><code class="language-haskell">main :: Eff (<span class="hljs-built_in">console</span> :: CONSOLE, <span class="hljs-attr">dom</span> :: DOM) Unit
</code></pre><p>まず、 <code>main</code>はコンソールにステータスメッセージを記録します。</p><pre><code class="language-haskell">main = <span class="hljs-keyword">void</span> <span class="hljs-keyword">do</span>
  log <span class="hljs-string">"Rendering address book component"</span>
</code></pre><p>その後、 <code>main</code>はDOM APIを使用してドキュメント本体への参照（ <code>doc</code>）を取得します。</p><pre><code class="language-haskell">  doc &lt;- <span class="hljs-built_in">window</span> &gt;&gt;= <span class="hljs-built_in">document</span>
</code></pre><p>これは混在した作用の一例になっていることに注目してください。 <code>log</code>関数は <code>CONSOLE</code>作用を使い、 <code>window</code>と <code>document</code>関数は両方とも <code>DOM</code>作用を使います。 <code>main</code>の型は両方の作用を利用することを示します。</p><p><code>main</code>は <code>window</code>アクションを使ってウィンドウオブジェクトへの参照を取得し、その結果を <code>document</code>関数に <code>>>=</code>を使って渡します。 <code>document</code>はウィンドウオブジェクトをとり、そのドキュメントへの参照を返します。</p><p>do記法の定義により、これを次のようにも書けることに注意してください。</p><pre><code class="language-haskell">  w &lt;- window
  doc &lt;- document w
</code></pre><p>どちらが読みやすいかどうかは個人の好みの問題です。前者は名前が付けられた関数の引数がなく、<strong>point-free</strong>形式の一例となっています。その一方で、後者ではウィンドウオブジェクトの名前として <code>w</code>が使われています。</p><p><code>Main</code>モジュールは <code>addressBook</code>と呼ばれる住所録<strong>コンポーネント</strong>を定義します。その定義を理解するために、まずいくつかの概念を理解する必要があります。</p><p>Reactコンポーネントを作成するには、最初にコンポーネントのテンプレートのように動作するReact<strong>クラス</strong>を作成する必要があります。 <code>purescript-react</code>では、 <code>createClass</code>関数を使ってクラスを作成することができます。 <code>createClass</code>はクラスの<strong>仕様</strong>を必要とします。この本質は、コンポーネントのライフサイクルについて処理するために使われる <code>Eff</code>アクションの集合です。開発者が注目するべきなのは <code>Render</code>アクションです。</p><p>Reactライブラリが提供するいくつかの関連する関数の型は次のとおりです。</p><pre><code class="language-haskell"><span class="hljs-title">createClass</span>
  :: <span class="hljs-keyword">forall</span> props state eff
   . <span class="hljs-type">ReactSpec</span> props state eff
  -&gt; <span class="hljs-type">ReactClass</span> props

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Render</span> props state eff</span>
   = <span class="hljs-type">ReactThis</span> props state
  -&gt; <span class="hljs-type">Eff</span> ( props :: <span class="hljs-type">ReactProps</span>
         , refs :: <span class="hljs-type">ReactRefs</span> <span class="hljs-type">Disallowed</span>
         , state :: <span class="hljs-type">ReactState</span> <span class="hljs-type">ReadOnly</span>
         | eff
         ) <span class="hljs-type">ReactElement</span>

<span class="hljs-title">spec</span>
  :: <span class="hljs-keyword">forall</span> props state eff
   . state
  -&gt; <span class="hljs-type">Render</span> props state eff
  -&gt; <span class="hljs-type">ReactSpec</span> props state eff
</code></pre><ul>
<li><code>Render</code>型同義語は、いくつかの型シグネチャを単純化するために提供され、コンポーネントのレンダリング機能を表します。</li>
<li><code>Render</code>アクションは（ <code>ReactThis</code>型の）コンポーネントへの参照をとり、 <code>Eff</code>モナドに <code>ReactElement</code>を返します。 <code>ReactElement</code>はレンダリング後の意図したDOMの状態を記述するデータ構造体です。</li>
<li>すべてのReactコンポーネントは、ある型の状態を定義します。ボタンのクリックなどのイベントに応じて状態を変更することができます。 <code>purescript-react</code>では、初期状態値が <code>spec</code>関数で提供されます。</li>
<li><code>Render</code>型の作用の行は、いくつかの面白い作用を使用して、特定の関数からReactコンポーネントの状態へのアクセスを制限します。たとえば、レンダリングのあいだ、「refs」オブジェクトへのアクセスは <code>Disallowed</code>であり、コンポーネント状態へのアクセスは <code>ReadOnly</code>です。</li>
</ul><p><code>Main</code>モジュールは、住所録コンポーネントの状態の型と初期状態を定義します。</p><pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">AppState</span> = <span class="hljs-type">AppState</span></span>
  { person :: <span class="hljs-type">Person</span>
  , errors :: <span class="hljs-type">Errors</span>
  }

<span class="hljs-title">initialState</span> :: <span class="hljs-type">AppState</span>
<span class="hljs-title">initialState</span> = <span class="hljs-type">AppState</span>
  { person: examplePerson
  , errors: []
  }
</code></pre><p>状態には、（フォームコンポーネントを使用して編集可能にする） <code>Person</code>レコードと、既存の検証コードを使用して入力されるエラーの配列が含まれています。</p><p>次に、コンポーネントの定義を見てみましょう。</p><pre><code class="language-haskell"><span class="hljs-title">addressBook</span> :: <span class="hljs-keyword">forall</span> props. <span class="hljs-type">ReactClass</span> props
</code></pre><p>すでに述べたように、<code>addressBook</code>は<code>createClass</code>と<code>spec</code>を使用してReactクラスを作成します。ここから初期状態の値と<code>Render</code>アクションを得ることができます。取得した<code>Render</code>アクションでいったい何ができるのでしょうか？　例えば、<code>purescript-react</code>は以下のような単純なアクションを提供しています。</p><pre><code class="language-haskell"><span class="hljs-title">readState</span>
  :: <span class="hljs-keyword">forall</span> props state access eff
   . <span class="hljs-type">ReactThis</span> props state
  -&gt; <span class="hljs-type">Eff</span> ( state :: <span class="hljs-type">ReactState</span> ( read :: <span class="hljs-type">Read</span>
                               | access
                               )
         | eff
         ) state

<span class="hljs-title">writeState</span>
  :: <span class="hljs-keyword">forall</span> props state access eff
   . <span class="hljs-type">ReactThis</span> props state
  -&gt; state
  -&gt; <span class="hljs-type">Eff</span> ( state :: <span class="hljs-type">ReactState</span> ( write :: <span class="hljs-type">Write</span>
                               | access
                               )
         | eff
         ) state
</code></pre><p><code>readState</code>と <code>writeState</code>アクションは拡張可能作用を伴って、ReactState作用を使ってReactの状態にアクセスできるようにしますが、<strong>他の</strong>行の <code>ReactState</code>作用をパラメータ化することで、読み書き権限がさらに分離されることに注意してください！</p><p>これは、PureScriptの行ベースの作用に関する興味深い点を示しています。行内に現れる作用は単純な１要素である必要はなく、様々な構造を持つことができ、この柔軟性によってコンパイル時にいくつかの有用な制限が可能になります。 <code>purescript-react</code>ライブラリがこの制限をしなかった場合、 <code>Render</code>アクションで状態を書き込もうとすると、実行時に例外を受け取ることになります。適切な制限を行うことで、このような間違いがコンパイル時に捕捉されるようになりました。</p><p>これで <code>addressBook</code>コンポーネントの定義を読むことができるようになりました。まずは現在のコンポーネントの状態を読むことから始めましょう。</p><pre><code class="language-haskell"><span class="hljs-title">addressBook</span> = createClass $ spec initialState \ctx -&gt; <span class="hljs-keyword">do</span>
  <span class="hljs-type">AppState</span> { person: <span class="hljs-type">Person</span> person@{ homeAddress: <span class="hljs-type">Address</span> address }
           , errors
           } &lt;- readState ctx
</code></pre><p>次の点に注意してください。</p><ul>
<li>名前<code>ctx</code>は <code>ReactThis</code>を参照しており、必要に応じて状態を読み書きするために使用することができます。</li>
<li>AppState内のレコードは、レコードパターンを使用して照合しています。これには<strong>errors</strong>フィールドのレコード同名利用も含まれます。便利なように、状態の構造のそれぞれの部分に明示的な名前をつけています。</li>
</ul><p><code>Render</code>はDOMの次の状態を表す<code>ReactElement</code>構造体を返さなければならないのでした。<code>Render</code>アクションはいくつかの補助関数から定義されています。その補助関数の1つは <code>renderValidationErrors</code>です。これは<code>Errors</code>構造体を<code>ReactElement</code>の配列に変換します。</p><pre><code class="language-haskell"><span class="hljs-title">renderValidationError</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">ReactElement</span>
<span class="hljs-title">renderValidationError</span> err = <span class="hljs-type">D</span>.li' [ <span class="hljs-type">D</span>.text err ]

<span class="hljs-title">renderValidationErrors</span> :: <span class="hljs-type">Errors</span> -&gt; <span class="hljs-type">Array</span> <span class="hljs-type">ReactElement</span>
<span class="hljs-title">renderValidationErrors</span> [] = []
<span class="hljs-title">renderValidationErrors</span> xs =
  [ <span class="hljs-type">D</span>.div [ <span class="hljs-type">P</span>.className <span class="hljs-string">"alert alert-danger"</span> ]
          [ <span class="hljs-type">D</span>.ul' (map renderValidationError xs) ]
  ]
</code></pre><p><code>purescript-react</code>では、 <code>ReactElement</code>は通常、単一のHTML要素を <code>div</code>のような関数を適用することで作成します。これらの関数は通常、属性の配列と子要素の配列を引数として取ります。しかし、ここでは <code>ul'</code>のようにプライム記号(', prime character)で終わる名前は属性配列を省略し、代わりにデフォルトの属性を使用します。</p><p>ここでは通常のデータ構造体を単純に操作しているので、 <code>map</code>のような関数を使って様々な要素を構築することができます。</p><p>2番目の補助関数は <code>formField</code>です。これは、単一フォームフィールドのテキスト入力を含む <code>ReactElement</code>を作成します。</p><pre><code class="language-haskell"><span class="hljs-title">formField</span>
  :: <span class="hljs-type">String</span>
  -&gt; <span class="hljs-type">String</span>
  -&gt; <span class="hljs-type">String</span>
  -&gt; (<span class="hljs-type">String</span> -&gt; <span class="hljs-type">Person</span>)
  -&gt; <span class="hljs-type">ReactElement</span>
<span class="hljs-title">formField</span> name hint value update =
  <span class="hljs-type">D</span>.div [ <span class="hljs-type">P</span>.className <span class="hljs-string">"form-group"</span> ]
        [ <span class="hljs-type">D</span>.label [ <span class="hljs-type">P</span>.className <span class="hljs-string">"col-sm-2 control-label"</span> ]
                  [ <span class="hljs-type">D</span>.text name ]
        , <span class="hljs-type">D</span>.div [ <span class="hljs-type">P</span>.className <span class="hljs-string">"col-sm-3"</span> ]
                [ <span class="hljs-type">D</span>.input [ <span class="hljs-type">P</span>._type <span class="hljs-string">"text"</span>
                          , <span class="hljs-type">P</span>.className <span class="hljs-string">"form-control"</span>
                          , <span class="hljs-type">P</span>.placeholder hint
                          , <span class="hljs-type">P</span>.value value
                          , <span class="hljs-type">P</span>.onChange (updateAppState ctx update)
                          ] []
                ]
        ]
</code></pre><p>繰り返しますが、単純な要素から様々な要素を構成し、それぞれの要素に属性を適用しています。ここで注目すべき属性の1つは、 <code>input</code>要素に適用される <code>onChange</code>属性です。これは<strong>イベントハンドラ</strong>で、ユーザーがテキストボックス内のテキストを編集するときにコンポーネントの状態を更新するために使用されます。イベントハンドラは、3番目の補助関数 <code>updateAppState</code>を使用して定義されています。</p><pre><code class="language-haskell"><span class="hljs-title">updateAppState</span>
  :: <span class="hljs-keyword">forall</span> props eff
   . <span class="hljs-type">ReactThis</span> props <span class="hljs-type">AppState</span>
  -&gt; (<span class="hljs-type">String</span> -&gt; <span class="hljs-type">Person</span>)
  -&gt; <span class="hljs-type">Event</span>
  -&gt; <span class="hljs-type">Eff</span> ( console :: <span class="hljs-type">CONSOLE</span>
         , state :: <span class="hljs-type">ReactState</span> <span class="hljs-type">ReadWrite</span>
         | eff
         ) <span class="hljs-type">Unit</span>
</code></pre><p><code>updateAppState</code>は、 <code>ReactThis</code>値の形式でコンポーネントへの参照、 <code>Person</code>レコードを更新する関数、そして <code>Event</code>レコードを取ります。まず、（valueOf補助関数を使用して） <code>change</code>イベントからテキストボックスの新しい値を抽出し、それを使って新しい <code>Person</code>状態を作成します。</p><pre><code class="language-haskell">  for_ (valueOf e) \s -&gt; <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">let</span> newPerson = update s
</code></pre><p>次に、検証関数を実行し、それに応じて（writeStateを使用して）コンポーネントの状態を更新します。</p><pre><code class="language-haskell">    log <span class="hljs-string">"Running validators"</span>
    <span class="hljs-keyword">case</span> validatePerson' newPerson <span class="hljs-keyword">of</span>
      <span class="hljs-type">Left</span> errors -&gt;
        writeState ctx (<span class="hljs-type">AppState</span> { person: newPerson
                                 , errors: errors
                                 })
      <span class="hljs-type">Right</span> _ -&gt;
        writeState ctx (<span class="hljs-type">AppState</span> { person: newPerson
                                 , errors: []
                                 })
</code></pre><p>これは、コンポーネント実装の基本をカバーしています。しかし、コンポーネントの仕組みを完全に理解するためには、この章に付随する情報をお読みください。</p><p><code>pulp browserify --to dist/Main.js</code>を実行して、それからWebブラウザで <code>html/index.html</code>を開き、ユーザインターフェイスを試してみてください。フォームフィールドにいろいろな値を入力すると、ページ上に出力された検証エラーを見ることができるでしょう。</p><p>このユーザインタフェースには明らかに改善すべき点がたくさんあります。演習ではアプリケーションがより使いやすくなるような方法を追究していきます。</p><div class="exercise"><h2>演習</h2><ol>
<li>
<p>(簡単) このアプリケーションを変更し、職場の電話番号を入力できるテキストボックスを追加してください。</p>
</li>
<li>
<p>(やや難しい) 検証エラーを <code>ul</code>要素を使ってリストで表示するかわりに、それぞれのエラーについてひとつづつ <code>alert</code>スタイルで <code>div</code>を作成するように、コードを変更してください。</p>
</li>
<li>
<p>(難しい、拡張) このユーザーインターフェイスの問題のひとつは、検証エラーがその発生源であるフォームフィールドの隣に表示されていないことです。コードを変更してこの問題を解決してください。</p>
<p><strong>ヒント</strong>：検証器によって返されるエラーの型は、エラーの原因となっているフィールドを示すために拡張する必要があります。次のようなエラー型を使用したくなるかもしれません。</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Field</span> = <span class="hljs-type">FirstNameField</span></span>
           | <span class="hljs-type">LastNameField</span>
           | <span class="hljs-type">StreetField</span>
           | <span class="hljs-type">CityField</span>
           | <span class="hljs-type">StateField</span>
           | <span class="hljs-type">PhoneField</span> <span class="hljs-type">PhoneType</span>

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">ValidationError</span> = <span class="hljs-type">ValidationError</span> <span class="hljs-type">String</span> <span class="hljs-type">Field</span></span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Errors</span> = <span class="hljs-type">Array</span> <span class="hljs-type">ValidationError</span></span>
</code></pre>
<p>適切なフォーム要素を選択するように、 <code>Field</code>を <code>querySelector</code>アクションの呼び出しに変更する関数を書く必要があるでしょう。</p>
</li>
</ol></div><h2>まとめ</h2><p>この章ではPureScriptでの副作用の扱いについての多くの考え方を導入しました。</p><ul>
<li><code>Monad</code>型クラスと、それに関連するdo記法の導入をしました。</li>
<li>モナド則を導入し、do記法使って書かれたコードを変換する方法を説明しました。</li>
<li>異なる副作用で動作するコードを書くために、モナドを抽象的に扱う方法を説明しました。</li>
<li>モナドがApplicative関手の一例であること、両者がどのように副作用のある計算を可能にするのか、2つの手法の違いを説明しました。</li>
<li>ネイティブな作用の概念を定義し、ネイティブな副作用を処理するために使用する <code>Eff</code>モナドを導入しました。</li>
<li>どのように <code>Eff</code>モナドが拡張可能作用を提供するか、複数の種類のネイティブな作用を同じ計算に混在させる方法を説明しました。</li>
<li>作用やレコードが種システムでどのように扱われるか、拡張可能レコードと拡張可能作用の関連を見ました。</li>
<li>乱数生成、例外、コンソール入出力、変更可能な状態、およびDOM操作といった、さまざまな作用を扱うために <code>Eff</code>モナドを使いました。</li>
</ul><p><code>Eff</code>モナドは現実のPureScriptコードにおける基本的なツールです。本書ではこのあとも、様々な場面で副作用を処理するために <code>Eff</code>モナドを使っていきます。</p><a href="chapter09.html"><div class="next">次の第9章を読む</div></a><p class="home"><a href="index.html">目次に戻る</a></p></div>
  </div>


</body></html>