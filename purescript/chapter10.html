<!DOCTYPE html><html><head><meta charset="UTF-8">

  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="実例によるPureScript">
  <meta name="twitter:description" content="純粋関数型プログラミング言語 PureScriptの入門書、"PureScript by Example"の日本語訳">
  <meta name="twitter:いまげ" content="http://aratama.github.io/purescript/card.png">    
  <meta property="og:url" content="http://aratama.github.io/purescript/">
  <meta property="og:title" content="実例によるPureScript">
  <meta property="og:description" content="純粋関数型プログラミング言語 PureScriptの入門書、"PureScript by Example"の日本語訳">
  <meta property="og:image" content="http://aratama.github.io/purescript/card.png">
  
  <title>実例によるPureScript</title>

  <link rel="icon" type="image/png" href="favicon-96x96.png" sizes="96x96">
  <link rel="stylesheet" href="github-markdown.css" type="text/css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Roboto">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/agate.min.css">
</head>

<body>
  <div class="main">
    <header>
      <a class="logo" href="/purescript/">
          <img class="logo" src="logo-shadow.png">
      </a>
      <div class="title">
          <h1 id="実例によるpurescript">実例による<wbr>PureScript</h1>
          <p>ウェブのための<wbr>関数型<wbr>プログラミング</p>
          <p class="author">
            <a href="https://leanpub.com/purescript/read">
              Phil Freeman, "PureScript by Example - Functional Programming for the Web"
            </a>
          </p>
      </div>
    </header>

    <div class="markdown-body content">
    <p class="home"><a href="index.html">目次に戻る</a></p>
<h1>第10章 外部関数インタフェース</h1>
<h2>10.1 この章の目標</h2>
<p>この章では、PureScriptコードからJavaScriptコードへの呼び出し、およびその逆を可能にする、PureScriptの<strong>外部関数インタフェース</strong>(foreign function interface, FFI)を紹介します。これから扱うのは次のようなものです。</p>
<ul>
<li>PureScriptから純粋なJavaScript関数を呼び出す方法</li>
<li>既存のJavaScriptコードに基づいて、作用型と <code>Eff</code>モナドと一緒に使用する新しいアクションを作成する方法</li>
<li>JavaScriptからPureScriptコードを呼び出す方法</li>
<li>実行時のPureScriptの値の表現を知る方法</li>
<li><code>purescript-foreign</code>パッケージを使用して型付けされていないデータを操作する方法</li>
</ul>
<p>この章の終わりにかけて、再び住所録のコード例について検討します。この章の目的は、FFIを使ってアプリケーションに次のような新しい機能を追加することです。</p>
<ul>
<li>ポップアップ通知でユーザーに警告する</li>
<li>フォームのデータを直列化してブラウザのローカルストレージに保存し、アプリケーションが再起動したときにそれを再読み込みする</li>
</ul>
<h2>10.2 プロジェクトの準備</h2>
<p>このモジュールのソースコードは、第3章、第7章及び第8章の続きになります。今回もそれぞれのディレクトリから適切なソースファイルがソースファイルに含められています。</p>
<p>この章では、2つの新しいBower依存関係を追加します。</p>
<ol>
<li><code>purescript-foreign</code>- データ型と関数を提供しています。</li>
<li><code>purescript-foreign-generic</code>- <strong>データ型ジェネリックプログラミング</strong>を操作するためのデータ型と関数を提供します。</li>
</ol>
<p><strong>注意</strong>：ウェブページがローカルファイルから配信されているときに起こる、ローカルストレージとブラウザ特有の問題を避けるために、この章の例を実行するには、HTTPを経由してこの章のプロジェクトを実行する必要があります。</p>
<h2>10.3 免責事項</h2>
<p>JavaScriptとの共同作業をできる限り簡単にするため、PureScriptは単純な多言語関数インタフェースを提供します。しかしながら、FFIはPureScriptの<strong>高度な</strong>機能であることには留意していただきたいと思います。FFIを安全かつ効率的に使用するには、扱うつもりであるデータの実行時の表現についてよく理解していなければなりません。この章では、PureScriptの標準ライブラリのコードに関連する、そのような理解を与えることを目指しています。</p>
<p>PureScriptのFFIはとても柔軟に設計されています。実際には、外部関数に最低限の型だけを与えるか、それとも型システムを利用して外部のコードの誤った使い方を防ぐようにするか、開発者が選ぶことができるということを意味しています。標準ライブラリのコードは、後者の手法を好む傾向にあります。</p>
<p>簡単な例としては、JavaScriptの関数で戻り値が <code>null</code>をされないことを保証することはできません。実のところ、既存のJavaScriptコードはかなり頻繁に <code>null</code>を返します！しかし、PureScriptの型は通常null値を持っていません。そのため、FFIを使ってJavaScriptコードのインターフェイスを設計するときは、これらの特殊な場合を適切に処理するのは開発者の責任です。</p>
<h2>10.4 JavaScriptからPureScriptを呼び出す</h2>
<p>少なくとも単純な型を持った関数については、JavaScriptからPureScript関数を呼び出すのはとても簡単です。</p>
<p>例として以下のような簡単なモジュールを見てみましょう。</p>
<pre><code class="language-haskell"><span class="hljs-keyword">module</span> Test <span class="hljs-keyword">where</span>

<span class="hljs-title">gcd</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span>
<span class="hljs-title">gcd</span> <span class="hljs-number">0</span> m = m
<span class="hljs-title">gcd</span> n <span class="hljs-number">0</span> = n
<span class="hljs-title">gcd</span> n m
  | n &gt; m     = gcd (n - m) m
  | otherwise = gcd (m - n) n
</code></pre>
<p>この関数は、減算を繰り返すことによって2つの数の最大公約数を見つけます。関数を定義するのにPureScriptを使いたくなるかもしれない良い例となっていますが、JavaScriptからそれを呼び出すためには条件があります。
PureScriptでパターン照合と再帰を使用してこの関数を定義するのは簡単で、実装する開発者は型検証器の恩恵を受けることができます。</p>
<p>この関数をJavaScriptから呼び出す方法を理解するには、PureScriptの関数は常に引数がひとつのJavaScript関数へと変換され、引数へは次のようにひとつづつ適用していかなければならないことを理解するのが重要です。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> Test = <span class="hljs-built_in">require</span>(<span class="hljs-string">'Test'</span>);
Test.gcd(<span class="hljs-number">15</span>)(<span class="hljs-number">20</span>);
</code></pre>
<p>ここでは、コードがPureScriptモジュールをCommonJSモジュールにコンパイルする <code>pulp build</code>でコンパイルされていると仮定しています。 そのため、 <code>require</code>を使って <code>Test</code>モジュールをインポートした後、 <code>Test</code>オブジェクトの <code>gcd</code>関数を参照することができました。</p>
<p><code>pulp build -O --to file.js</code>を使用して、ブラウザ用のJavaScriptコードをバンドルすることもできます。 その場合、グローバルなPureScript名前空間から <code>Test</code>モジュールにアクセスします。デフォルトは <code>PS</code>です。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> Test = PS.Test;
Test.gcd(<span class="hljs-number">15</span>)(<span class="hljs-number">20</span>);
</code></pre>
<h2>10.5 名前の生成を理解する</h2>
<p>PureScriptはコード生成時にできるだけ名前を保存することを目的としています。具体的には、トップレベルでの宣言では、JavaScriptのキーワードでなければ任意の識別子が保存されます。</p>
<p>識別子としてJavaScriptの予約語を使う場合は、名前はダブルダラー記号でエスケープされます。たとえば、次のPureScriptコードを考えてみます。</p>
<pre><code class="language-haskell"><span class="hljs-literal">null</span> = []
</code></pre>
<p>これは以下のようなJavaScriptへコンパイルされます。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> $$<span class="hljs-literal">null</span> = [];
</code></pre>
<p>また、識別子に特殊文字を使用したい場合は、単一のドル記号を使用してエスケープされます。たとえば、このPureScriptコードを考えます。</p>
<pre><code class="language-haskell">example' = 100
</code></pre>
<p>これは以下のJavaScriptにコンパイルされます。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> example$prime = <span class="hljs-number">100</span>;
</code></pre>
<p>この方式は、ユーザー定義の中置演算子の名前を生成するためにも使用されます。</p>
<pre><code class="language-haskell">(%) a b = ...
</code></pre>
<p>これは次のようにコンパイルされます。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> $percent = ...
</code></pre>
<p>コンパイルされたPureScriptコードがJavaScriptから呼び出されることを意図している場合、識別子は英数字のみを使用し、JavaScriptの予約語を避けることをお勧めします。ユーザ定義演算子がPureScriptコードでの使用のために提供される場合でも、JavaScriptから使うための英数字の名前を持った代替関数を提供しておくことをお勧めします。</p>
<h2>10.6 実行時のデータ表現</h2>
<p>型はプログラムがある意味で「正しい」ことをコンパイル時に判断できるようにします。つまり、実行時には中断されません。しかし、これは何を意味するのでしょうか？PureScriptでは式の型は実行時の表現と互換性がなければならないことを意味します。</p>
<p>そのため、PureScriptとJavaScriptコードを一緒に効率的に使用できるように、実行時のデータ表現について理解することが重要です。これは、与えられた任意のPureScriptの式について、その値が実行時にどのように評価されるかという挙動を理解できるべきであることを意味しています。</p>
<p>PureScriptの式は、実行時に特に単純な表現を持っているということは朗報です。実際に標準ライブラリのコードについて、その型を考慮すれば式の実行時のデータ表現を把握することが可能です。</p>
<p>単純な型については、対応関係はほとんど自明です。たとえば、式が型 <code>Boolean</code>を持っていれば、実行時のその値 <code>v</code>は <code>typeof v === 'boolean'</code>を満たします。つまり、型 <code>Boolean</code>の式は <code>true</code>もしくは <code>false</code>のどちらか一方の(JavaScriptの)値へと評価されます。実のところ、 <code>null</code>や <code>undefined</code>に評価される、型 <code>Boolean</code>のPureScriptの式はありません。</p>
<p><code>Number</code>と <code>String</code>の型の式についても同様のことが成り立ちます。 <code>Number</code>型の式は <code>null</code>でないJavaScriptの数へと評価されますし、 <code>String</code>型の式は <code>null</code>でないJavaScriptの文字列へと評価されます。</p>
<p>もっと複雑な型についてはどうでしょうか？</p>
<p>すでに見てきたように、PureScriptの関数は引数がひとつのJavaScriptの関数に対応しています。厳密に言えば、任意の型 <code>a</code>、 <code>b</code>について、式 <code>f</code>の型が <code>a -> b</code>で、式 <code>x</code>が型 <code>a</code>についての適切な実行時表現の値へと評価されるなら、 <code>f</code>はJavaScriptの関数へと評価され、 <code>x</code>を評価した結果に <code>f</code>を適用すると、それは型 <code>b</code>の適切な実行時表現を持ちます。簡単な例としては、 <code>String -> String</code>型の式は、 <code>null</code>でないJavaScript文字列から <code>null</code>でないJavaScript文字列への関数へと評価されます。</p>
<p>ご想像のとおり、PureScriptの配列はJavaScriptの配列に対応しています。しかし、PureScriptの配列は均質であり、つまりすべての要素が同じ型を持っていることは覚えておいてください。具体的には、もしPureScriptの式 <code>e</code>が任意の型 <code>a</code>について型 <code>Array a</code>を持っているなら、 <code>e</code>はすべての要素が型 <code>a</code>の適切な実行時表現を持った(<code>null</code>でない)JavaScript配列へと評価されます。</p>
<p>PureScriptのレコードがJavaScriptのオブジェクトへと評価されることはすでに見てきました。ちょうど関数と配列の場合のように、そのラベルに関連付けられている型を考慮すれば、レコードのフィールドのデータの実行時の表現についても推論することができます。もちろん、レコードのそれぞれのフィールドは、同じ型である必要はありません。</p>
<h2>10.7 代数的データ型の実行時表現</h2>
<p>PureScriptコンパイラは、代数的データ型のすべての構築子についてそれぞれ関数を定義し、新たなJavaScriptオブジェクト型を作成します。これらの構築子はこれらのプロトタイプに基づいて新しいJavaScriptオブジェクトを作成する関数に対応しています。</p>
<p>たとえば、次のような単純な代数的データ型を考えてみましょう。</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">ZeroOrOne</span> a = <span class="hljs-type">Zero</span> | <span class="hljs-type">One</span> a</span>
</code></pre>
<p>PureScriptコンパイラは、次のようなコードを生成します。</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">One</span>(<span class="hljs-params">value0</span>) </span>{
    <span class="hljs-keyword">this</span>.value0 = value0;
};

One.create = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value0</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> One(value0);
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Zero</span>(<span class="hljs-params"></span>) </span>{
};

Zero.value = <span class="hljs-keyword">new</span> Zero();
</code></pre>
<p>ここで2つのJavaScriptオブジェクト型 <code>Zero</code>と <code>One</code>を見てください。JavaScriptの予約語 <code>new</code>を使用すると、それぞれの型の値を作成することができます。引数を持つ構築子については、コンパイラは <code>value0</code>、 <code>value1</code>などと呼ばれるフィールドに対応するデータを格納します。</p>
<p>PureScriptコンパイラは補助関数も生成します。引数のない構築子については、コンパイラは構築子が使われるたびに <code>new</code>演算子を使うのではなく、データを再利用できるように <code>value</code>プロパティを生成します。ひとつ以上の引数を持つ構築子では、適切な表現を持つ引数を取り適切な構築子を適用する <code>create</code>関数をコンパイラは生成します。</p>
<p>２引数以上の構築子についてはどうでしょうか？その場合でも、PureScriptコンパイラは新しいオブジェクト型と補助関数を作成します。しかし今回は、補助関数は2引数のカリー化された関数です。たとえば、次のような代数的データ型を考えます。</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Two</span> a b = <span class="hljs-type">Two</span> a b</span>
</code></pre>
<p>このコードからは、次のようなJavaScriptコードを生成されます。</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Two</span>(<span class="hljs-params">value0, value1</span>) </span>{
    <span class="hljs-keyword">this</span>.value0 = value0;
    <span class="hljs-keyword">this</span>.value1 = value1;
};

Two.create = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value0</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value1</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Two(value0, value1);
    };
};
</code></pre>
<p>ここで、オブジェクト型 <code>Two</code>の値は予約語 <code>new</code>または <code>Two.create</code>関数を使用すると作成することができます。</p>
<p>newtypeの場合はまた少し異なります。newtypeは単一の引数を取る単一の構築子を持つよう制限された代数的データ型であることを思い出してください。この場合には、実際はnewtypeの実行時表現は、その引数の型と同じになります。</p>
<p>例えば、電話番号を表す次のようなnewtypeを考えます。</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">newtype</span> <span class="hljs-type">PhoneNumber</span> = <span class="hljs-type">PhoneNumber</span> <span class="hljs-type">String</span></span>
</code></pre>
<p>これは実行時にはJavaScriptの文字列として表されます。newtypeは型安全性の追加の層を提供しますが、実行時の関数呼び出しのオーバーヘッドがないので、ライブラリを設計するのに役に立ちます。</p>
<h2>10.8 量化された型の実行時表現</h2>
<p>量化された型(多相型)の式は、制限された表現を実行時に持っています。実際には、量化された型の式が比較的少数与えられたとき、とても効率的に解決できることを意味しています。</p>
<p>例えば、次の多相型を考えてみます。</p>
<pre><code class="language-haskell"><span class="hljs-title">forall</span> a. a -&gt; a
</code></pre>
<p>この型を持っている関数にはどんなものがあるでしょうか。少なくともひとつはこの型を持つ関数が存在しています。すなわち、 <code>Prelude</code>で定義されている恒等関数 <code>id</code>です。</p>
<pre><code class="language-haskell"><span class="hljs-title">id</span> :: <span class="hljs-keyword">forall</span> a. a -&gt; a
<span class="hljs-title">id</span> a = a
</code></pre>
<p>実のところ、 <code>id</code>の関数はこの型の<strong>唯一の</strong>(全)関数です！これは確かに間違いなさそうに見えますが(この型を持った <code>id</code>とは明らかに異なる式を書こうとしてみてください)、これを確かめるにはどうしたらいいでしょうか。これは型の実行時表現を考えることによって確認することができます。</p>
<p>量化された型 <code>forall a. t</code>の実行時表現はどうなっているのでしょうか。さて、この型の実行時表現を持つ任意の式は、型 <code>a</code>をどのように選んでも型 <code>t</code>の適切な実行時表現を持っていなければなりません。上の例では、型 <code>forall a. a -> a</code>の関数は、 <code>String -> String</code>、 <code>Number -> Number</code>、 <code>Array Boolean -> Array Boolean</code>などといった型について、適切な実行時表現を持っていなければなりません。 これらは、数から数、文字列から文字列の関数でなくてはなりません。</p>
<p>しかし、それだけでは十分ではありません。量化された型の実行時表現は、これよりも更に厳しくなります。任意の式がパラメトリック多相的でなければなりません。つまり、その実装において、引数の型についてのどんな情報も使うことができないのです。この追加の条件は、考えられる多相型のうち、次のようなJavaScriptの関数として問題のある実装を禁止します。</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invalid</span>(<span class="hljs-params">a</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">'string'</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Argument was a string."</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> a;
    }
}
</code></pre>
<p>確かにこの関数は文字列から文字列、数から数へというような関数ではありますが、追加の条件を満たしていません。引数の実行時の型を調べているからです。したがって、この関数は型 <code>forall a. a -> a</code>の正しい実装だとはいえないのです。</p>
<p>関数の引数の実行時の型を検査することができなければ、唯一の選択肢は引数をそのまま返すことだけであり、したがって <code>id</code>は、 <code>forall a. a -> a</code>のまったく唯一の実装なのです。</p>
<p><strong>パラメトリック多相</strong>(parametric polymorphism)と<strong>パラメトリック性</strong>(parametricity)についての詳しい議論は本書の範囲を超えています。しかしながら、PureScriptの型は、実行時に<strong>消去</strong>されているので、PureScriptの多相関数は(FFIを使わない限り)引数の実行時表現を検査することが<strong>できない</strong>し、この多相的なデータの表現は適切であることに注意してください。</p>
<h2>10.9 制約された型の実行時表現</h2>
<p>型クラス制約を持つ関数は、実行時に面白い表現を持っています。関数の振る舞いはコンパイラによって選ばれた型クラスのインスタンスに依存する可能性があるため、関数には選択したインスタンスから提供された型クラスの関数の実装が含まれてた<strong>型クラス辞書</strong>(type class dictionary)と呼ばれる追加の引数が与えられています。</p>
<p>例えば、 <code>Show</code>型クラスを使用している制約された型を持つ、次のような単純なPureScript関数について考えます。</p>
<pre><code class="language-haskell"><span class="hljs-title">shout</span> :: <span class="hljs-keyword">forall</span> a. <span class="hljs-type">Show</span> a =&gt; a -&gt; <span class="hljs-type">String</span>
<span class="hljs-title">shout</span> a = show a &lt;&gt; <span class="hljs-string">"!!!"</span>
</code></pre>
<p>このコードから生成されるJavaScriptは次のようになります。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> shout = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dict</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) </span>{
        <span class="hljs-keyword">return</span> show(dict)(a) + <span class="hljs-string">"!!!"</span>;
    };
};
</code></pre>
<p><code>shout</code>は１引数ではなく、２引数の(カリー化された)関数にコンパイルされていることに注意してください。最初の引数 <code>dict</code>は <code>Show</code>制約の型クラス辞書です。 <code>dict</code>には型 <code>a</code>の <code>show</code>関数の実装が含まれています。</p>
<p>最初の引数として明示的にPreludeの型クラス辞書を渡すと、JavaScriptからこの関数を呼び出すことができます。</p>
<pre><code class="language-javascript">shout(<span class="hljs-built_in">require</span>(<span class="hljs-string">'Prelude'</span>).showNumber)(<span class="hljs-number">42</span>);
</code></pre>
<div class="exercise"><h2>演習</h2><ol>
<li>
<p>(簡単) これらの型の実行時の表現は何でしょうか。</p>
<pre><code class="language-haskell"><span class="hljs-title">forall</span> a. a
<span class="hljs-title">forall</span> a. a -&gt; a -&gt; a
<span class="hljs-title">forall</span> a. <span class="hljs-type">Ord</span> a =&gt; <span class="hljs-type">Array</span> a -&gt; <span class="hljs-type">Boolean</span>
</code></pre>
<p>これらの型を持つ式についてわかることはなんでしょうか。</p>
</li>
<li>
<p>(やや難しい)<code>pulp build</code>を使ってコンパイルし、NodeJSの <code>require</code>関数を使ってモジュールをインポートすることで、JavaScriptから <code>purescript-arrays</code>ライブラリの関数を使ってみてください。<strong>ヒント</strong>：生成されたCommonJSモジュールがNodeJSモジュールのパスで使用できるように、出力パスを設定する必要があります。</p>
</li>
</ol></div>

<h2>10.10 PureScriptからのJavaScriptコードを使う</h2>
<p>PureScriptからJavaScriptコードを使用する最も簡単な方法は、<strong>外部インポート宣言</strong>(foreign import declaration)を使用し、既存のJavaScriptの値に型を与えることです。外部インポート宣言では、対応するJavaScriptの宣言を<strong>外部JavaScriptモジュール</strong>(foreign JavaScript module)に持つ必要があります。</p>
<p>たとえば、特殊文字をエスケープすることによりURIのコンポーネントを符号化するJavaScriptの <code>encodeURIComponent</code>関数について考えてみます。</p>
<pre><code class="language-text">$ node

node> encodeURIComponent('Hello World')
'Hello%20World'
</code></pre>
<p><code>null</code>でない文字列から <code>null</code>でない文字列への関数であり、副作用を持っていないので、この関数はその型 <code>String -> String</code>について適切な実行時表現を持っています。</p>
<p>次のような外部インポート宣言を使うと、この関数に型を割り当てることができます。</p>
<pre><code class="language-haskell"><span class="hljs-keyword">module</span> Data.URI <span class="hljs-keyword">where</span>

<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> encodeURIComponent :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">String</span>
</code></pre>
<p>また、外部JavaScriptモジュールを書く必要があります。上記のモジュールを<code>src/Data/URI.purs</code>として保存した場合、次のような外部JavaScriptモジュールを<code>src/Data/URI.js</code>として保存します。</p>
<pre><code class="language-javascript"><span class="hljs-meta">"use strict"</span>;

exports.encodeURIComponent = <span class="hljs-built_in">encodeURIComponent</span>;
</code></pre>
<p>Pulpは<code>src</code>ディレクトリにある<code>.js</code>ファイルを見つけ、それを外部JavaScriptモジュールとしてコンパイラに提供します。</p>
<p>JavaScriptの関数と値は、通常のCommonJSモジュールと同じように<code>exports</code>オブジェクトに代入することで、外部JavaScriptモジュールからエクスポートされます。<code>purs</code>コンパイラは、このモジュールを通常のCommonJSモジュールのように扱い、コンパイルされたPureScriptモジュールへの依存関係として追加します。しかし、<code>psc-bundle</code>や<code>pulp build -O --to</code>を使ってブラウザ向けのコードをバンドルするときは、上記のパターンに従い、プロパティ代入を使って<code>exports</code>オブジェクトにエクスポートする値を代入することがとても重要です。 これは、<code>psc-bundle</code>がこの形式を認識し、未使用のJavaScriptのエクスポートをバンドルされたコードから削除できるようにするためです。</p>
<p>これら2つの部品を使うことで、PureScriptで書かれた関数のように、PureScriptから<code>encodeURIComponent</code>関数を使うことができます。たとえば、この宣言をモジュールとして保存してPSCiにロードすると、上記の計算を再現できます。</p>
<pre><code class="language-text">$ pulp repl

> import Data.URI
> encodeURIComponent "Hello World"
"Hello%20World"
</code></pre>
<p>この手法は簡単なJav​​aScriptの値には適していますが、もっと複雑な値に使うには限界があります。ほとんどの既存のJavaScriptコードは、基本的なPureScriptの型の実行時表現によって課せられた厳しい条件を満たしていないからです。このような場合のためには、適切な実行時表現に従うことを強制するようにJavaScriptコードを<strong>ラップする</strong>という別の方法があります。</p>
<h2>10.11 JavaScriptの値のラッピング</h2>
<p>これはPureScriptの型を与えるためにJavaScriptコードの既存の部分をラップする場合に特に便利です。このようにしたくなる理由はいくつかあります。</p>
<ul>
<li>関数が複数の引数を取るが、カリー化した関数と同じように呼び出したい。</li>
<li>任意のJavaScriptの副作用を追跡するために、 <code>Eff</code>モナドを使うことができます。</li>
<li>関数の適切な実行時表現を与えるために、 <code>null</code>や <code>undefined</code>のような特殊な場合を処理するために必要な場合があります。</li>
</ul>
<p>外部インポート宣言を使用して、配列についての <code>head</code>関数を作成したいとしましょう。JavaScriptでは次のような関数になるでしょう。</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">head</span>(<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>];
}
</code></pre>
<p>しかし、この関数には問題があります。型 <code>forall a. Array a -> a</code>を与えようとしても、空の配列に対してこの関数は <code>undefined</code>を返します。したがって、この特殊な場合を処理するために、ラッパー関数を使用する必要があります。</p>
<p>簡単な方法としては、空の配列の場合に例外を投げる方法があります。厳密に言えば、純粋な関数は例外を投げるべきではありませんが、デモンストレーションの目的ではこれで十分ですし、安全性でないということを関数名で示しておけばいいでしょう。</p>
<pre><code class="language-haskell"><span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> unsafeHead :: forall a. <span class="hljs-type">Array</span> a -&gt; a
</code></pre>
<p>JavaScriptモジュールでは、 <code>unsafeHead</code>を以下のように定義することができます。</p>
<pre><code class="language-haskell">exports.unsafeHead = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-keyword">if</span> (arr.length) {
    <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>];
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'unsafeHead: empty array'</span>);
  }
};
</code></pre>
<h2>10.12 外部型の定義</h2>
<p>失敗した場合に例外を投げるという方法は、あまり理想的とはいえません。PureScriptのコードでは、欠けた値のような副作用は型システムを使って扱うのが普通です。この手法としては <code>Maybe</code>型構築子を使う方法もありますが、この節ではFFIを使用した別の解決策を扱います。</p>
<p>実行時には型 <code>a</code>のように表現されますが <code>undefined</code>の値も許容するような新しい型 <code>Undefined a</code>を定義したいとしましょう。</p>
<p><strong>外部インポート宣言</strong>とFFIを使うと、<strong>外部型</strong>(foreign type)を定義することができます。構文は外部関数を定義するのと似ています。</p>
<pre><code class="language-haskell"><span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> data <span class="hljs-type">Undefined</span> :: <span class="hljs-type">Type</span> -&gt; <span class="hljs-type">Type</span>
</code></pre>
<p>この予約語 <code>data</code>は値ではなく定義している型を表していることに注意してください。型シグネチャの代わりに、新しい型の<strong>種</strong>を与えます。このとき、種 <code>Undefined</code>が <code>Type -> Type</code>であると宣言しています。つまり <code>Undefined</code>は型構築子です。</p>
<p>これで <code>head</code>の定義を簡素化することができます。</p>
<pre><code class="language-haskell">exports.head = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>];
};
</code></pre>
<p>PureScriptモジュールには以下を追加します。</p>
<pre><code class="language-haskell"><span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> head :: forall a. <span class="hljs-type">Array</span> a -&gt; <span class="hljs-type">Undefined</span> a
</code></pre>
<p>2点変更がある注意してください。 <code>head</code>関数の本体ははるかに簡単で、もしその値が未定義であったとしても <code>arr[0]</code>を返し、型シグネチャはこの関数が未定義の値を返すことがあるという事実を反映するよう変更されています。</p>
<p>この関数はその型の適切な実行時表現を持っていますが、型 <code>Undefined a</code>の値を使用する方法がありませんので、まったく役に立ちません。しかし、FFIを使用して新しい関数を幾つか書くことによって、それを修正することができます！</p>
<p>次の関数は、値が定義されているかどうかを教えてくれる最も基本的な関数です。</p>
<pre><code class="language-haskell"><span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> isUndefined :: forall a. <span class="hljs-type">Undefined</span> a -&gt; <span class="hljs-type">Boolean</span>
</code></pre>
<p>JavaScriptモジュールで次のように簡単に定義できます。</p>
<pre><code class="language-javascript">exports.isUndefined = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
  <span class="hljs-keyword">return</span> value === <span class="hljs-literal">undefined</span>;
};
</code></pre>
<p>PureScriptから <code>isUndefined</code>と <code>head</code>を一緒に使用すると、便利な関数を定義することができます。</p>
<pre><code class="language-haskell"><span class="hljs-title">isEmpty</span> :: <span class="hljs-keyword">forall</span> a. <span class="hljs-type">Array</span> a -&gt; <span class="hljs-type">Boolean</span>
<span class="hljs-title">isEmpty</span> = isUndefined &lt;&lt;&lt; head
</code></pre>
<p>ここで、定義されたこの外部関数はとても簡単であり、PureScriptの型検査器を使うことによる利益をなるべく多く得るということを意味します。一般に外部関数は可能な限り小さく保ち、アプリケーションの処理はPureScriptコードへ移動しておくことをおすすめします。</p>
<h2>10.13 多変数​関数</h2>
<p>PureScriptのPreludeには、興味深い外部型がいくつかも含まれています。すでに扱ってきたように、PureScriptの関数型は単一の引数だけを取りますが、<strong>カリー化</strong>(Currying)を使うと複数の引数の関数をシミュレートすることができます。これには明らかな利点があります。関数を部分適用することができ、関数型の型クラスインスタンスを与えることができます。ただし、効率上のペナルティが生じます。パフォーマンス重視するコードでは、複数の引数を受け入れる本物のJavaScript関数を定義することが必要な場合があります。Preludeではそのような関数を安全に扱うことができるようにする外部型が定義されています。</p>
<p>たとえば、Preludeの <code>Data.Function.Uncurried</code>モジュールには次の外部型宣言があります。</p>
<pre><code class="language-haskell"><span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> data <span class="hljs-type">Fn2</span> :: <span class="hljs-type">Type</span> -&gt; <span class="hljs-type">Type</span> -&gt; <span class="hljs-type">Type</span> -&gt; <span class="hljs-type">Type</span>
</code></pre>
<p>これは3つの型引数を取る型構築子 <code>Fn2</code>を定義します。 <code>Fn2 a b c</code>は、型 <code>a</code>と <code>b</code>の２つの引数、返り値の型 <code>c</code>をもつJavaScript関数の型を表現しています。</p>
<p>Preludeでは0引数から10引数までの関数について同様の型構築子が定義されています。</p>
<p>次のように <code>mkFn2</code>関数を使うと、2引数の関数を作成することができます。</p>
<pre><code class="language-haskell"><span class="hljs-keyword">import</span> Data.Function.Uncurried

<span class="hljs-title">divides</span> :: <span class="hljs-type">Fn2</span> <span class="hljs-type">Int</span> <span class="hljs-type">Int</span> <span class="hljs-type">Boolean</span>
<span class="hljs-title">divides</span> = mkFn2 \n m -&gt; m % n == <span class="hljs-number">0</span>
</code></pre>
<p>そして、 <code>runFn2</code>関数を使うと、2引数の関数を適用することができます。</p>
<pre><code class="language-haskell">&gt; runFn2 divides <span class="hljs-number">2</span> <span class="hljs-number">10</span>
<span class="hljs-literal">true</span>

&gt; runFn2 divides <span class="hljs-number">3</span> <span class="hljs-number">10</span>
<span class="hljs-literal">false</span>
</code></pre>
<p>ここで重要なのは、引数がすべて適用されるなら、コンパイラは <code>mkFn2</code>関数や <code>runFn2</code>関数を<strong>インライン化</strong>するということです。そのため、生成されるコードはとてもコンパクトになります。</p>
<pre><code class="language-javascript">exports.divides = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n, m</span>) </span>{
    <span class="hljs-keyword">return</span> m % n === <span class="hljs-number">0</span>;
};
</code></pre>
<h2>10.14 副作用の表現</h2>
<p><code>Eff</code>モナドもPreludeの外部型として定義されています。その実行時表現はとても簡単です。型 <code>Eff eff a</code>の式は、任意の副作用を実行し型 <code>a</code>の適切な実行時表現で値を返す、引数なしのJavaScript関数へと評価されます。</p>
<p><code>Eff</code>型の構築子の定義は、 <code>Control.Monad.Eff</code>モジュールで次のように与えられています。</p>
<pre><code class="language-haskell"><span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> data <span class="hljs-type">Eff</span> :: # <span class="hljs-type">Effect</span> -&gt; <span class="hljs-type">Type</span> -&gt; <span class="hljs-type">Type</span>
</code></pre>
<p><code>Eff</code>型の構築子は作用の行と返り値の型によってパラメータ化されおり、それが種に反映されることを思い出してください。</p>
<p>簡単な例として、 <code>purescript-random</code>パッケージで定義される <code>random</code>関数を考えてみてください。その型は次のようなものでした。</p>
<pre><code class="language-haskell"><span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> random :: forall eff. <span class="hljs-type">Eff</span> (random :: <span class="hljs-type">RANDOM</span> | eff) <span class="hljs-type">Number</span>
</code></pre>
<p><code>random</code>関数の定義は次のように与えられます。</p>
<pre><code class="language-javascript">exports.random = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random();
};
</code></pre>
<p><code>random</code>関数は実行時には引数なしの関数として表現されていることに注目してください。これは乱数生成という副作用を実行しそれを返しますが、返り値は <code>Number</code>型の実行時表現と一致します。それは <code>null</code>でないJavaScriptの数です。</p>
<p>もう少し興味深い例として、 Preludeの <code>Control.Monad.Eff.Console</code>モジュールで定義された <code>log</code>関数を考えてみましょう。 <code>log</code>関数は次の型を持っています。</p>
<pre><code class="language-haskell"><span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> log :: forall eff. <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Eff</span> (console :: <span class="hljs-type">CONSOLE</span> | eff) <span class="hljs-type">Unit</span>
</code></pre>
<p>この定義は次のようになっています。</p>
<pre><code class="language-javascript">exports.log = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(s);
  };
};
</code></pre>
<p>実行時の <code>log</code>の表現は、引数なしの関数を返す、単一の引数のJavaScript関数です。内側の関数はコンソールにメッセージを書き込むという副作用を実行し、空のレコードを返します。 <code>Unit</code>は空のレコード型のnewtypeとしてPreludeで定義されているので、内側の関数の戻り値の型は <code>Unit</code>型の実行時表現と一致していることに注意してください。</p>
<p>作用 <code>RANDOM</code>と <code>CONSOLE</code>も外部型として定義されています。その種は <code>!</code>、つまり作用であると定義されています。例えば次のようになります。</p>
<pre><code class="language-haskell"><span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> data <span class="hljs-type">RANDOM</span> :: <span class="hljs-type">Effect</span>
</code></pre>
<p>詳しくはあとで見ていきますが、このように新たな作用を定義することが可能なのです。</p>
<p><code>Eff eff a</code>型の式は、通常のJavaScriptのメソッドのようにJavaScriptから呼び出すことができます。例えば、この <code>main</code>関数は作用の集合 <code>eff</code>と何らかの型 <code>a</code>について <code>Eff eff a</code>という型でなければならないので、次のように実行することができます。</p>
<pre><code class="language-javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">'Main'</span>).main();
</code></pre>
<p><code>pulp build -O --to</code>または <code>pulp run</code>を使用するときは、 <code>main</code>モジュールが定義されていると、この <code>main</code>の呼び出しを自動的に生成することができます。</p>
<h2>10.15 新しい作用の定義</h2>
<p>この章のソースコードでは、2つの新しい作用が定義されています。最も簡単なのは <code>Control.Monad.Eff.Alert</code>モジュールで定義された <code>ALERT</code>作用です。これはその計算がポップアップウィンドウを使用してユーザに警告しうることを示すために使われます。</p>
<p>この作用は最初に外部型宣言を使用して定義されています。</p>
<pre><code class="language-haskell"><span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> data <span class="hljs-type">ALERT</span> :: <span class="hljs-type">Effect</span>
</code></pre>
<p><code>Alert</code>は種 <code>Effect</code>が与えられており、 <code>Alert</code>が型ではなく作用であることを示しています。</p>
<p>次に、 <code>alert</code>アクションが定義されています。 <code>alert</code>アクションはポップアップを表示し、作用の行に <code>Alert</code>作用を追加します。</p>
<pre><code class="language-haskell"><span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> alert :: forall eff. <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Eff</span> (alert :: <span class="hljs-type">ALERT</span> | eff) <span class="hljs-type">Unit</span>
</code></pre>
<p>JavaScriptモジュールは簡単で、 <code>alert</code>関数を <code>exports</code>変数に代入して定義します。</p>
<pre><code class="language-javascript"><span class="hljs-meta">"use strict"</span>;

exports.alert = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">window</span>.alert(msg);
    };
};

</code></pre>
<p>このアクションは <code>Control.Monad.Eff.Console</code>モジュールの <code>log</code>アクションととてもよく似ています。唯一の違いは、 <code>log</code>アクションが <code>console.log</code>メソッドを使用しているのに対し、 <code>alert</code>アクションは <code>window.alert</code>メソッドを使用していることです。このように、 <code>alert</code>は <code>window.alert</code>が定義されているウェブブラウザのような環境で使用することができます。</p>
<p><code>log</code>の場合のように、 <code>alert</code>関数は型 <code>Eff (alert :: ALERT | eff) Unit</code>の計算を表現するために引数なしの関数を使っていることに注意してください。</p>
<p>この章で定義される２つめの作用は、 <code>Control.Monad.Eff.Storage</code>モジュールで定義されている <code>STORAGE</code>作用です。これは計算がWeb Storage APIを使用して値を読み書きする可能性があることを示すために使われます。</p>
<p>この作用も同じように定義されています。</p>
<pre><code class="language-haskell"><span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> data <span class="hljs-type">STORAGE</span> :: <span class="hljs-type">Effect</span>
</code></pre>
<p><code>Control.Monad.Eff.Storage</code>モジュールには、ローカルストレージから値を取得する <code>getItem</code>と、ローカルストレージに値を挿入したり値を更新する <code>setItem</code>という、２つのアクションが定義されています。この二つの関数は、次のような型を持っています。</p>
<pre><code class="language-haskell"><span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> getItem :: forall eff . <span class="hljs-type">String</span>
  -&gt; <span class="hljs-type">Eff</span> (storage :: <span class="hljs-type">STORAGE</span> | eff) <span class="hljs-type">Foreign</span>
<span class="hljs-keyword">foreign</span> <span class="hljs-keyword">import</span> setItem :: forall eff . <span class="hljs-type">String</span>
  -&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">Eff</span> (storage :: <span class="hljs-type">STORAGE</span> | eff) <span class="hljs-type">Unit</span>
</code></pre>
<p>興味のある読者は、このモジュールのソースコードでこれらのアクションがどのように定義されているか調べてみてください。</p>
<p><code>setItem</code>はキーと値(両方とも文字列)を受け取り、指定されたキーでローカルストレージに値を格納する計算を返します。</p>
<p><code>getItem</code>の型はもっと興味深いものです。 <code>getItem</code>はキーを引数に取り、キーに関連付けられた値をローカルストレージから取得しようとします。 <code>window.localStorage</code>の <code>getItem</code>メソッドは <code>null</code>を返すことがあるので、返り値は <code>String</code>ではなく、 <code>purescript-foreign</code>パッケージの <code>Data.Foreign</code>モジュールで定義されている <code>Foreign</code>になっています。</p>
<p><code>Data.Foreign</code>は、<strong>型付けされていないデータ</strong>、もっと一般的にいえば実行時表現が不明なデータを扱う方法を提供しています。</p>
<div class="exercise"><h2>演習</h2><ol>
<li>
<p>(やや難しい) JavaScriptの <code>Window</code>オブジェクトの <code>confirm</code>メソッドのラッパを書き、 <code>Control.Monad.Eff.Alert</code>モジュールにその関数を追加してください。</p>
</li>
<li>
<p>(やや難しい)<code>localStorage</code>オブジェクトの <code>removeItem</code>メソッドのラッパを書き、 <code>Control.Monad.Eff.Storage</code>モジュールに追加してください</p>
</li>
</ol></div>

<h2>10.16 型付けされていないデータの操作</h2>
<p>この節では、型付けされていないデータを、その型の適切な実行時表現を持った型付けされたデータに変換する、 <code>Data.Foreign</code>ライブラリの使い方について見て行きます。</p>
<p>この章のコードは、第8章の住所録の上にフォームの一番下に保存ボタンを追加することで作っていきます。保存ボタンがクリックされると、フォームの状態をJSONに直列化し、ローカルストレージに格納します。ページが再読み込みされると、JSON文書がローカルストレージから取得され、構文解析されます。</p>
<p><code>Main</code>モジュールではフォームデータの型を定義します。</p>
<pre><code class="language-haskell">newtype FormData = FormData
  { <span class="hljs-attr">firstName</span>  :: <span class="hljs-built_in">String</span>
  , <span class="hljs-attr">lastName</span>   :: <span class="hljs-built_in">String</span>
  , <span class="hljs-attr">street</span>     :: <span class="hljs-built_in">String</span>
  , <span class="hljs-attr">city</span>       :: <span class="hljs-built_in">String</span>
  , <span class="hljs-attr">state</span>      :: <span class="hljs-built_in">String</span>
  , <span class="hljs-attr">homePhone</span>  :: <span class="hljs-built_in">String</span>
  , <span class="hljs-attr">cellPhone</span>  :: <span class="hljs-built_in">String</span>
  }
</code></pre>
<p>問題は、このJSONが正しい形式を持っているという保証がないことです。別の言い方をすれば、JSONが実行時にデータの正しい型を表しているかはわかりません。この問題は <code>purescript-foreign</code>ライブラリによって解決することができます。他にも次のような使いかたがあります。</p>
<ul>
<li>WebサービスからJSONレスポンス</li>
<li>JavaScriptコードから関数に渡された値</li>
</ul>
<p>それでは、 <code>PSCi</code>で <code>purescript-foreign</code>及び <code>purescript-foreign-generic</code>ライブラリを試してみましょう。</p>
<p>二つのモジュールをインポートして起動します。</p>
<pre><code class="language-text">> import Data.Foreign
> import Data.Foreign.Generic
> import Data.Foreign.JSON
</code></pre>
<p><code>Foreign</code>な値を取得するためには、JSON文書を解析するのがいいでしょう。 <code>purescript-foreign</code>では次の2つの関数が定義されています。</p>
<pre><code class="language-haskell"><span class="hljs-title">parseJSON</span> :: <span class="hljs-type">String</span> -&gt; <span class="hljs-type">F</span> <span class="hljs-type">Foreign</span>
<span class="hljs-title">decodeJSON</span> :: <span class="hljs-keyword">forall</span> a. <span class="hljs-type">Decode</span> a =&gt; <span class="hljs-type">String</span> -&gt; <span class="hljs-type">F</span> a
</code></pre>
<p>型構築子<code>F</code>は、実際には<code>Data.Foreign</code>で定義されている型同義語です。</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">F</span> = <span class="hljs-type">Except</span> (<span class="hljs-type">NonEmptyList</span> <span class="hljs-type">ForeignError</span>)</span>
</code></pre>
<p>ここで<code>Except</code>は、<code>Either</code>のように、純粋なコードで例外を処理するためのモナドです。<code>runExcept</code>関数を使うと、<code>F</code>モナドの値を<code>Either</code>モナドの値に変換することができます。</p>
<p>この <code>Decode</code>型クラスは、それらの型が型付けされていないデータから得られることを表しています。プリミティブ型や配列については型クラスインスタンスがすでに定義されていますが、独自のインスタンスを定義することもできます。</p>
<p>それでは <code>PSCi</code>で <code>readJSON</code>を使用していくつかの簡単なJSON文書を解析してみましょう。</p>
<pre><code class="language-text">> import Control.Monad.Except

> runExcept (decodeJSON "\"Testing\"" :: F String)
Right "Testing"

> runExcept (decodeJSON "true" :: F Boolean)
Right true

> runExcept (decodeJSON "[1, 2, 3]" :: F (Array Int))
Right [1, 2, 3]
</code></pre>
<p><code>Either</code>モナドでは <code>Right</code>データ構築子は成功を示していることを思い出してください。しかし、その不正なJSONや誤った型はエラーを引き起こすことに注意してください。</p>
<pre><code class="language-text">> runExcept (decodeJSON "[1, 2, true]" :: F (Array Int))
(Left (NonEmptyList (NonEmpty (ErrorAtIndex 2 (TypeMismatch "Int" "Boolean")) Nil)))
</code></pre>
<p><code>purescript-foreign-generic</code>ライブラリはJSON文書で型エラーが発生した位置を教えてくれます。</p>
<h2>10.17 nullとundefined値の取り扱い</h2>
<p>実世界のJSON文書にはnullやundefined値が含まれているので、それらも扱えるようにしなければなりません。</p>
<p><code>purescript-foreign-generic</code>では、この問題を解決する3種類の構築子、 <code>Null</code>、 <code>Undefined</code>、 <code>NullOrUndefined</code>が定義されています。先に定義した <code>Undefined</code>型の構築子と似た目的を持っていますが、省略可能な値を表すために <code>Maybe</code>型の構築子を内部的に使っています。</p>
<p>それぞれの型の構築子について、ラップされた値から内側の値を取り出す関数、 <code>runNullOrUndefined</code>が提供されています。 <code>null</code>値を許容するJSON文書を解析するには、 <code>readJSON</code>アクションまで対応する適切な関数を持ち上げます。</p>
<pre><code class="language-text">> import Prelude
> import Data.Foreign.NullOrUndefined

> runExcept (unNullOrUndefined <$> decodeJSON "42" :: F (NullOrUndefined Int))
(Right (Just 42))

> runExcept (unNullOrUndefined <$> decodeJSON "null" :: F (NullOrUndefined Int))
(Right Nothing)
</code></pre>
<p>それぞれの場合で、型注釈が <code><$></code>演算子の右辺に適用されています。たとえば、 <code>readJSON "42"</code>は型 <code>F (NullOrUndefined Int)</code>を持っています。 <code>unNullOrUndefined</code>関数は最終的な型 <code>F (Maybe Number)</code>与えるために <code>F</code>まで持ち上げられます。</p>
<p>型 <code>NullOrUndefined Int</code>は数またはnullいずれかの値を表しています。各要素が <code>null</code>をかもしれない数値の配列のように、より興味深いの値を解析したい場合はどうでしょうか。その場合には、次のように <code>readJSON</code>アクションまで関数 <code>map unNullOrUndefined</code>を持ち上げます。</p>
<pre><code class="language-text">> runExcept (map unNullOrUndefined <$> decodeJSON "[1, 2, null]"
    :: F (Array (NullOrUndefined Int))) (Right [(Just 1),(Just 2),Nothing])
</code></pre>
<p>一般的には、同じ型に異なる直列化戦略を提供するには、newtypesを使って既存の型をラップするのがいいでしょう。 <code>NullOrUndefined</code>それぞれの型は、 <code>Maybe</code>型構築子に包まれたnewtypeとして定義されています。</p>
<h2>10.18 住所録の項目の直列化</h2>
<p>実のところ、<code>purescript-foreign-generic</code>クラスは<strong>datatype-generic programming</strong>という技術を使ってインスタンスの<strong>自動導出</strong>(derive)することが可能なので、<code>Decode</code>クラスのインスタンスを自分で書く必要はほとんどありません。このテクニックの完全な説明は本書の範囲を超えていますが、関数を一度記述すれば、型自体の構造に基づいてさまざまなデータ型に再利用することができます。</p>
<p><code>FormData</code>型の <code>Decode</code>インスタンスを派生させるためには、まず <code>derive</code>キーワードを使って <code>Generic</code>型クラスのインスタンスを派生させます。</p>
<pre><code class="language-haskell"><span class="hljs-title">derive</span> <span class="hljs-keyword">instance</span> genericFormData :: <span class="hljs-type">Generic</span> <span class="hljs-type">FormData</span> _
</code></pre>
<p>そして、<code>genericDecode</code>関数を使って、次のように<code>decode</code>関数を定義します。</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> decodeFormData :: <span class="hljs-type">Decode</span> <span class="hljs-type">FormData</span> <span class="hljs-keyword">where</span></span>
  decode = genericDecode (defaultOptions { unwrapSingleConstructors = true })
</code></pre>
<p>実際、同じ方法で <code>encoder</code>を導出することもできます。</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">instance</span> encodeFormData :: <span class="hljs-type">Encode</span> <span class="hljs-type">FormData</span> <span class="hljs-keyword">where</span></span>
  encode = genericEncode (defaultOptions { unwrapSingleConstructors = true })
</code></pre>
<p>デコーダとエンコーダで同じオプションを使用することが重要です。そうしないと、エンコードされたJSONドキュメントが正しくデコードされないことがあります。</p>
<p>保存ボタンをクリックすると、JSON文書への直列化を行う<code>encode</code>関数に<code>FormData</code>型の値が渡されます。<code>FormData</code>型はレコードのnewtypeで、<code>encode</code>が渡された<code>FormData</code>型の値はJSON<strong>オブジェクト</strong>として直列化されます。これは、JSONエンコーダを定義する際に<code>unwrapSingleConstructors</code>オプションを指定したためです。</p>
<p>この<code>Decode</code>型クラスのインスタンスは、<code>decodeJSON</code>とともにローカル·ストレージから取得したJSON文書を解析するために次のように使われています。</p>
<pre><code class="language-haskell"><span class="hljs-title">loadSavedData</span> = <span class="hljs-keyword">do</span>
  item &lt;- getItem <span class="hljs-string">"person"</span>

  <span class="hljs-keyword">let</span>
    savedData :: <span class="hljs-type">Either</span> (<span class="hljs-type">NonEmptyList</span> <span class="hljs-type">ForeignError</span>) (<span class="hljs-type">Maybe</span> <span class="hljs-type">FormData</span>)
    savedData = runExcept <span class="hljs-keyword">do</span>
      jsonOrNull &lt;- traverse readString =&lt;&lt; readNullOrUndefined item
      traverse decodeJSON jsonOrNull
</code></pre>
<p><code>savedData</code>アクションは２つの手順にわけて <code>FormData</code>構造を読み取ります。まず、 <code>getItem</code>から得た <code>Foreign</code>値を解析します。 <code>jsonOrNull</code>の型はコンパイラによって <code>Null String</code>だと推論されます(読者への演習：　この型はどのように推論されているのでしょうか？)。 <code>traverse</code>関数は <code>readJSON</code>を <code>Maybe.String</code>型の結果の(不足しているかもしれない)要素へと適用するのに使われます。 <code>readJSON</code>について推論される型クラスのインスタンスはちょうどさっき書いたもので、型 <code>F (Maybe FormData)</code>の値で結果を返します。</p>
<p><code>traverse</code>の引数には <code>read</code>が最初の行で得た結果 <code>jsonOrNull</code>を使っているので、 <code>F</code>のモナド構造を使う必要があります。</p>
<p>結果の <code>FormData</code>には3つの可能性があります。</p>
<ul>
<li>もし外側の構築子が <code>Left</code>なら、JSON文字列の解析中にエラーがあったか、それが間違った型の値を表しています。この場合、アプリケーションは先ほど書いた <code>alert</code>アクションを使用してエラーを表示します。</li>
<li>もし外側の構築子が <code>Right</code>で内側の構築子が <code>Nothing</code>なら、 <code>getItem</code>が <code>Nothing</code>を返しており、キーがローカルストレージに存在していなかったことを意味しています。この場合、アプリケーションは静かに実行を継続します。</li>
<li>最後に、 <code>Right (Just _)</code>に適合した値はJSON文書としてただしく構文解析されたことを示しています。この場合、アプリケーションは適切な値でフォームフィールドを更新します。</li>
</ul>
<p><code>pulp build -O --to dist/Main.js</code>を実行してコードを試してから、ブラウザで <code>html/index.html</code>を開いてください。 保存ボタンをクリックするとフォームフィールドの内容をローカルストレージへ保存することができ、ページを再読込するとフィールドが再現されるはずです。</p>
<p><strong>注意</strong>：ブラウザ特有の問題を避けるために、ローカルなHTTPサーバからHTMLファイルとJavaScriptファイルを提供する必要があるかもしれません。</p>
<div class="exercise"><h2>演習</h2><ol>
<li>
<p>(簡単)<code>decodeJSON</code>を使って、 <code>[[1, 2, 3], [4, 5], [6]]</code>のようなJavaScriptの数の２次元配列を表現するJSON文書を解析してください。要素をnullにすることが許容されている場合はどうでしょうか。配列自体をnullにすることが許容されている場合はどうなりますか。</p>
</li>
<li>
<p>(やや難しい)<code>savedData</code>の実装の型を検証し、計算のそれぞれの部分式の推論された型を書き出してみましょう。</p>
</li>
<li>
<p>(難しい)次のデータ型は、葉で値を持つ二分木を表しています。</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Tree</span> a = <span class="hljs-type">Leaf</span> a | <span class="hljs-type">Branch</span> (<span class="hljs-type">Tree</span> <span class="hljs-title">a</span>) (<span class="hljs-type">Tree</span> <span class="hljs-title">a</span>)</span>
</code></pre>
<p><code>purescript-foreign-generic</code>を使ってこのタイプの <code>Encode</code>と <code>Decode</code>インスタンスを導き、エンコードされた値がPSCiで正しくデコードできることを確認してください。</p>
</li>
<li>
<p>(難しい) 次の<code>data</code>型は、整数か文字列のどちらかであるJSONを直接表現しています。</p>
<pre><code class="language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">IntOrString</span></span>
  = <span class="hljs-type">IntOrString_Int</span> <span class="hljs-type">Int</span>
  | <span class="hljs-type">IntOrString_String</span> <span class="hljs-type">String</span>
</code></pre>
<p>この動作を実装する <code>IntOrString</code>データ型の <code>Encode</code>と <code>Decode</code>のインスタンスを記述し、エンコードされた値が <code>PSCi</code>で正しくデコードできることを確認してください。</p>
</li>
</ol></div>

<h2>まとめ</h2>
<p>この章では、PureScriptから外部のJavaScriptコードを扱う方法、およびその逆の方法を学びました。また、FFIを使用して信頼できるコードを書く時に生じる問題について見てきました。</p>
<ul>
<li>データの<strong>実行時表現</strong>の重要性を見て、外部関数が正しい表現を持っていることを確かめました。</li>
<li>外部型、つまり <code>Foreign</code>データ型を使用することによって、null値のような特殊な場合やJavaScriptの他の型のデータに対処する方法を学びました。</li>
<li>Preludeで定義されたいくつかの共通の外部型、既存のJavaScriptコードとどのように相互運用に使用するかを見てきました。特に、 <code>Eff</code>モナドにおける副作用の表現を導入し、新たな副作用を追跡するために <code>Eff</code>モナドを使用する方法を説明しました。</li>
<li><code>IsForeign</code>型クラスを使用して安全にJSONデータを復元する方法を説明しました。</li>
</ul>
<p>その他の例については、Githubの <code>purescript</code>組織、<code>purescript-contrib</code>組織および <code>purescript-node</code>組織が、FFIを使用するライブラリの例を多数提供しています。残りの章では、型安全な方法で現実世界の問題を解決するために使うライブラリを幾つか見ていきます。</p>


<a href="chapter11.html"><div class="next">次の第11章を読む</div></a>
<p class="home"><a href="index.html">目次に戻る</a></p>
</div>
  </div>


</body></html>