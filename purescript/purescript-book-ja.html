<!DOCTYPE html>
<meta charset="UTF-8">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>実例によるPureScript</title>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="icon" type="image/png" href="favicon-96x96.png" sizes="96x96">
  <link rel="stylesheet" href="github-markdown.css" type="text/css"/>
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Roboto"/>
  <style>
    body {
      background-color: #f5f5f5;
    }

    div.main {
        min-width: 540px;
        max-width: 980px;
        margin: 0 auto;
        
        background-color: white;
        border: solid 1px #cbcbcb;
        box-shadow: 0 0 15px rgba(0,0,0,0.1);

        font-family: 'Roboto', 'Meiryo UI', sans-serif !important;
    }

    div.header img.logo:hover {
      background-color: rgba(255, 255, 255, 0.3);
    }

    div.header {
      background-color: #1d222d;
      color: white;
      padding: 50px;
    }

    div.header a {
      color: white;
      text-decoration: none;
    }

    div.header a:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }

    div.header h1 {
      letter-spacing: 0.2em;
      border-bottom: solid 1px rgba(255, 255, 255, 0.4);
      padding: 0.4em;
    }

    div.header p.author {
      font-family: 'Roboto', sans-serif;
    }

    div.content {
        padding: 30px;

        font-family: 'Roboto', 'Meiryo UI', sans-serif !important;
    }

    div.content a {
      color: #c4953a;
      text-decoration: none;
    }



    .main ol {
        list-style-type: decimal;
    }
    .main ol ol {
        list-style-type: decimal;
    }
    .main ol ol ol {
        list-style-type: decimal;
    }

    .main blockquote {
      color: #333;
    }

    .markdown code {
      white-space: pre;
      word-wrap: keep-all !important;  
    }

    /* Bug Workaround for Readium */
    .main h1, h2, h3, h4, h5, h6 {
      position: static !important;
      font-family: serif;
      font-weight: bold;
      letter-spacing: 0.12em;
    }

    .columns2 {
      -webkit-column-count: 2; /* Chrome, Safari, Opera */
      -moz-column-count: 2; /* Firefox */
      column-count: 2;
    }

    .columns3 {
      -webkit-column-count: 3; /* Chrome, Safari, Opera */
      -moz-column-count: 3; /* Firefox */
      column-count: 3;
    }    

    table.sourceCode tr {
      padding: 0;
      border: none;
    }

    table.sourceCode td {
      padding: 0;
      border: none;
    }

    table.sourceCode pre {
      margin: 0;
      border: none;
    }

    @media print {
      body {
        background-color: transparent;
      }

      .previous {
        visibility: hidden;
      }

      .main {
        font-family: 'MS PMincho', Serif;
        text-justify: inter-cluster;

        background-color: transparent;
        border: none 0px transparent;
        box-shadow: none;
      }
      .main h1, h2, h3, h4, h5, h6 {
        position: static !important;
      
      }
      pre {
        overflow: visible !important;
      }
    }

    .sourceCode, .shell {
      font-family: 'Courier New', Monospace;
      
    }

  </style>



</head>

<body>
  <div class="main">
    <div class="header" style="position:relative;">
      <a href="/purescript/">
          <img class="logo" src="logo-shadow.png"  style="display:block; position:absolute; left:50px;">
      </a>
      <div class="title" style="margin-left: 220px; position:relative; left:0px; right:0px;">
          <h1 id="実例によるpurescript">実例によるPureScript</h1>
          <p>ウェブのための関数型プログラミング</p>
          <p class="author"><a href="https://leanpub.com/purescript/read">Phil Freeman, &quot;PureScript by Example - Functional Programming for the Web&quot;</a></p>
      </div>
      <div style="clear:both;"></div>
    </div>

    <div class="markdown-body content">
      <p class="previous" style="visibility:hidden;"><a href="index.html">&lt; 目次に戻る</a></p>
<h1 id="はじめに"><span class="header-section-number">1</span> はじめに</h1>
<h2 id="関数型javascript"><span class="header-section-number">1.1</span> 関数型JavaScript</h2>
<p>関数型プログラミングの手法は、かねてよりJavaScriptでも用いられてきました。</p>
<ul>
<li><a href="http://underscorejs.org">UnderscoreJS</a>などのライブラリは、<code>map</code>や<code>filter</code>、<code>reduce</code>といったよく知られた関数を活用して、小さいプログラムを組み合わせて大きなプログラムを作れるようにします。</li>
</ul>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> sumOfPrimes = 
    <span class="ot">_</span>.<span class="fu">chain</span>(<span class="ot">_</span>.<span class="fu">range</span>(<span class="dv">1000</span>))
     .<span class="fu">filter</span>(isPrime)
     .<span class="fu">reduce</span>(<span class="kw">function</span>(x, y) { 
         <span class="kw">return</span> x + y; 
     })
     .<span class="fu">value</span>();</code></pre>
<ul>
<li>NodeJSにおける非同期プログラミングでは、コールバックを定義するために第一級の値としての関数に大きく依存しています。</li>
</ul>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="fu">require</span>(<span class="st">&#39;fs&#39;</span>).<span class="fu">readFile</span>(sourceFile, <span class="kw">function</span> (error, data) {
  <span class="kw">if</span> (!error) {
    <span class="fu">require</span>(<span class="st">&#39;fs&#39;</span>).<span class="fu">writeFile</span>(destFile, data, <span class="kw">function</span> (error) {
      <span class="kw">if</span> (!error) {
        <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&quot;File copied&quot;</span>);
      }
    });
  }
});</code></pre>
<p>関数は単純な抽象化を可能にし、優れた生産性をもたらしてくれます。しかし、JavaScriptでの関数型プログラミングには欠点があります。JavaScriptは冗長で、型付けされず、強力な抽象化を欠いているのです。また、奔放に書かれたJavaScriptコードは、式の理解をとても難しくします。</p>
<p>PureScriptはこのような問題を解決すべく作られたプログラミング言語です。PureScriptは、とても表現力豊かでありながらわかりやすく読みやすいコードを書けるようにする、軽量な構文を備えています。強力な抽象化を提供する豊かな型システムも使用しています。また、JavaScriptやJavaScriptへとコンパイルされる他の言語と相互運用するときに重要な、高速で理解しやすいコードを生成します。一言で言えば、PureScriptは純粋関数型プログラミングの理論的な強力さと、JavaScriptのお手軽で緩いプログラミングスタイルとの、とても現実的なバランスを狙っているということを理解して頂けたらと思います。</p>
<h2 id="型と型推論"><span class="header-section-number">1.2</span> 型と型推論</h2>
<p>動的型付けの言語と静的型付けの言語をめぐる議論についてはよく知られています。PureScriptは<strong>静的型付け</strong>の言語、つまり正しいプログラムはコンパイラによってその動作を示すような<strong>型</strong>を与えられる言語です。逆にいえば、型を​​与えることができないプログラムは<strong>誤ったプログラム</strong>であり、コンパイラによって拒否されます。動的型付けの言語とは異なり、PureScriptでは型は<strong>コンパイル時</strong>のみに存在し、実行時には型の表現はありません。</p>
<p>PureScriptの型は、これまでJavaやC#のような他の言語で見たような型とは、いろいろな意味で異なっていることにも注意することが大切です。おおまかに言えばPureScriptの型はJavaやC#と同じ目的を持っているものの、PureScriptの型はMLとHaskellのような言語に影響を受けています。開発者がプログラムについての強い主張を表明できるので、PureScriptの型は表現力豊かなのです。最も重要なのは、PureScriptの型システムは<strong>型推論</strong>(type inference)をサポートしていることです。型推論は最低限の明示的な型注釈だけを必要とし、型システムを厄介者ではなく<strong>道具</strong>にしてくれます。簡単な例を示すと、次のコードは<strong>数</strong>を定義していますが、それが <code>Number</code>型だという注釈はコードのどこにもありません。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">iAmANumber <span class="fu">=</span> 
  <span class="kw">let</span> square x <span class="fu">=</span> x <span class="fu">*</span> x
  <span class="kw">in</span> square <span class="dv">42</span></code></pre>
<p>次のもっと複雑な例では、<strong>コンパイラにとって未知</strong>の型が存在しているときでさえも、型注釈なしで型の正しさを確かめることができるということが示されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">iterate f <span class="dv">0</span> x <span class="fu">=</span> x
iterate f n x <span class="fu">=</span> iterate f (n <span class="fu">-</span> <span class="dv">1</span>) (f x)</code></pre>
<p>ここで <code>x</code>の型は不明ですが、<code>x</code>がどんな型を持っているかにかかわらず、<code>iterate</code>が型システムの規則に従っていることをコンパイラは検証することができます。</p>
<p>静的型はプログラムの正しさについての確信を得るためだけではなく、その正しさによって開発を助けるということをあなたに納得させる(もしくは、あなたの理解を確認する)ことをこの本では試みます。最も単純な抽象化を使わないかぎりJavaScriptでコードの大規模なリファクタリングすることは難しいですが、型検証器のある表現力豊かな型システムは、リファクタリングさえ楽しく対話的な体験にするのです。</p>
<p>加えて、型システムによって提供されたこのセーフティネットは、より高度な抽象化をも可能にします。実際に、関数型プログラミング言語Haskellによって知られるようになった、型主導の強力な抽象化である型クラスをPureScriptは備えています。</p>
<h2 id="多言語webプログラミング"><span class="header-section-number">1.3</span> 多言語Webプログラミング</h2>
<p>関数型プログラミングはすでに多くの成功を収めています。特に成功している応用例を いくつか挙げれば、データ解析、構文解析、コンパイラの実装、ジェネリックプログラミング、並列処理などです。</p>
<p>PureScriptのような関数型言語はアプリケーション開発の最初から最後までを​実施することが可能です。値や関数の型を提供することで既存のJavaScriptコードをインポートし、通常のPureScriptコードからこれらの関数を使用する機能をPureScriptは提供しています。この手法については本書で後ほど見ていくことになります。</p>
<p>しかしながら、PureScriptの強みのひとつはJavaScriptを対象とする他​​の言語との相互運用性にあります。アプリケーションの開発の一部にだけPureScriptを使用し、JavaScriptの残りの部分を記述するのに他の言語を使用するという方針もあります。</p>
<p>いくつかの例を示します。</p>
<ul>
<li>中核となる処理はPureScriptで記述し、ユーザーインターフェースはJavaScriptで記述する</li>
<li>JavaScriptや、他のJavaScriptにコンパイルされる言語でアプリケーションを書き、PureScriptでそのテストを書く</li>
<li>既存のアプリケーションのユーザインタフェースのテストを自動化するためにPureScriptを使用する</li>
</ul>
<p>この本では、小規模な課題をPureScriptで解決することに焦点を当てます。この解決策は大規模なアプリケーションに統合することもできますが、JavaScriptからPureScriptコードを呼び出す方法、およびその逆についても見ていきます。</p>
<h2 id="ソフトウェア要件"><span class="header-section-number">1.4</span> ソフトウェア要件</h2>
<p>この本でのソフトウェア要件は最小限です。第１章では開発環境のセットアップを一から案内します。これから使用するツールは、ほとんどの現代のオペレーティングシステムの標準リポジトリで使用できるものです。</p>
<p>PureScriptコンパイラ自体は最新のHaskell Platformが稼働しているシステムならソースからビルドすることができますが、次の章ではこの手順を説明していきます。</p>
<h2 id="読者について"><span class="header-section-number">1.5</span> 読者について</h2>
<p>読者はJavaScriptの基本をすでに理解しているものと仮定します。すでにNPM、Grunt、Bower のようなJavaScriptのエコシステムでの経験があれば、自身の好みに応じて標準設定をカスタマイズしたい場合などに役に立ちますが、そのような知識は必要ではありません。</p>
<p>関数型プログラミングの予備知識は必要ありませんが、あっても害にはならないでしょう。実例には新しいアイデアがつきものですから、これから使う関数型プログラミングからこうした概念に対する直感的理解を形成することができるはずです。</p>
<p>PureScriptはプログラミング言語Haskellに強く影響を受けているため、Haskellに通じている読者はこの本の中で提示された概念や構文の多くに見覚えがあるでしょう。しかしながら、読者はPureScriptとHaskellの間にはいくつか重要な違いがあることも理解しておかなければなりません。ここで紹介する概念の多くはHaskellでも同じように解釈できるとはいえ、どちらかの言語での考え方を他方の言語でそのまま応用しようとすることは、必ずしも適切ではありません。</p>
<h2 id="本書の読み進めかた"><span class="header-section-number">1.6</span> 本書の読み進めかた</h2>
<p>本書の各章は、概ね章ごとに完結しています。しかしながら、多少の関数型プログラミングの経験がある初心者でも、まずは各章を順番に進めていくことをおすすめします。最初の数章では、本書の後半の内容を理解するために必要な基礎知識を養います。関数型プログラミングの考え方に十分通じた読者(特にMLやHaskellのよう強く型付けされた言語での経験を持つ読者)なら、本書の前半のほうの章を読まなくても後半の章のコードの大まかな理解を得ることがおそらく可能でしょう。</p>
<p>各章ではそれぞれひとつの実用的な例に焦点をあて、新しい考え方を導入するための動機付けとして用います。各章のコードは本書の<a href="https://github.com/paf31/purescript-book">GitHubのリポジトリ</a>から入手できます。各章にはソースコードから抜粋したコード片が掲載されていますが、完全に理解するためには本書に掲載されたコードと平行してリポジトリのソースコードを読む必要があります。対話式環境 <code>psci</code>で実行し理解を確かめられるように、長めの節には短いコード片が含まれます。</p>
<p>コード例は次のように等幅フォントで示されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Example</span> <span class="kw">where</span>

main <span class="fu">=</span> Debug.Trace.trace <span class="st">&quot;Hello, World!&quot;</span></code></pre>
<p>先頭にドル記号がついた行は、コマンドラインに入力されたコマンドです。</p>
<pre class="text"><code>$ psc src/Main.purs</code></pre>
<p>通常はこれらのコマンドはLinux / Mac OSの利用者には適合しますが、Windowsの利用者はファイル区切り文字を変更する、シェルの組み込み機能をWindowsの相当するものに置き換えるなどの小さな変更を加える必要があるかもしれません。</p>
<p><code>psci</code> 対話式プロンプトに入力するコマンドは、行の先頭に山括弧が付けられています。</p>
<pre class="text"><code>&gt; 1 + 2
3</code></pre>
<p>各章には演習が付いており、それぞれ難易度も示されています。各章の内容を完全に理解するために、演習に取り組むことを強くお勧めします。</p>
<p>この本は初心者にPureScriptへの導入を提供することを目的としており、問題についてのお決まりの解決策の一覧を提供するような種類の本ではありません。初心者にとってこの本を読むのは楽しい挑戦になるはずですし、本書の内容を読み演習に挑戦すればだいたいの利益を得られるでしょうが、なにより重要なのは、あなたが自分自身のコードを書いてみることです。</p>
<h2 id="困ったときには"><span class="header-section-number">1.7</span> 困ったときには</h2>
<p>もしどこかでつまづいたときには、PureScriptを学ぶためのオンラインで利用可能な資料がたくさんあります。</p>
<ul>
<li>PureScript IRCチャン​​ネルはあなたが抱える問題についてチャットするのに最適な場所です。IRCクライアントでirc.freenode.netをポイントし、#purescriptチャンネルに接続してください。</li>
<li><a href="http://purescript.org">PureScriptのウェブサイト</a>にはPureScriptの開発者によって書かれたブログ記事や、初心者向けの動画、その他のリソースへのリンクがあります。</li>
<li><a href="http://docs.purescript.org">PureScriptコンパイラのドキュメント</a>は、言語の主要な機能についての簡単​​なコード例があります。</li>
<li><a href="http://try.purescript.org">Try PureScript!</a> ではユーザーがWebブラウザでPureScriptコードをコンパイルすることができます。また、ウェブサイトにはコードの簡単な例がいくつか含まれています。</li>
</ul>
<p>もしあなたが例を読んで学ぶことを好むなら、GitHubの <code>purescript</code>と<code>purescript-contrib</code> organisation にはPureScriptコードの例がたくさんあります。</p>
<h2 id="著者について"><span class="header-section-number">1.8</span> 著者について</h2>
<p>私はPureScriptコンパイラの最初の開発者です。私はカリフォルニア州ロサンゼルスを拠点にしており、8ビットパーソナルコンピュータ、Amstrad CPC上のBASICでまだ幼い時にプログラミングを始めました。それ以来、私はいくつものプログラミング言語(JavaやScala、C#、F#)で業務に携わってきました。</p>
<p>プロとしての経歴が始まって間もなく、私は関数型プログラミングと数学の関係を理解するようになり、そしてプログラミング言語Haskellとの恋に落ちました。</p>
<p>JavaScriptでの経験をもとに、私はPureScriptコンパイラの開発を始めることにしました。私がHaskellのような言語から取り上げた関数型プログラミングの手法を使っていることを私自ら発見しましたが、それを応用するためのもっと理にかなった環境を求めていました。そのときの解決策にはHaskellをその意味論を維持しながらJavaScriptへとコンパイルするいろいろな試み(Fay、Haste、GHCJS)が含まれていましたが、私が興味を持っていたのは、この問題への別の切り口からのアプローチ、すなわちHaskellのような言語の構文と型システムを楽しみながらJavaScriptの意味論も維持するということが、どのようにすれば可能になるのかでした。</p>
<p>私は<a href="http://functorial.com">ウェブサイト</a>を運営しており、<a href="http://twitter.com/paf31">Twitterで連絡をとる</a>こともできます。</p>
<h2 id="謝辞"><span class="header-section-number">1.9</span> 謝辞</h2>
<p>現在の状態に到達するまでPureScriptを手伝ってくれた多くの協力者に感謝したいと思います。コンパイラやツール、ライブラリ、ドキュメント、テストでの組織的で弛まぬ努力がなかったら、プロジェクトは間違いなく失敗していたことでしょう。</p>
<p>この本の表紙に表示されたPureScriptのロゴはGareth Hughesによって作成されたもので、<a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 license</a>の条件の下で再利用させて頂いています 。</p>
<p>最後に、この本の内容に関する反応や訂正をくださったすべての方に、心より感謝したいと思います。</p>
<h1 id="開発環境の準備"><span class="header-section-number">2</span> 開発環境の準備</h1>
<h2 id="この章の目標"><span class="header-section-number">2.1</span> この章の目標</h2>
<p>この章の目標は、作業用のPureScript開発環境を準備し、最初のPureScriptプログラムを書くことです。</p>
<p>これから書く最初のコードは、NPMとBowerから依存するライブラリを使用し、ビルド自動化ツールであるGruntを使用してビルドされるライブラリの例です。このライブラリは直角三角形の対角線の長さを計算する関数ひとつだけを提供します。</p>
<h2 id="導入"><span class="header-section-number">2.2</span> 導入</h2>
<p>PureScript開発環境を準備するために、次のツールを使います。</p>
<ul>
<li><a href="http://purescript.org"><code>psc</code></a> - PureScriptコンパイラ本体</li>
<li><a href="http://npmjs.org"><code>npm</code></a> - 残りの開発ツールをインストールできるようにする、Nodeパッケージマネージャ</li>
<li><a href="http://bower.io/"><code>bower</code></a> ​​- 必要となる様々なバージョンのPureScriptパッケージで使われているパッケージマネージャ</li>
<li><a href="http://gruntjs.com/"><code>grunt</code></a> - PureScriptコードをビルドするために使用する自動化ツール</li>
</ul>
<p>この章ではこれらのツールのインストール方法と設定を説明します。</p>
<h2 id="purescriptのインストール"><span class="header-section-number">2.3</span> PureScriptのインストール</h2>
<p>PureScriptコンパイラをインストールするときに推奨される方法は、ソースからコンパイラをビルドすることです。PureScriptコンパイラは<a href="http://purescript.org">PureScriptのウェブサイト</a>から64ビットのUbuntu用のバイナリディストリビューションとしてダウンロードすることもできますが、現在のところバイナリディストリビューションは主要なリリースについてだけ提供されています。もし最近のバグ修正や機能追加がなされた最新版に保ち、コンパイラで最新のパッケージをビルドできるようにしたいなら、最新のマイナーリリースをビルドするよう以下の指示に従ってください。</p>
<p>主なソフトウェア要件としては、<a href="http://haskell.org/platform">Haskell Platform</a>がインストールされていることです。お使いのオペレーティングシステムによっては、パッケージマネージャを使用して<code>ncurses</code>開発パッケージもインストールする必要があるかもしれません(例えば、Ubuntuでは<code>libncurses5-dev</code>パッケージとしての利用できます)。</p>
<p>Cabal実行ファイルの最新版を持っているのを確認することから始めましょう。</p>
<pre class="shell"><code>$ cabal install Cabal cabal-install</code></pre>
<p>また、Cabalのパッケージ一覧が最新であることも確認してください。</p>
<pre class="shell"><code>$ cabal update</code></pre>
<p>PureScriptコンパイラは、グローバルもしくはローカルディレクトリ内のCabalサンドボックス内のどちらかにインストールすることができます。この節ではグローバルにPureScriptをインストールし、その実行ファイルがパス上で利用できるようにする方法を説明します。</p>
<p><code>cabal install</code>コマンドを使用して、HackageからPureScriptをインストールします。</p>
<pre class="shell"><code>$ cabal install purescript</code></pre>
<p>これでコンパイラおよび関連する実行ファイルはあなたのパス上で利用できるようになるでしょう。確認のために、コマンドラインでPureScriptコンパイラを実行してみましょう：</p>
<pre class="shell"><code>$ psc</code></pre>
<h2 id="各ツールのインストール"><span class="header-section-number">2.4</span> 各ツールのインストール</h2>
<p>もし<a href="http://nodejs.org/">NodeJS</a>がインストールされていないなら、NodeJSをインストールする必要があります。そうするとシステムに <code>npm</code>パッケージマネージャもインストールされるはずです。 <code>npm</code>がインストールされ、パス上で利用可能であることを確認してください。</p>
<p><code>npm</code> がインストールされたら、GruntとBowerもインストールする必要があります。プロジェクトがどこで作業しているかにかかわらずこれらのコマンドラインツールを利用可能にするため、通常はグローバルにインストールしておくのがいいでしょう。</p>
<pre class="shell"><code>$ npm install -g grunt-cli bower</code></pre>
<p>これで、最初のPureScriptプロジェクトを作成するために必要なすべてのツールの用意ができたことになります。</p>
<h2 id="hello-purescript"><span class="header-section-number">2.5</span> Hello, PureScript!</h2>
<p>まずはシンプルに始めましょう。PureScriptコンパイラ <code>psc</code>を直接使用して、基本的なHello World! プログラムをコンパイルします。3つの標準のコマンドですべての依存関係ライブラリを含めてゼロからアプリをビルドできるようになるまで、この章を読み進むにつれて開発手順をだんだんと自動化していきます。</p>
<p>まず最初に、ソースファイルのディレクトリ <code>src</code>を作成し、<code>src/Chapter2.purs</code>という名前のファイルに以下のコードを貼り付けます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Chapter2</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Debug.Trace</span>

main <span class="fu">=</span> trace <span class="st">&quot;Hello, World!&quot;</span></code></pre>
<p>これは小さなサンプルコードですが、​​いくつかの重要な概念を示しています。</p>
<ul>
<li>すべてのソースファイルはモジュールヘッダから始まります。モジュール名は、ドットで区切られた大文字で始まる1つ以上の単語から構成されています。ここではモジュール名としてひとつの単語だけが使用されていますが、<code>My.First.Module</code>というようなモジュール名も有効です。</li>
<li>モジュールは、モジュール名の各部分を区切るためのドットを含めた、完全な名前を使用してインポートされます。ここでは<code>trace</code>関数を提供する <code>Debug.Trace</code>モジュールをインポートしています。</li>
<li>この<code>main</code>プログラムの定義本体は、関数適用の式になっています。PureScriptでは、関数適用は関数名の後に引数を空白で区切って書くことで示されます。</li>
</ul>
<p>それではこのコードをビルドして実行してみましょう。次のコマンドを実行します。</p>
<pre class="shell"><code>$ psc src/Chapter2.purs</code></pre>
<p>うまくいくと、大量のJavaScriptがコンソールに出力されるのを目にするはずです。コンソールに出力する代わりに、<code>--output</code>コマンドラインオプションで出力をファイルにリダイレクトしてみましょう。</p>
<pre class="shell"><code>$ psc src/Chapter2.purs --output dist/Main.js</code></pre>
<p>これでNodeJSを使用してコードを実行することができるはずです。</p>
<pre class="shell"><code>$ node dist/Main.js</code></pre>
<p>うまくいくと、NodeJSはこのコードを正常に実行し、コンソールには何も出力されないはずです。これは、メインとなるモジュールの名前をPureScriptコンパイラに教えていないためです！</p>
<pre class="shell"><code>$ psc src/Chapter2.purs --output dist/Main.js --main=Chapter2</code></pre>
<p>再びNodeJSで実行すると、今度は &quot;Hello, World!&quot; という単語がコンソールに出力されるのがわかるはずです。</p>
<h2 id="使用されていないコードを取り除く"><span class="header-section-number">2.6</span> 使用されていないコードを取り除く</h2>
<p>テキストエディタで <code>dist/Main.js</code>ファイルを開くと、大量のJavaScriptコードが書かれているのがわかります。これはコンパイラがPreludeと呼ばれるモジュール群で定義されている標準関数を追加しているためです。Preludeにはコンソールに出力するのに使う <code>Debug.Trace</code>モジュールが含まれています。</p>
<p>ここで生成されたコードのほとんどは実際には使用されていないので、別のコンパイラオプションを指定すると未使用のコードを削除することができます。</p>
<pre class="shell"><code>$ psc src/Chapter2.purs --output dist/Main.js --main=Chapter2 --module Chapter2</code></pre>
<p><code>Chapter2</code>モジュールで定義されたコードで必要とされているJavaScriptだけを含めるよう<code>psc</code>に指示する<code>--module Chapter2</code>オプションを追加しました。生成されたコードをテキストエディタで開くと、次のように出力されているのがわかるはずです。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> PS = PS || {};
<span class="ot">PS</span>.<span class="fu">Debug_Trace</span> = (<span class="kw">function</span> () {
    <span class="st">&quot;use strict&quot;</span>;
    <span class="kw">function</span> <span class="fu">trace</span>(s) { 
      <span class="kw">return</span> <span class="kw">function</span>() {
        <span class="ot">console</span>.<span class="fu">log</span>(s);
        <span class="kw">return</span> {};  
      };
    };
    <span class="kw">return</span> {
        <span class="dt">trace</span>: trace
    };
})();

<span class="kw">var</span> PS = PS || {};
<span class="ot">PS</span>.<span class="fu">Chapter2</span> = (<span class="kw">function</span> () {
    <span class="st">&quot;use strict&quot;</span>;
    <span class="kw">var</span> Debug_Trace = <span class="ot">PS</span>.<span class="fu">Debug_Trace</span>;
    <span class="kw">var</span> main = <span class="ot">Debug_Trace</span>.<span class="fu">trace</span>(<span class="st">&quot;Hello, World!&quot;</span>);
    <span class="kw">return</span> {
        <span class="dt">main</span>: main
    };
})();

<span class="ot">PS</span>.<span class="ot">Chapter2</span>.<span class="fu">main</span>();</code></pre>
<p>NodeJSを使用してこのコードを実行すると、先ほどと同じ文字列がコンソールに出力されるはずです。</p>
<p>ここでPureScriptコンパイラがJavascriptコードを生成する方法の要点が示されています。</p>
<ul>
<li>すべてのモジュールはオブジェクトに変換され、そのオブジェクトにはそのモジュールのエクスポートされたメンバが含まれています。モジュールは即時関数パターンによってスコープが限定されたコードで初期化されています。</li>
<li>PureScriptは可能な限り変数の名前をそのまま使おうとします</li>
<li>PureScriptにおける関数適用は、そのままJavaScriptの関数適用に変換されます。</li>
<li>引数のない単純な呼び出しとしてメインメソッド呼び出しが生成され、すべてのモジュールが定義された後に実行されます。</li>
<li>PureScriptコードはどんな実行時ライブラリにも依存しません。コンパイラによって生成されるすべてのコードは、あなたのコードが依存するいずれかのPureScriptモジュールをもとに出力されているものです。</li>
</ul>
<p>PureScriptはシンプルで理解しやすいコードを生成すること重視しているので、これらの点は大切です。実際に、ほとんどのコード生成処理はごく軽い変換です。PureScriptについての理解が比較的浅くても、ある入力からどのようなJavaScriptコードが生成されるかを予測することは難しくありません。</p>
<h2 id="gruntによるビルドの自動化"><span class="header-section-number">2.7</span> Gruntによるビルドの自動化</h2>
<p>今度は、PureScriptコンパイラオプションを毎回手で入力する代わりに、コードを自動でビルドできるように、Gruntを設定してみましょう。</p>
<p>プロジェクトディレクトリに<code>Gruntfile.js</code>という名前のファイルを作成し、次のコードを貼り付けてください。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="ot">module</span>.<span class="fu">exports</span> = <span class="kw">function</span>(grunt) {

  <span class="st">&quot;use strict&quot;</span>;

  <span class="ot">grunt</span>.<span class="fu">initConfig</span>({

    <span class="dt">srcFiles</span>: [<span class="st">&quot;src/**/*.purs&quot;</span>],

    <span class="dt">psc</span>: {
      <span class="dt">options</span>: {
        <span class="dt">main</span>: <span class="st">&quot;Chapter2&quot;</span>,
        <span class="dt">modules</span>: [<span class="st">&quot;Chapter2&quot;</span>]
      },
      <span class="dt">all</span>: {
        <span class="dt">src</span>: [<span class="st">&quot;&lt;%=srcFiles%&gt;&quot;</span>],
        <span class="dt">dest</span>: <span class="st">&quot;dist/Main.js&quot;</span>
      }
    }
  });

  <span class="ot">grunt</span>.<span class="fu">loadNpmTasks</span>(<span class="st">&quot;grunt-purescript&quot;</span>);
  
  <span class="ot">grunt</span>.<span class="fu">registerTask</span>(<span class="st">&quot;default&quot;</span>, [<span class="st">&quot;psc:all&quot;</span>]);
};</code></pre>
<p>このファイルではNodeモジュールを定義しており、ビルド構成を定義するために<code>grunt</code>モジュールをライブラリとして使用しています。JSONプロパティとしてコマンドラインオプションを指定してPureScriptコンパイラを呼び出せる<code>grunt-purescript</code>プラグインを使用しています。</p>
<p><code>grunt-purescript</code>プラグインは他にも便利な機能を提供しており、コードから自動的にMarkdownドキュメントを生成する機能や、ライブラリから<code>psci</code>対話式コンパイラ向けの設定ファイルを自動生成する機能があります。興味があれば <code>grunt-purescript</code> <a href="http://github.com/purescript-contrib/grunt-purescript">プロジェクトのホームページ</a>を参照してみてください。</p>
<p>次のように入力して、ローカルのmodulesディレクトリに <code>grunt</code>ライブラリと<code>grunt-purescript</code>プラグインをインストールしてください。</p>
<pre class="shell"><code>$ npm install grunt grunt-purescript@0.6.0</code></pre>
<p>保存された<code>Gruntfile.js</code>ファイルを使うと、次のようにコードをコンパイルできるようになります。</p>
<pre class="shell"><code>$ grunt
&gt;&gt; Created file dist/Main.js.

Done, without errors.</code></pre>
<h2 id="npmパッケージの作成"><span class="header-section-number">2.8</span> NPMパッケージの作成</h2>
<p>Gruntを設定したので、コンパイルするときに毎回コマンドラインにコマンドを入力する必要はなくなりましたが、もっと重要なのは、アプリケーションのエンドユーザはどちらも必要ないということです。そのためには、ビルドする前にNPMパッケージの必要なモジュールを自動的にインストールしておくという手順を追加しておきましょう。</p>
<p>依存関係が指定された独自のNPMパッケージを定義します。</p>
<p>プロジェクトディレクトリで <code>init</code>サブコマンドを指定して<code>npm</code>を実行し、新しいプロジェクトを初期化します。</p>
<pre class="shell"><code>$ npm init</code></pre>
<p>いろいろと質問されますが、それが終わると<code>package.json</code>という名前のファイルがプロジェクトディレクトリに追加されます。このファイルではプロジェクトのプロパティを指定したり、依存するライブラリの指定を追加することができます。テキストエディタでこのファイルを開き、JSONオブジェクトに次のプロパティを追加しましょう。</p>
<pre class="sourceCode json"><code class="sourceCode json"><span class="er">&quot;dependencies&quot;:</span> <span class="fu">{</span>
  <span class="dt">&quot;grunt-purescript&quot;</span><span class="fu">:</span> <span class="st">&quot;0.6.0&quot;</span>
<span class="fu">}</span></code></pre>
<p>このコードではインストールする<code>grunt-purescript</code>プラグインの厳密なバージョンを指定しています。</p>
<p>依存するライブラリを手作業でインストールするかわりに、エンドユーザーは単に <code>npm</code>コマンドを使用するだけで必要なものすべてをインストールできるようになりました。</p>
<pre class="shell"><code>$ npm install</code></pre>
<h2 id="bowerによる依存関係の追跡"><span class="header-section-number">2.9</span> Bowerによる依存関係の追跡</h2>
<p>この章の目的となっている<code>diagonal</code>関数を書くためには、平方根を計算できるようにする必要があります。<code>purescript-math</code>パッケージにはJavaScriptの<code>Math</code>オブジェクトのプロパティとして定義されている関数の型定義が含まれていますので、<code>purescript-math</code>パッケージをインストールしてみましょう。 <code>npm</code>の依存関係でやったのと同じように、次のようにコマンドラインに入力すると直接このパッケージをダウンロードできます。</p>
<pre class="shell"><code>$ bower install purescript-math#0.1.0</code></pre>
<p>このコマンドは <code>purescript-math</code>ライブラリのバージョン0.1.0をそれが依存するライブラリと一緒にインストールします。</p>
<p>しかし、<code>package.json</code>を作成してNPMの依存関係を制御するために<code>npm init</code>を使用したのと同じような方法で、Bowerの依存関係が含まれている<code>bower.json</code>ファイルを設定することができます。</p>
<p>コマンドラインに次のコマンドを入力します。</p>
<pre class="shell"><code>$ bower init</code></pre>
<p>NPMの場合とちょうど同じように、いくつか質問をされ、それが終わると <code>bower.json</code>ファイルがプロジェクトディレクトリに配置されます。この処理の途中で、すでに存在するライブラリの依存関係をプロジェクトファイルに含めたいかどうかを尋ねられるでしょう。「はい」を選択した場合は、<code>bower.json</code> にこのようなセクションがあるのがわかるでしょう。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="st">&quot;dependencies&quot;</span>: {
  <span class="st">&quot;purescript-math&quot;</span>: <span class="st">&quot;0.1.0&quot;</span>
}</code></pre>
<p>エンドユーザーが手作業で依存するライブラリを指示する必要がなくなり、代わりに次のようにコマンドを呼び出すだけで依存するライブラリを取り込むことができるようになりました。</p>
<pre class="shell"><code>$ bower update</code></pre>
<p>それでは、Bowerから取り込んだ依存先ライブラリをコンパイルに含めるように、Gruntスクリプトを更新してみましょう。<code>Gruntfile.js</code>を編集し、ソースファイルについての行を次のように変更します。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">srcFiles: [<span class="st">&quot;src/**/*.purs&quot;</span>, <span class="st">&quot;bower_components/**/src/**/*.purs&quot;</span>]</code></pre>
<p>この行では <code>bower_components</code>ディレクトリのソースファイルをコンパイルするソースファイルに含めています。独自のBower構成がある場合は、それに応じてこの行を修正する必要があるかもしれません。</p>
<blockquote>
<h3 id="なぜnpmとbowerの両方を使うのか" class="unnumbered">なぜNPMとBowerの両方を使うのか？</h3>
<p>疑問に思ったかもしれませんが、なぜ2つ​​のパッケージマネージャを使い分ける必要があるのでしょうか？PureScriptライブラリをNPMレジストリに含めることはできないのでしょうか？</p>
<p>PureScriptコミュニティは、さまざまな理由でPureScriptの依存ライブラリをBowerを使用して標準化しています。</p>
<ul>
<li>PureScriptのライブラリパッケージがJavaScriptのソースコードを含むことはめったになく、コンパイルされないままでNPMレジストリへ配置するのには適していません。</li>
<li>Bowerレジストリは、直接コードをホスティングする代わりに、既存のGitリポジトリのパッケージ名とバージョンの対応関係だけを管理しています。これによりコミュニティがコードおよびリリースを管理するのにGitHubのような既存のツールを使用することができます。</li>
<li>BowerはCommonJSのモジュール標準のような特定の配置に従うようパッケージに要求してしません。</li>
</ul>
<p>もちろん、任意のパッケージマネージャを自由に選択して使用することもできます。PureScriptコンパイラおよびツール群は、Bowerに（またはNPM、Gruntなどにも）依存しているわけではありません。</p>
</blockquote>
<h2 id="対角線の長さの計算"><span class="header-section-number">2.10</span> 対角線の長さの計算</h2>
<p>それでは外部ライブラリの関数を使用する例として <code>diagonal</code>関数を書いてみましょう。</p>
<p>まず、 <code>src/Chapter2.purs</code>ファイルの先頭に次の行を追加し、<code>Math</code>モジュールをインポートします。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Math</span></code></pre>
<p>そして、次のように<code>diagonal</code>関数を定義します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">diagonal w h <span class="fu">=</span> sqrt (w <span class="fu">*</span> w <span class="fu">+</span> h <span class="fu">*</span> h)</code></pre>
<p>この関数の型を定義する必要はないことに注意してください。<code>diagonal</code> は2つの数値を取り数を返す関数である とコンパイラは推論することができます。しかし、ドキュメントとしても役立つので、通常は型注釈を提供しておくことをお勧めします。</p>
<p>それでは、新しい<code>diagonal</code>関数を使うように<code>main</code>関数も変更してみましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> print (diagonal <span class="dv">3</span> <span class="dv">4</span>)</code></pre>
<p>Gruntを使用して、モジュールを再コンパイルします。</p>
<pre class="shell"><code>$ grunt</code></pre>
<p>生成されたコードを再び実行すると、このコードが正常に呼び出されたことがわかるでしょう。</p>
<pre class="shell"><code>$ node dist/Main.js 

5</code></pre>
<h2 id="対話式処理系を使用したコードのテスト"><span class="header-section-number">2.11</span> 対話式処理系を使用したコードのテスト</h2>
<p>PureScriptコンパイラには <code>psci</code>と呼ばれる対話式のREPL(Read-eval-print loop)が付属しています。<code>psci</code>はコードをテストしたり思いついたことを試すのにとても便利です。それでは、<code>psci</code>を使って<code>diagonal</code>関数をテストしてみましょう。</p>
<p><code>grunt-purescript</code>プラグインは、ソースファイルに応じて<code>psci</code>設定を自動で生成するように設定することができます。これにより<code>psci</code>に手作業でモジュールを読み込む手間を省くことができます。</p>
<p>これを設定するには、<code>Gruntfile.js</code>ファイルに以下のような<code>psc</code>や<code>pscMake</code>という新しいビルドターゲットを追加します。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">dotPsci: [<span class="st">&quot;&lt;%=srcFiles%&gt;&quot;</span>]</code></pre>
<p>また、デフォルトのタスクにこのターゲットを追加しておきましょう。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="ot">grunt</span>.<span class="fu">registerTask</span>(<span class="st">&quot;default&quot;</span>, [<span class="st">&quot;psc:all&quot;</span>, <span class="st">&quot;dotPsci&quot;</span>]);</code></pre>
<p>これで <code>grunt</code>を実行すると<code>.psci</code>ファイルがプロジェクトディレクトリに自動生成されるようになりました。このファイルは、 <code>psci</code>の起動時に設定で使用されるコマンドを指定するのに使われます。</p>
<p>それでは <code>psci</code>を起動してみます。</p>
<pre class="shell"><code>$ psci
&gt; </code></pre>
<p>コマンドの一覧を見るには、<code>:?</code>と入力します。</p>
<pre class="shell"><code>&gt; :?
The following commands are available:

    :?              Show this help menu
    :i &lt;module&gt;     Import &lt;module&gt; for use in PSCI
    :m &lt;file&gt;       Load &lt;file&gt; for importing
    :q              Quit PSCi
    :r              Reset
    :t &lt;expr&gt;       Show the type of &lt;expr&gt;</code></pre>
<p>Tabキーを押すと、自分のコードで利用可能なすべての関数、及びBowerの依存関係とプレリュードモジュールのリストをすべて見ることができるはずです。</p>
<p>幾つか数式を評価してみてください。<code>psci</code>で評価を行うには、1行以上の式を入力し、Ctrl+ Dで入力を終了します。</p>
<pre class="shell"><code>&gt; 1 + 2
3

&gt; &quot;Hello, &quot; ++ &quot;World!&quot;
&quot;Hello, World!&quot;</code></pre>
<p>それでは<code>psci</code>で<code>diagonal</code>関数を試してみましょう。</p>
<pre class="shell"><code>&gt; Chapter2.diagonal 5 12

13</code></pre>
<p>また、<code>psci</code>で関数を定義する使こともできます。</p>
<pre class="shell"><code>&gt; let double x = x * 2

&gt; double 10
20</code></pre>
<p>コード例の構文がまだよくわからなくても心配はいりません。 この本を読み進めるうちにわかるようになっていきます。</p>
<p>最後に、<code>:t</code>コマンドを使うと式の型を確認することができます。</p>
<pre class="shell"><code>&gt; :t true
Prim.Boolean

&gt; :t [1, 2, 3]
[Prim.Number]</code></pre>
<p><code>psci</code>で試してみてください。もしどこかでつまづいた場合は、メモリ内にあるコンパイル済みのすべてのモジュールをアンロードするリセットコマンド<code>:r</code>を使用してみてください。</p>
<h2 id="任意-commonjsのモジュールのビルド"><span class="header-section-number">2.12</span> 任意: CommonJSのモジュールのビルド</h2>
<p>PureScriptコンパイラの<code>psc</code>コマンドは、ウェブブラウザでの使用に適した、単一の出力ファイルにJavaScriptコードを生成します。それとは別に、コンパイルには<code>psc-make</code>という選択肢もあります。<code>psc-make</code>では、コンパイルされるPureScriptモジュールそれぞれについて、個別のCommonJSモジュール生成することができます。もしCommonJSモジュール標準に対応したNodeJSのような実行環境を対象とするなら、<code>psc-make</code>のほうが望ましい場合があるでしょう。</p>
<p>コマンドラインで<code>psc-make</code>を実行するには、入力ファイルを指定し、<code>--output</code>オプションでCommonJSモジュールが作成されるディレクトリも指定します。</p>
<pre class="shell"><code>$ psc-make src/Chapter2.purs --output dist/</code></pre>
<p>与えられた入力ファイルのそれぞれのモジュールについて、<code>dist/</code>ディレクトリの中にサブディレクトリが作成されるでしょう。Bowerの依存関係を使用している場合は、<code>bower_components/</code>ディレクトリ内のソースファイルを含めることを忘れないでください！</p>
<p><code>grunt-purescript</code>プラグインは<code>psc-make</code>を使用したコンパイルにも対応しています。Gruntから <code>psc-make</code>を使用するには、<code>Gruntfile.js</code>ファイルを次のように変更します。</p>
<ul>
<li>ビルドターゲットを<code>psc</code>から<code>pscMake</code> へ変更します</li>
<li>出力先を<code>dist/Main.js</code>という単一のファイルからディレクトリ<code>dest： &quot;dist /&quot;</code>へ変更します</li>
<li>デフォルトのタスクを<code>pscMake</code>ビルドターゲットを参照するように変更します</li>
</ul>
<p>これで、 <code>Chapter2</code>モジュールとその依存先ライブラリそれぞれについて、<code>grunt</code>コマンドラインツールが <code>dist/</code>の下にサブディレクトリを作成するようになりました。</p>
<h2 id="gruntプロジェクトテンプレートの使用"><span class="header-section-number">2.13</span> Gruntプロジェクトテンプレートの使用</h2>
<p>様々なビルドプロセスに対応するために、NPMやGrunt、Bowerはいろいろな方法でカスタマイズすることができます。しかし、簡単なプロジェクトでは、この手順はGruntプロジェクトテンプレートを使用して自動化することもできます。</p>
<p><code>grunt-init</code>ツールは、テンプレートを利用して簡単なプロジェクトを開始する方法を提供します。<code>grunt-init-purescript</code>プロジェクトは、簡単なテストスイートを含むPureScriptプロジェクトのシンプルなテンプレートを提供します。</p>
<p><code>grunt-init</code>を使用してプロジェクトを設定するには、最初にNPMを使用して<code>grunt-init</code>のコマンドラインツールをインストールします。</p>
<pre class="shell"><code>$ npm install -g grunt-init</code></pre>
<p>そして、ホームディレクトリにPureScriptテンプレートを複製してください。たとえば、LinuxやMacでは、次のようにします。</p>
<pre class="shell"><code>$ mkdir ~/.grunt-init
$ git clone https://github.com/purescript-contrib/grunt-init-purescript.git \
    ~/.grunt-init/purescript</code></pre>
<p>これで、新しいディレクトリに簡単なプロジェクトを作成できるようになりました。</p>
<pre class="shell"><code>$ mkdir new-project
$ cd new-project/
$ grunt-init purescript</code></pre>
<p>いくつかの簡単な質問を受けたあと、現在のディレクトリにプロジェクトが初期化されますので、これまで見てきたコマンドを使ってビルドの準備をしましょう。</p>
<pre class="shell"><code>$ npm install
$ bower update
$ grunt</code></pre>
<p>最後のコマンドでは、ソースファイルをビルドし、テストスイートを実行しています。</p>
<p>より複雑なプロジェクトの雛形として、このプロジェクトテンプレートを使用することができます。</p>
<blockquote>
<h2 id="演習" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単） <code>Math.pi</code>定数を使用し、指定された半径の円の面積を計算する関数 <code>circleArea</code>を書いてみましょう。また、<code>psci</code>を使用してその関数をテストしてください。</p></li>
<li><p>（やや難しい） <code>node dist/Main.js</code>と入力する代わりにユーザが単に <code>grunt run</code>を入力するだけで、コンパイルされたコードをNodeJSで実行できるように、<code>Gruntfile.js</code>ファイルにタスクを追加しましょう。<strong>ヒント</strong>： <code>grunt-execute</code> Gruntプラグインを使用することを検討してください。</p></li>
</ol>
</blockquote>
<h2 id="まとめ"><span class="header-section-number">2.14</span> まとめ</h2>
<p>この章では、JavaScriptのエコシステムのNPMとBower、Gruntという標準的なツールを使用し、一から開発環境をセットアップしました。</p>
<p>また最初のPureScript関数を書き、コンパイルし、NodeJSを使用して実行することができました。</p>
<p>以降の章では、コードをコンパイルやデバッグ、テストするためにこの開発設定を使用しますので、これらのツールや使用手順に十分習熟しておくとよいでしょう。</p>
<h1 id="関数とレコード"><span class="header-section-number">3</span> 関数とレコード</h1>
<h2 id="この章の目標-1"><span class="header-section-number">3.1</span> この章の目標</h2>
<p>この章では、関数およびレコードというPureScriptプログラムのふたつの構成要素を導入します。さらに、どのようにPureScriptプログラムを構造化するのか、どのように型をプログラム開発に役立てるかを見ていきます。　</p>
<p>電話番号の一覧を管理する簡単​​な電話帳アプリケーションを作成していきます。このコード例により、PureScriptの構文からいくつかの新しい概念を導入します。</p>
<p>このアプリケーションのフロントエンドは対話式処理系 <code>psci</code> を使うようにしますが、JavaScriptでフロントエンドを書くこともできるでしょう。</p>
<h2 id="プロジェクトの準備"><span class="header-section-number">3.2</span> プロジェクトの準備</h2>
<p>この章のソースコードは<code>src/data/ PhoneBook.purs</code> というファイルに含まれています。このファイルは次のようなモジュール宣言とインポート一覧から始まります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Data.PhoneBook</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.List</span>
<span class="kw">import </span><span class="dt">Data.Maybe</span>

<span class="kw">import </span><span class="dt">Control.Plus</span> (empty)</code></pre>
<p>ここでは <code>purescript-lists</code>パッケージで提供されている <code>Data.List</code> モジュールをインポートしています。<code>purescript-lists</code>パッケージはbowerを使用してインストールすることができ、連結リストを使うために必要ないくつかの関数が含まれています。</p>
<p><code>Data.Maybe</code> モジュールは、値が存在したりしなかったりするような、オプショナルな値を扱うためのデータ型と関数を定義しています。</p>
<p><code>Control.Plus</code> モジュールには後ほど使う <code>em​​pty</code> 値が定義されています。このモジュールのインポート内容は括弧内で明示的に列挙されていることに注意してください。明示的な列挙はインポート内容の衝突を避けるのに役に立つので、一般に良い習慣です。</p>
<h2 id="単純な型"><span class="header-section-number">3.3</span> 単純な型</h2>
<p>JavaScriptのプリミティブ型に対応する組み込みデータ型として、PureScriptでは数値型と文字列型、真偽型の３つが定義されています。すべてのモジュールに暗黙にインポートされる <code>Prim</code>モジュールでこれらの型は定義されています。これらの型はそれぞれ <code>Number</code>、<code>String</code>、と <code>Boolean</code> と呼ばれ、<code>psci</code> の<code>:t</code> コマンドを使用すると簡単な値の型を確認できます。</p>
<pre class="text"><code>$ psci

&gt; :t 1
Prim.Number

&gt; :t &quot;test&quot;
Prim.String

&gt; :t true
Prim.Boolean</code></pre>
<p>PureScriptには他にも配列とレコード、関数の3つの組み込み型が定義されています。</p>
<p>配列はJavaScriptの配列に対応していますが、JavaScriptの配列とは異なり、PureScriptの配列のすべての要素は同じ型を持つ必要があります。</p>
<pre class="text"><code>&gt; :t [1, 2, 3]
[Prim.Number]

&gt; :t [true, false]
[Prim.Boolean]

&gt; :t [1, false]
Cannot unify Prim.Number with Prim.Boolean.</code></pre>
<p>最後の例で起きているエラーは型検証器によって報告されたもので、配列の2つの要素の型を<strong>単一化</strong>(Unification)しようとして失敗したこと示しています。</p>
<p>レコードはJavaScriptのオブジェクトに対応しており、レコードリテラルはJavaScriptのオブジェクトリテラルと同じ構文になっています。</p>
<pre class="text"><code>&gt; let author = 
        { name: &quot;Phil&quot;
        , interests: [&quot;Functional Programming&quot;, &quot;JavaScript&quot;] 
        }

&gt; :t author
{ name :: Prim.String, interests :: [Prim.String] }</code></pre>
<p>この型が示しているのは、オブジェクト<code>author</code>は、</p>
<ul>
<li><code>String</code>型のフィールド<code>name</code></li>
<li><code>[String]</code>つまり<code>String</code>の配列の型のフィールド<code>interests</code></li>
</ul>
<p>というふたつの<strong>フィールド</strong>(field)を持っているということです。</p>
<p>レコードのフィールドは、ドットに続けて参照したいフィールドのラベルを書くと参照することができます。</p>
<pre class="text"><code>&gt; author.name
&quot;Phil&quot;

&gt; author.interests
[&quot;Functional Programming&quot;,&quot;JavaScript&quot;]</code></pre>
<p>PureScriptの関数はJavaScriptのの関数に対応しています。PureScriptの標準ライブラリは多くの関数の例を提供しており、この章ではそれらをもう少し詳しく見ていきます。</p>
<pre class="text"><code>&gt; :t Prelude.flip
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c

&gt; :t Prelude.const
forall a b. a -&gt; b -&gt; a</code></pre>
<p>ファイルのトップレベルでは、等号の直前に引数を指定することで関数を定義することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span>
add x y <span class="fu">=</span> x <span class="fu">+</span> y</code></pre>
<p>バックスラッシュにに続けて空白文字で区切られた引数名のリストを書くと、関数をインラインで定義することもできます。</p>
<pre class="text"><code>&gt; let 
    add :: Number -&gt; Number -&gt; Number
    add = \x y -&gt; x + y</code></pre>
<p><code>psci</code>でこの関数が定義されていると、次のように関数の隣に２つの引数を空白で区切って書くことで、関数をこれらの引数に<strong>適用</strong>(apply)することができます。</p>
<pre class="text"><code>&gt; add 10 20
30</code></pre>
<h2 id="量化された型"><span class="header-section-number">3.4</span> 量化された型</h2>
<p>前の節ではPreludeで定義された関数の型をいくつかの見てきました。たとえば<code>flip</code>関数は次のような型を持っていました。</p>
<pre class="text"><code>&gt; :t Prelude.flip
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</code></pre>
<p>この<code>forall</code>キーワードは<code>flip</code>が<strong>全称量化された型</strong>(universally quantified type)を持っていることを示しています。これは、<code>a</code>や<code>b</code>、<code>c</code>をどの型に置き換えても、<code>flip</code>はその型でうまく動作するという意味です。</p>
<p>例えば、<code>a</code>を<code>Number</code>、<code>b</code>を<code>String</code>、<code>c</code>を<code>String</code>というように選んでみたとします。この場合、<code>flip</code>の型を次のように<strong>特殊化</strong>(specialize)することができます。</p>
<pre class="text"><code>(Number -&gt; String -&gt; String) -&gt; String -&gt; Number -&gt; String</code></pre>
<p>量化された型を特殊化したいということをコードで示す必要はありません。特殊化は自動的に行われます。たとえば、すでにその型の<code>flip</code>を持っていたかのように、次のように単に<code>flip</code>を使用することができます。</p>
<pre class="text"><code>&gt; flip (\n s -&gt; show n ++ s) &quot;Ten&quot; 10
  
&quot;10Ten&quot;</code></pre>
<p><code>a</code>、<code>b</code>、<code>c</code>の型はどんな型でも選ぶことができるといっても、型の不整合は生じないようにしなければなりません。<code>flip</code> に渡す関数の型は、他の引数の型と整合性がなくてはなりません。第２引数として文字列<code>&quot;Ten&quot;</code>、第３引数として数<code>10</code>を渡したのはそれが理由です。もし引数が逆になっているとうまくいかないでしょう。</p>
<pre class="text"><code>&gt; flip (\n s -&gt; show n ++ s) 10 &quot;Ten&quot;

Error in value 10:
Value does not have type Prim.String</code></pre>
<h2 id="字下げについての注意"><span class="header-section-number">3.5</span> 字下げについての注意</h2>
<p>JavaScriptとは異なり、PureScriptのコードは字下げの大きさに影響されます(indentation-sensitive)。これはHaskellと同じようになっています。コード内の空白の多寡は無意味ではなく、Cのような言語で中括弧によってコードのまとまりを示しているように、PureScriptでは空白がコードのまとまりを示すのに使われているということです。</p>
<p>宣言が複数行にわたる場合は、２つめの行は最初の行の字下げより深く字下げしなければなりません。</p>
<p>したがって、次は正しいPureScriptコードです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">add x y z <span class="fu">=</span> x <span class="fu">+</span>
  y <span class="fu">+</span> z</code></pre>
<p>しかし、次は正しいコードではありません。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">add x y z <span class="fu">=</span> x <span class="fu">+</span>
y <span class="fu">+</span> z</code></pre>
<p>後者では、PureScriptコンパイラはそれぞれの行ごとにひとつ、つまり<strong>2つ</strong>の宣言であると構文解析します。</p>
<p>一般に、同じブロック内で定義された宣言は同じ深さで字下げする必要があります。例えば<code>psci</code>でlet文の宣言は同じ深さで字下げしなければなりません。次は正しいコードです。</p>
<pre class="text"><code>&gt; let x = 1
      y = 2</code></pre>
<p>しかし、これは正しくありません。</p>
<pre class="text"><code>&gt; let x = 1
       y = 2</code></pre>
<p>PureScriptのいくつかの予約語（例えば <code>where</code>や<code>of</code>、<code>let</code>）は新たなコードのまとまりを導入しますが、そのコードのまとまり内の宣言はそれより深く字下げされている必要があります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">example x y z <span class="fu">=</span> foo <span class="fu">+</span> bar
  <span class="kw">where</span>
  foo <span class="fu">=</span> x <span class="fu">*</span> y
  bar <span class="fu">=</span> y <span class="fu">*</span> z</code></pre>
<p>ここで<code>foo</code>や<code>bar</code>の宣言は<code>example</code> の宣言より深く字下げされていることに注意してください。</p>
<p>ただし、ソースファイルの先頭、最初の <code>module</code>宣言における予約語<code>where</code>だけは、この規則の唯一の例外になっています。</p>
<h2 id="独自の型の定義"><span class="header-section-number">3.6</span> 独自の型の定義</h2>
<p>PureScriptで新たな問題に取り組むときは、まずはこれから扱おうとする値の型の定義を書くことから始めるのがよいでしょう。最初に、電話帳に含まれるレコードの型を定義してみます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Entry</span> <span class="fu">=</span> {<span class="ot"> firstName ::</span> <span class="dt">String</span>,<span class="ot"> lastName ::</span> <span class="dt">String</span>,<span class="ot"> phone ::</span> <span class="dt">String</span> }</code></pre>
<p>これは<code>Entry</code>という<strong>型同義語</strong>(type synonym、型シノニム)を定義しています。 型<code>Entry</code>は等号の右辺と同じ型ということです。レコードの型はいずれも文字列である<code>firstName</code>、<code>lastName</code>、<code>phone</code>という３つのフィールドからなります。</p>
<p>それでは、２つめの型別名も定義してみましょう。電話帳のデータ構造として、単に項目の連結リストとして格納することにします。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">PhoneBook</span> <span class="fu">=</span> <span class="dt">List</span> <span class="dt">Entry</span></code></pre>
<p><code>List Entry</code>は<code>[Entry]</code>とは同じではないということに注意してください。<code>[Entry]</code>は電話帳の項目の<strong>配列</strong>を意味しています。</p>
<h2 id="型構築子と種"><span class="header-section-number">3.7</span> 型構築子と種</h2>
<p><code>List</code>は<strong>型構築子</strong>(type constructor、型コンストラクタ)の一例になっています。<code>List</code>そのものは型ではなく、何らかの型<code>a</code>があるとき<code>List a</code>が型になっています。つまり、 <code>List</code>は<strong>型引数</strong>(type argument) <code>a</code>をとり、新たな型<code>List a</code>を構築するのです。</p>
<p>ちょうど関数適用と同じように、型構築子は他の型に並べることで適用されることに注意してください。型<code>List　Entry</code>は実は型構築子<code>List</code>が型<code>Entry</code>に<strong>適用</strong>されたものです。これは電話帳項目のリストを表しています。</p>
<p>(型注釈演算子 <code>::</code> を使って)もし型<code>List</code>の値を間違って定義しようとすると、今まで見たことのないような種類のエラーが表示されるでしょう。</p>
<pre class="text"><code>&gt; :i Data.List
&gt; Nil :: List
Expected type of kind *, was * -&gt; *</code></pre>
<p>これは<strong>種エラー</strong>(kind error)です。値がその<strong>型</strong>で区別されるのと同じように、型はその<strong>種</strong>(kind)によって区別され、間違った型の値が<strong>型エラー</strong>になるように、<strong>間違った種</strong>の型は種エラーを引き起こします。</p>
<p><code>Number</code>や<code>String</code>のような、値を持つすべての型の種を表す <code>*</code>と呼ばれる特別な種があります。</p>
<p>型構築子にも種があります。たとえば、種 <code>* -&gt; *</code>はちょうど<code>List</code>のような型から型への関数を表しています。ここでエラーが発生したのは、値が種 <code>*</code>であるような型を持つと期待されていたのに、<code>List</code>は種 <code>* -&gt; *</code>を持っているためです。</p>
<p><code>psci</code>で型の種を調べるには、<code>:k</code>命令を使用します。例えば次のようになります。</p>
<pre class="text"><code>&gt; :k Number
*

&gt; :i Data.List
&gt; :k List
* -&gt; *

&gt; :k List String
*</code></pre>
<p>PureScriptの<strong>種システム</strong>は他にも面白い種に対応していますが、それらについては本書の他の部分で見ていくことになるでしょう。</p>
<h2 id="電話帳の項目の表示"><span class="header-section-number">3.8</span> 電話帳の項目の表示</h2>
<p>それでは最初に、文字列で電話帳の項目を表現するような関数を書いてみましょう。まずは関数に型を与えることから始めます。型の定義は省略することも可能ですが、ドキュメントとしても役立つので型を書いておくようにすると良いでしょう。型宣言は関数の名前とその型を<code>::</code>記号で区切るようにして書きます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">showEntry ::</span> <span class="dt">Entry</span> <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre>
<p><code>showEntry</code>は引数として<code>Entry</code>を取り <code>string</code>を返す関数であるということを、この型シグネチャは言っています。 <code>showEntry</code>の定義は次のとおりです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">showEntry entry <span class="fu">=</span> entry<span class="fu">.</span>lastName <span class="fu">++</span> <span class="st">&quot;, &quot;</span> <span class="fu">++</span> 
                  entry<span class="fu">.</span>firstName <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> 
                  entry<span class="fu">.</span>phone</code></pre>
<p>この関数は<code>Entry</code>レコードの３つのフィールドを連結し、単一の文字列にします。</p>
<p>関数定義は関数の名前で始まり、引数名のリストが続きます。関数の結果は等号の後ろに定義します。フィールドはドットに続けてフィールド名を書くことで参照することができます。PureScriptでは、文字列連結はJavaScriptのような単一のプラス記号ではなく、ダブルプラス演算子（<code>++</code>）を使用します。</p>
<h2 id="はやめにテストたびたびテスト"><span class="header-section-number">3.9</span> はやめにテスト、たびたびテスト</h2>
<p><code>psci</code> 対話式処理系では反応を即座に得られるので、試行錯誤を繰り返したいときに向いています。それではこの最初の関数が正しく動作するかを<code>psci</code>を使用して確認してみましょう。</p>
<p>まず、これまで書かれたコードをビルドします。</p>
<pre class="text"><code>$ grunt</code></pre>
<p>次に、<code>psci</code>を起動し、この新しいモジュールをインポートするために<code>:i</code>命令を使います。</p>
<pre class="text"><code>$ psci

&gt; :i Data.PhoneBook</code></pre>
<p>レコードリテラルを使うと、電話帳の項目を作成することができます。レコードリテラルはJavaScriptの無名オブジェクトと同じような構文です。これを<code>let</code>式で名前に束縛します。</p>
<pre class="text"><code>&gt; let example = { firstName: &quot;John&quot;, lastName: &quot;Smith&quot;, phone: &quot;555-555-5555&quot; }</code></pre>
<p>（Ctrl+ Dで式をを終了することを忘れないようにしましょう）​​。それでは、この関数を<code>example</code>に適用してみてください。</p>
<pre class="text"><code>&gt; showEntry example

&quot;Smith, John: 555-555-5555&quot;</code></pre>
<p>おめでとうございます！PureScriptで初めて関数を書き、それを実行することができました。</p>
<h2 id="電話帳の作成"><span class="header-section-number">3.10</span> 電話帳の作成</h2>
<p>今度は電話帳の操作を支援する関数をいくつか書いてみましょう。空の電話帳を表す値として、空のリストを使います。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">emptyBook ::</span> <span class="dt">PhoneBook</span>
emptyBook <span class="fu">=</span> empty</code></pre>
<p>既存の電話帳に値を挿入する関数も必要でしょう。この関数を <code>insertEntry</code>と呼ぶことにします。関数の型を与えることから始めましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insertEntry ::</span> <span class="dt">Entry</span> <span class="ot">-&gt;</span> <span class="dt">PhoneBook</span> <span class="ot">-&gt;</span> <span class="dt">PhoneBook</span></code></pre>
<p><code>insertEntry</code>は、最初の引数として<code>Entry</code>、第二引数として<code>PhoneBook</code>を取り、新しい<code>PhoneBook</code>を返すということを、この型シグネチャは言っています。</p>
<p>既存の <code>PhoneBook</code>を直接変更することはしません。その代わりに、同じデータが含まれている新しい <code>PhoneBook</code>を返すようにします。このように、 <code>PhoneBook</code>は<strong>永続データ構造</strong>(persistent data structure)の一例となっています。これはPureScriptにおける重要な考え方です。変更はコードの副作用であり、コードの振る舞いについての判断するのを難しくします。そのため、我々は可能な限り純粋な関数や不変のデータを好むのです。</p>
<p><code>Data.List</code>の<code>Cons</code>関数を使用すると<code>insertEntry</code>を実装できます。<code>psci</code>を起動し<code>:t</code>コマンドを使って、この関数の型を見てみましょう。</p>
<pre class="text"><code>$ psci

&gt; :t Data.List.Cons

forall a. a -&gt; List a -&gt; List a</code></pre>
<p><code>Cons</code>は、なんらかの型<code>a</code>の値と、型 <code>a</code>を要素に持つリストを引数にとり、同じ型の要素を持つ新しいリストを返すということを、この型シグネチャは言っています。<code>a</code>を<code>Entry</code>型として特殊化してみましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Entry</span> <span class="ot">-&gt;</span> <span class="dt">List</span> <span class="dt">Entry</span> <span class="ot">-&gt;</span> <span class="dt">List</span> <span class="dt">Entry</span></code></pre>
<p>しかし、 <code>List Entry</code> はまさに<code>PhoneBook</code>ですから、次と同じになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Entry</span> <span class="ot">-&gt;</span> <span class="dt">PhoneBook</span> <span class="ot">-&gt;</span> <span class="dt">PhoneBook</span></code></pre>
<p>今回の場合、すでに適切な入力があります。 <code>Entry</code>、と<code>PhoneBook</code>に <code>Cons</code>を適用すると、新しい<code>PhoneBook</code>を得ることができます。これこそまさに私たちが求めていた関数です！</p>
<p><code>insertEntry</code>の実装は次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">insertEntry entry book <span class="fu">=</span> <span class="dt">Cons</span> entry book</code></pre>
<p>等号の左側にある２つの引数 <code>entry</code>と<code>book</code>がスコープに導入されますから、これらに <code>Cons</code>関数を適用して結果の値を作成しています。</p>
<h2 id="カリー化された関数"><span class="header-section-number">3.11</span> カリー化された関数</h2>
<p>PureScriptでは、関数は常にひとつの引数だけを取ります。<code>insertEntry</code>関数は２つの引数を取るように見えますが、これは実際には<strong>カリー化された関数</strong>(curried function)の一例となっています。</p>
<p><code>insertEntry</code>の型に含まれる <code>-&gt;</code> は右結合の演算子であり、つまりこの型はコンパイラによって次のように解釈されます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Entry</span> <span class="ot">-&gt;</span> (<span class="dt">PhoneBook</span> <span class="ot">-&gt;</span> <span class="dt">PhoneBook</span>)</code></pre>
<p>すなわち、<code>insertEntry</code>は関数を返す関数である、ということです！この関数は単一の引数 <code>Entry</code>を取り、それから単一の引数<code>PhoneBook</code>を取り新しい <code>PhoneBook</code>を返す新しい関数を返すのです。</p>
<p>これは例えば、最初の引数だけを与えると<code>insertEntry</code>を<strong>部分適用</strong>(partial application)できることを意味します。<code>psci</code>でこの結果の型を見てみましょう。</p>
<pre class="text"><code>&gt; :t insertEntry example

PhoneBook -&gt; PhoneBook</code></pre>
<p>期待したとおり、戻り値の型は関数になっていました。この結果の関数に、ふたつめの引数を適用することもできます。</p>
<pre class="text"><code>&gt; :t (insertEntry example) emptyBook
PhoneBook</code></pre>
<p>ここで括弧は不要であることにも注意してください。次の式は同等です。</p>
<pre class="text"><code>&gt; :t insertEntry example emptyBook
PhoneBook</code></pre>
<p>これは関数適用が左結合であるためで、なぜ単に空白で区切るだけで関数に引数を与えることができるのかも説明にもなっています。</p>
<p>本書では今後、「２引数の関数」というように表現することがあることに注意してください。これはあくまで、最初の引数を取り別の関数を返す、カリー化された関数を意味していると考えてください。</p>
<p>今度は<code>insertEntry</code> の定義について考えてみます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insertEntry ::</span> <span class="dt">Entry</span> <span class="ot">-&gt;</span> <span class="dt">PhoneBook</span> <span class="ot">-&gt;</span> <span class="dt">PhoneBook</span>
insertEntry entry book <span class="fu">=</span> <span class="dt">Cons</span> entry book</code></pre>
<p>もし式の右辺に明示的に括弧をつけるなら、 <code>（Cons entry）book</code> となります。<code>insertEntry entry</code> はその引数が単に関数<code>(Cons entry)</code>に渡されるような関数だということです。この2つの関数はどんな入力についても同じ結果を返しますから、つまりこれらは同じ関数です！よって、両辺から引数 <code>book</code>を削除できます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insertEntry ::</span> <span class="dt">Entry</span> <span class="ot">-&gt;</span> <span class="dt">PhoneBook</span> <span class="ot">-&gt;</span> <span class="dt">PhoneBook</span>
insertEntry entry <span class="fu">=</span> <span class="dt">Cons</span> entry</code></pre>
<p>そして、同様の理由で両辺から<code>entry</code> も削除することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insertEntry ::</span> <span class="dt">Entry</span> <span class="ot">-&gt;</span> <span class="dt">PhoneBook</span> <span class="ot">-&gt;</span> <span class="dt">PhoneBook</span>
insertEntry <span class="fu">=</span> <span class="dt">Cons</span></code></pre>
<p>この処理は<strong>イータ変換</strong>(eta conversion)と呼ばれ、引数を参照することなく関数を定義する<strong>ポイントフリー形式</strong>(point-free form)へと関数を書き換えるのに使うことができます。</p>
<p><code>insertEntry</code>の場合には、イータ変換によって「<code>insertEntry</code>は単にリストに対する<code>cons</code>だ」と関数の定義はとても明確になりました。しかしながら、常にポイントフリー形式のほうがいいのかどうかには議論の余地があります。</p>
<h2 id="あなたの電話番号は"><span class="header-section-number">3.12</span> あなたの電話番号は？</h2>
<p>最小限の電話帳アプリケーションの実装で必要になる最後の関数は、名前で人を検索し適切な<code>Entry</code>を返すものです。これは小さな関数を組み合わせることでプログラムを構築するという、関数型プログラミングで鍵となる考え方のよい応用例になるでしょう。</p>
<p>まずは電話帳をフィルタリングし、該当する姓名を持つ項目だけを保持するようにするのがいいでしょう。それから、結果のリストの先頭の(head)要素を返すだけです。</p>
<p>この大まかな仕様に従って、この関数の型を計算することができます。まず <code>psci</code>を起動し、<code>filter</code>関数と<code>head</code>関数の型を見てみましょう。</p>
<pre class="text"><code>$ psci

&gt; :t Data.List.filter

forall a. (a -&gt; Boolean) -&gt; List a -&gt; List a

:t Data.List.head

forall a. List a -&gt; Maybe a</code></pre>
<p>型の意味を理解するために、これらの2つの型の一部を取り出してみましょう。</p>
<p><code>filter</code>はカリー化された２引数の関数です。最初の引数は、リストの要素を取り<code>Boolean</code>値を結果として返す関数です。第２引数は要素のリストで、返り値は別のリストです。</p>
<p><code>head</code>は引数としてリストをとり、<code>Maybe a</code>という今まで見たことがないような型を返します。<code>Maybe a</code>は型<code>a</code>のオプショナルな値、つまり<code>a</code>の値を持つか持たないかのどちらかの値を示しており、JavaScriptのような言語で値がないことを示すために使われる<code>null</code>の型安全な代替手段を提供します。これについては後の章で詳しく扱います。</p>
<p><code>filter</code>と<code>head</code>の全称量化された型は、PureScriptコンパイラによって次のように<strong>特殊化</strong>されます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">filter<span class="ot"> ::</span> (<span class="dt">Entry</span> <span class="ot">-&gt;</span> <span class="dt">Boolean</span>) <span class="ot">-&gt;</span> <span class="dt">PhoneBook</span> <span class="ot">-&gt;</span> <span class="dt">PhoneBook</span>

head<span class="ot"> ::</span> <span class="dt">PhoneBook</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Entry</span></code></pre>
<p>検索する関数の引数として姓と名前をを渡す必要があるのもわかっています。</p>
<p><code>filter</code>に渡す関数も必要になることもわかります。この関数を <code>filterEntry</code>と呼ぶことにしましょう。<code>filterEntry</code>は<code>Entry -&gt; Boolean</code>という型を持っています。<code>filter filterEntry</code>という関数適用の式は、<code>PhoneBook -&gt; PhoneBook</code>という型を持つでしょう。もしこの関数の結果を<code>head</code>関数に渡すと、型<code>Maybe Entry</code>の結果を得ることになります。</p>
<p>これまでのことをまとめると、この<code>findEntry</code>関数の妥当な型シグネチャは次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">findEntry ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">PhoneBook</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Entry</span></code></pre>
<p><code>findEntry</code> は、姓と名前の2つの文字列、および<code>PhoneBook</code>を引数にとり、<code>Maybe Entry</code>という型の値を結果として返すということを、この型シグネチャは言っています。結果の<code>Maybe Entry</code>という型は、名前が電話帳で発見された場合にのみ<code>Entry</code>の値を持ちます。</p>
<p>そして、<code>findEntry</code> の定義は次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">findEntry firstName lastName book <span class="fu">=</span> head <span class="fu">$</span> filter filterEntry book
  <span class="kw">where</span>
<span class="ot">  filterEntry ::</span> <span class="dt">Entry</span> <span class="ot">-&gt;</span> <span class="dt">Boolean</span>
  filterEntry entry <span class="fu">=</span> entry<span class="fu">.</span>firstName <span class="fu">==</span> firstName <span class="fu">&amp;&amp;</span> entry<span class="fu">.</span>lastName <span class="fu">==</span> lastName</code></pre>
<p>一歩づつこのコードの動きを調べてみましょう。</p>
<p><code>findEntry</code>は、どちらも文字列型である<code>firstName</code>と<code>lastName</code>、<code>PhoneBook</code>型の<code>book</code>という3つの名前をスコープに導入します</p>
<p>定義の右辺では<code>filter</code>関数と<code>head</code>関数が組み合わされています。まず項目のリストをフィルタリングし、その結果に<code>head</code>関数を適用しています。</p>
<p>真偽型を返す関数 <code>filterEntry</code>は<code>where</code>節の内部で補助的な関数として定義されています。このため、 <code>filterEntry</code>関数はこの定義の内部では使用できますが、外部では使用することができません。また、<code>filterEntry</code>はそれを包む関数の引数に依存することができ、<code>filterEntry</code>は指定された<code>Entry</code>をフィルタリングするために引数 <code>firstName</code>と<code>lastName</code>を使用しているので、<code>filterEntry</code>が<code>findEntry</code>の内部にあることは必須になっています。</p>
<p>最上位での宣言と同じように、必ずしも<code>filterEntry</code>の型シグネチャを指定しなくてもよいことに注意してください。ただし、ドキュメントとしても役に立つので型シグネチャを書くことは推奨されています。</p>
<h2 id="中置の関数適用"><span class="header-section-number">3.13</span> 中置の関数適用</h2>
<p>上でみた <code>findEntry</code>のコードでは、少し異なる形式の関数適用が使用されています。<code>head</code>関数は中置の <code>$</code>演算子を使って式 <code>filter filterEntry book</code>に適用されています。</p>
<p>これは<code>head (filter filterEntry book)</code>という通常の関数適用と同じ意味です。</p>
<p><code>($)</code>はPreludeで定義されている通常の関数です。<code>($)</code>は次のように定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">($) ::</span> forall a b<span class="fu">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b
(<span class="fu">$</span>) f x <span class="fu">=</span> f x</code></pre>
<p>つまり、 <code>($)</code>は関数と値をとり、その値にその関数を適用します。</p>
<p>しかし、なぜ通常の関数適用の代わりに <code>$</code>を使ったのでしょうか？その理由は <code>$</code>は右結合で優先順位の低い演算子だということにあります。これは、深い入れ子になった関数適用のための括弧を、<code>$</code>を使うと取り除くことができることを意味します。</p>
<p>たとえば、ある従業員の上司の住所がある道路を見つける、次の入れ子になった関数適用を考えてみましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">street (address (boss employee))</code></pre>
<p>これは<code>$</code>を使用して表現すればずっと簡単になります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">street <span class="fu">$</span> address <span class="fu">$</span> boss employee</code></pre>
<h2 id="関数合成"><span class="header-section-number">3.14</span> 関数合成</h2>
<p>イータ変換を使うと <code>insertEntry</code>関数を簡略化できたのと同じように、引数をよく考察すると<code>findEntry</code>の定義を簡略化することができます。</p>
<p>引数<code>book</code>が関数<code>filter filterEntry</code>に渡され、この適用の結果が <code>head</code>に渡されることに注目してください。これは言いかたを変えれば、<code>filter filterEntry</code>と<code>head</code>の<strong>合成</strong>(composition) に<code>book</code>は渡されるということです。</p>
<p>PureScriptの関数合成演算子は <code>&lt;&lt;&lt;</code>と <code>&gt;&gt;&gt;</code>です。前者は「逆方向の合成」であり、後者は「順方向の合成」です。</p>
<p>いずれかの演算子を使用して <code>findEntry</code>の右辺を書き換えることができます。逆順の合成を使用すると、右辺は次のようになります。</p>
<pre><code>(head &lt;&lt;&lt; filter filterEntry) book</code></pre>
<p>この形式なら最初の定義にイータ変換の技を適用することができ、<code>findEntry</code> は最終的に次のような形式に到達します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">findEntry firstName lastName <span class="fu">=</span> head <span class="fu">&lt;&lt;&lt;</span> filter filterEntry
  <span class="kw">where</span>
  <span class="fu">...</span></code></pre>
<p>右辺を次のようにしても同じです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">filter filterEntry <span class="fu">&gt;&gt;&gt;</span> head</code></pre>
<p>どちらにしても、これは「 <code>findEntry</code>はフィルタリング関数と<code>head</code>関数の合成である」という <code>findEntry</code>関数のわかりやすい定義を与えます。</p>
<p>どちらの定義のほうがわかりやすいかの判断はお任せしますが、このように関数を部品として捉え、関数はひとつの役目だけをこなし、機能を関数合成で組み立てるというように考えると有用なことがよくあります。</p>
<h2 id="テストテストテスト"><span class="header-section-number">3.15</span> テスト、テスト、テスト……</h2>
<p>これでこのアプリケーションの中核部分が完成しましたので、 <code>psci</code>を使って試してみましょう。</p>
<pre class="text"><code>$ psci

&gt; :i Data.PhoneBook </code></pre>
<p>まずは空の電話帳から項目を検索してみましょう（これは明らかに空の結果が返ってくることが期待されます）。</p>
<pre class="text"><code>&gt; findEntry &quot;John&quot; &quot;Smith&quot; emptyBook

Error in declaration main
No instance found for Prelude.Show (Data.Maybe.Maybe Data.PhoneBook.Entry&lt;&gt;)</code></pre>
<p>エラーです！でも心配しないでください。これは単に 型<code>Entry</code>の値を文字列として出力する方法を<code>psci</code>が知らないという意味のエラーです。</p>
<p><code>findEntry</code>の返り値の型は <code>Maybe Entry</code>ですが、これは手作業で文字列に変換することができます。</p>
<p><code>showEntry</code>関数は<code>Entry</code>型の引数を期待していますが、今あるのは<code>Maybe Entry</code> 型の値です。この関数は<code>Entry</code> 型のオプショナルな値を返すことを忘れないでください。行う必要があるのは、オプショナルな値の中に項目の値が存在すれば <code>showEntry</code>関数を適用し、そうでなければ存在しないという値をそのまま伝播することです。</p>
<p>幸いなことに、Preludeモジュールはこれを行う方法を提供しています。<code>&lt;$&gt;</code>演算子は<code>Maybe</code> のような適切な型構築子まで関数を「持ち上げる」ことができます（この本の後半で関手について説明するときに、この関数やそれに類似する他のものについて詳しく見ていきます）。</p>
<pre class="text"><code>&gt; showEntry &lt;$&gt; findEntry &quot;John&quot; &quot;Smith&quot; emptyBook

Nothing</code></pre>
<p>今度はうまくいきました。この返り値 <code>Nothing</code>は、オプショナルな返り値に値が含まれていないことを示しています。期待していたとおりです。</p>
<p>もっと使いやすくするために、<code>Entry</code>を文字列として出力するような関数を定義し、毎回<code>showEntry</code>を使わなくてもいいようにすることもできます。</p>
<pre class="text"><code>&gt; let printEntry firstName lastName book = showEntry &lt;$&gt; findEntry firstName lastName book</code></pre>
<p>それでは空でない電話帳を作成してもう一度試してみましょう。先ほどの項目の例を再利用します。</p>
<pre class="text"><code>&gt; let john = { firstName: &quot;John&quot;, lastName: &quot;Smith&quot;, phone: &quot;555-555-5555&quot; }

&gt; let book1 = insertEntry john emptyBook

&gt; printEntry &quot;John&quot; &quot;Smith&quot; book1

Just (&quot;Smith, John: 555-555-5555&quot;)</code></pre>
<p>今度は結果が正しい値を含んでいました。<code>book1</code> に別の名前で項目を挿入して、ふたつの名前がある電話帳<code>book2</code>を定義し、それぞれの項目を名前で検索してみてください。</p>
<blockquote>
<h2 id="演習-1" class="unnumbered">演習　</h2>
<ol type="1">
<li><p>（簡単）<code>findEntry</code>関数の定義の主な部分式の型を書き下し、<code>findEntry</code>関数についてよく理解しているか試してみましょう。たとえば、<code>findEntry</code>の定義のなかにある<code>head</code>関数の型は<code>List Entry -&gt; Maybe Entry</code>と特殊化されています。</p></li>
<li><p>（簡単） <code>findEntry</code>の既存のコードを再利用し、与えられた電話番号から <code>Entry</code> を検索する関数を書いてみましょう。また、<code>psci</code> で実装した関数をテストしてみましょう。</p></li>
<li><p>（やや難しい） 指定された名前が<code>PhoneBook</code>に存在するかどうかを調べて真偽値で返す関数を書いてみましょう。<strong>ヒント</strong>： リストが空かどうかを調べる<code>Data.List.null</code>関数の型を<code>psci</code>で調べてみてみましょう。</p></li>
<li><p>（難しい） 姓名が重複している項目を電話帳から削除する関数 <code>removeDuplicates</code> を書いてみましょう。<strong>ヒント</strong>： 値どうしの等価性を定義する述語関数に基づいてリストから重複要素を削除する関数 <code>List.nubBy</code>の型を、<code>psci</code>を使用して調べてみましょう。</p></li>
</ol>
</blockquote>
<h2 id="まとめ-1"><span class="header-section-number">3.16</span> まとめ</h2>
<p>この章では、関数型プログラミングの新しい概念をいくつか導入しました。</p>
<ul>
<li>不変データ型と純粋な関数の重要性</li>
<li>対話的モード <code>psci</code>を使用して関数を調べたり思いついたことを試す方法</li>
<li>検証や実装の道具としての型の役割</li>
<li>多引数関数を表現する、カリー化された関数の使用</li>
<li>関数合成で小さな部品を組み合わせてのプログラムの構築</li>
<li><code>where</code>節を利用したコードの構造化</li>
<li><code>Maybe</code>型を使用してnull値を回避する方法</li>
<li>イータ変換や関数合成のような手法を利用した、よりわかりやすいコードへの再構成</li>
</ul>
<p>次の章からは、これらの考えかたに基づいて進めていきます。</p>
<h1 id="再帰マップ畳み込み"><span class="header-section-number">4</span> 再帰、マップ、畳み込み</h1>
<h2 id="この章の目標-2"><span class="header-section-number">4.1</span> この章の目標</h2>
<p>この章では再帰関数を使ってどのようにアルゴリズムを構造化するかについて見ていきましょう。再帰はこの本を通じて使用する関数型プログラミングの基本的な手法です。</p>
<p>また、PureScriptの標準ライブラリから標準的な関数をいくつか扱います。<code>map</code>や<code>fold</code>のような関数だけでなく、<code>filter</code>や<code>concatMap</code>といった便利で特殊なものについても見ていきます。</p>
<p>この章では仮想的なファイルシステムを操作する関数のライブラリを動機付けに用います。この章で学ぶ手法を応用して、模擬的なファイルシステムによって表されるファイルのプロパティを計算する関数を記述します。</p>
<h2 id="プロジェクトの準備-1"><span class="header-section-number">4.2</span> プロジェクトの準備</h2>
<p>この章のソースコードには、<code>src/Data/Path.purs</code>と<code>src/FileOperations.purs</code>という２つのファイルが含まれています。</p>
<p><code>Data.Path</code>モジュールには、仮想ファイルシステムが含まれています。このモジュールの内容を変更する必要はありません。</p>
<p><code>FileOperations</code>モジュールは、<code>Data.Path</code> APIを使用する関数が含まれています。演習への回答はこのファイルだけで完了することができます。</p>
<p>このプロジェクトには以下のBower依存関係があります。</p>
<ul>
<li><code>purescript-maybe</code>: <code>Maybe</code>型構築子が定義されています</li>
<li><code>purescript-arrays</code>: 配列を扱うための関数が定義されています</li>
<li><code>purescript-foldable-traversable</code>: 配列の畳み込みやその他のデータ構造に関する関数が定義されています</li>
</ul>
<h2 id="はじめに-1"><span class="header-section-number">4.3</span> はじめに</h2>
<p>再帰は一般のプログラミングでも重要な手法ですが、純粋関数型プログラミングでは特に当たり前のように用いられます。この章で見ていくように、再帰はプログラムの変更可能な状態を減らすために役立つからです。</p>
<p>再帰は<strong>分割統治</strong>(Divide and conquer)戦略と密接な関係があります。分割統治とはすなわち、いろいろな入力に対する問題を解決するために、入力を小さな部分に分割し、それぞれの部分について問題を解いて、部分ごとの答えから最終的な答えを組み立てるということです。</p>
<p>それでは、PureScriptにおける再帰の簡単な例をいくつか見てみましょう。</p>
<p>次は<strong>階乗関数</strong>(factorial function)のよくある例です。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fact ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span>
fact <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>
fact n <span class="fu">=</span> n <span class="fu">*</span> fact (n <span class="fu">-</span> <span class="dv">1</span>)</code></pre>
<p>部分問題へ問題を分割することによって階乗関数がどのように計算されるかがわかります。より小さい数へと階乗を計算していくということです。ゼロに到達すると答えは直ちに求まります。</p>
<p>次は<strong>フィボナッチ関数</strong>(Fibonnacci function)を計算するという、これまたよくある例です。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fib ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span>
fib <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>
fib <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span>
fib n <span class="fu">=</span> fib (n <span class="fu">-</span> <span class="dv">1</span>) <span class="fu">+</span> fib (n <span class="fu">-</span> <span class="dv">2</span>)</code></pre>
<p>やはり部分問題の解決策を考えることで全体を解決していることがわかります。この場合、<code>fib (n - 1)</code> と <code>fib (n - 2)</code>という式に対応した２つの部分問題があります。これらの２つの部分問題が解決されているときに、部分的な答えを加算することで答えを組み立てることができます。</p>
<h2 id="配列上での再帰"><span class="header-section-number">4.4</span> 配列上での再帰</h2>
<p>再帰関数の定義は、<code>Number</code>型だけに限定されるものではありません！本書の後半で<strong>パターン照合</strong>(pattern matching)を扱うときに、いろいろなデータ型の上での再帰関数について見ていきますが、今は数と配列に限っておきます。</p>
<p>入力がゼロでないかどうかについて分岐するのと同じように、配列の場合も、配列が空でないかどうかについて分岐していきます。再帰を使用して配列の長さを計算する次の関数を考えてみます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Array</span> (null)
<span class="kw">import </span><span class="dt">Data.Array.Unsafe</span> (tail)

length<span class="ot"> ::</span> forall a<span class="fu">.</span> [a] <span class="ot">-&gt;</span> <span class="dt">Number</span>
length arr <span class="fu">=</span> 
  <span class="kw">if</span> null arr
  <span class="kw">then</span> <span class="dv">0</span> 
  <span class="kw">else</span> <span class="dv">1</span> <span class="fu">+</span> length (tail arr)</code></pre>
<p>この関数では配列が空かどうかで分岐するために <code>if ... then ... else</code>式を使っています。この<code>null</code>関数は配列が空のときに<code>true</code>を返します。空の配列の長さはゼロであり、空でない配列の長さは配列の先頭を取り除いた残りの部分の長さより１大きいというわけです。</p>
<p>この例はJavaScriptで配列の長さを調べるのにはどうみても実用的な方法とはいえませんが、次の演習を完了するための手がかりとしては充分でしょう。</p>
<blockquote>
<h2 id="演習-2" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単) 入力が偶数であるとき、かつそのときに限り<code>true</code>に返すような再帰関数を書いてみましょう。</p></li>
<li><p>(少し難しい) 配列内の偶数の数を数える再帰関数を書いてみましょう。<strong>ヒント</strong>： <code>Data.Array.Unsafe</code>モジュールの <code>head</code>関数を使用します。</p></li>
</ol>
</blockquote>
<h2 id="マップ"><span class="header-section-number">4.5</span> マップ</h2>
<p><code>map</code>関数は配列に対する再帰関数のひとつです。これは、配列の各要素に順番に関数を適用することによって、配列の要素を変換するために使用されます。そのため、配列の<strong>内容</strong>は変更されますが、その<strong>形状</strong>(ここでは「長さ」)は保存されます。</p>
<p>本書で後ほど<strong>型クラス</strong>(type class)を扱うとき、形状を保存しながら型構築子のクラスを変換する<strong>関手</strong>(functor)と呼ばれる関数を紹介しますが、その時に<code>map</code>関数は関手の具体例であることがわかります。</p>
<p>それでは<code>psci</code>で <code>map</code>関数を試してみましょう。</p>
<pre class="text"><code>$ psci

&gt; :i Data.Array
&gt; map (\n -&gt; n + 1) [1, 2, 3, 4, 5]

[2, 3, 4, 5, 6]</code></pre>
<p><code>map</code>がどのように使われているかに注目してください。最初の引数には配列がどのように対応付けられるかを示す関数、第２引数には配列そのものを渡します。</p>
<h2 id="中置演算子"><span class="header-section-number">4.6</span> 中置演算子</h2>
<p>バッククォート(`)で関数名を囲むと、対応関係を表す関数と配列の間に<code>map</code>関数を書くことができます。</p>
<pre class="text"><code>&gt; (\n -&gt; n + 1) `map` [1, 2, 3, 4, 5]

[2, 3, 4, 5, 6]</code></pre>
<p>この構文は<strong>中置関数適用</strong>と呼ばれ、どんな関数でもこのように中置することができます。普通は2引数の関数に対して使うのが最も適切でしょう。</p>
<p>配列を扱うときは、<code>map</code>関数と等価な<code>&lt;$&gt;</code>という演算子が存在します。この演算子は他の二項演算子と同じように中置で使用することができます。</p>
<pre class="text"><code>&gt; (\n -&gt; n + 1) &lt;$&gt; [1, 2, 3, 4, 5]

[2, 3, 4, 5, 6]</code></pre>
<p><strong>注意</strong>：<code>&lt;$&gt;</code>の型は実際には<code>map</code>よりも一般的ですが、中置適用のほうが自然であるなら、<code>map</code>の代わりに<code>&lt;$&gt;</code>を使ってもたいていの場合は大丈夫です。</p>
<p>それでは<code>map</code> の型を見てみましょう。</p>
<pre class="text"><code>&gt; :t map
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</code></pre>
<p><code>map</code>関数に適用するときには<code>a</code>と<code>b</code>という２つの型を自由に選ぶことができると、この型は言っています。<code>a</code>は元の配列の要素の型で、<code>b</code>は目的の配列の要素の型です。もっと言えば、 <code>map</code>が配列要素の型を変化させても構わないということです。例えば、数値を文字列に変換するのにマップを使用することができます。</p>
<pre class="text"><code>&gt; show &lt;$&gt; [1, 2, 3, 4, 5]

[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]</code></pre>
<p>中置演算子 <code>&lt;$&gt;</code>は特別な構文のように見えるかもしれませんが、実際には普通のPureScript関数です。中置構文を使用した単なる<strong>適用</strong>にすぎません。実際、括弧でその名前を囲むと、この関数を通常の関数のように使用することができます。これは、配列に対する<code>map</code>の代わりに、括弧で囲まれた<code>(&lt;$&gt;)</code>という名前を使うことができるということです。</p>
<pre class="text"><code>&gt; (&lt;$&gt;) show [1, 2, 3, 4, 5]

[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]</code></pre>
<p>新しい中置演算子を定義するには、関数と同じ記法を使います。演算子名を括弧で囲み、あとは普通の関数のようにその中置演算子を定義します。たとえば、 <code>Data.Array</code>モジュールでは次のように<code>range</code>関数と同じ振る舞いの中置演算子 <code>(..)</code>を定義しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(..) ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> [<span class="dt">Number</span>]
(<span class="fu">..</span>) <span class="fu">=</span> range</code></pre>
<p>この演算子は次のように使うことができます。</p>
<pre class="text"><code>&gt; 1 .. 5

[1, 2, 3, 4, 5]

&gt; show &lt;$&gt; (1 .. 5)
  
[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]</code></pre>
<p><strong>注意</strong>： 独自の中置演算子は自然な構文を持った領域特化言語を定義するのに優れた手段になりえます。ただし、使用には充分注意してください。初心者が読めないコードになることがありますから、新たな演算子の定義には慎重になるのが賢明です。</p>
<p>上記の例では、<code>1 .. 5</code>という式は括弧で囲まれていましたが、実際にはこれは必要ありません。なぜなら、<code>Data.Array</code>モジュールは、 <code>&lt;$&gt;</code>に割り当てられた優先順位より 高い優先順位を<code>..</code> 演算子に割り当てているからです。PureScriptでは予約語<code>infix</code>を使用して独自の演算子に優先順位を割り当てる方法が提供されています。</p>
<pre class="text"><code>infix 5 ..</code></pre>
<p>ここでは<code>&lt;$&gt;</code>の優先順位よりも高い優先順位5を<code>(..)</code>に割り当てており、これはつまり括弧を付け加える必要がないということです。</p>
<pre class="text"><code>&gt; show &lt;$&gt; 1 .. 5
  
[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;]</code></pre>
<p>中置演算子に左結合性または右結合性を与えたい場合は、代わりに予約語 <code>infixl</code>と<code>infixr</code>を使います。</p>
<h2 id="配列のフィルタリング"><span class="header-section-number">4.7</span> 配列のフィルタリング</h2>
<p><code>Data.Array</code>モジュールでは他にも、<code>map</code>と同様によく使われる関数<code>filter</code>も提供しています。　この関数は、述語関数に適合する要素のみを残し、既存の配列から新しい配列を作成する機能を提供します。</p>
<p>たとえば、1から10までの数で、偶数であるような数の配列を計算したいとします。これは次のように行うことができます。</p>
<pre class="text"><code>&gt; :i Data.Array

&gt; filter (\n -&gt; n % 2 == 0) (1 .. 10)
[2,4,6,8,10]</code></pre>
<blockquote>
<h2 id="演習-3" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単) <code>map</code>関数や<code>&lt;$&gt;</code>関数を使用して、 配列に格納された数のそれぞれの平方を計算する関数を書いてみましょう。</p></li>
<li><p>(簡単) <code>filter</code>関数を使用して、数の配列から負の数を取り除く関数を書いてみましょう。</p></li>
<li><p>(やや難しい) <code>filter</code>関数と同じ意味の中置演算子<code>&lt;$?&gt;</code>を定義してみましょう。先ほどの演習の回答を、この新しい演算子を使用して書き換えてください。また、<code>psci</code>でこの演算子の優先順位と結合性を試してみてください。</p></li>
</ol>
</blockquote>
<h2 id="配列の平坦化"><span class="header-section-number">4.8</span> 配列の平坦化</h2>
<p><code>Data.Array</code>で定義されている配列に関する標準の関数としては、<code>concat</code>関数もあります。 <code>concat</code>は配列の配列をひとつの配列へと平坦化します。</p>
<pre class="text"><code>&gt; :i Data.Array
&gt; :t concat 

forall a. [[a]] -&gt; [a]

&gt; concat [[1, 2, 3], [4, 5], [6]]

[1, 2, 3, 4, 5, 6]</code></pre>
<p>関連する関数として、<code>concat</code>と<code>map</code>を組み合わせたような<code>concatMap</code>と呼ばれる関数もあります。<code>map</code>は(相異なる型も可能な)値からの値への関数を引数に取りますが、それに対して<code>concatMap</code>は値から値の配列の関数を取ります。</p>
<p>実際に動かして見てみましょう。</p>
<pre class="text"><code>&gt; :i Data.Array

&gt; :t concatMap
forall a b. (a -&gt; [b]) -&gt; [a] -&gt; [b]

&gt; concatMap (\n -&gt; [n, n * n]) (1 .. 5)
  
[1,1,2,4,3,9,4,16,5,25]</code></pre>
<p>ここでは、数をその数とその数の平方の２つの要素からなる配列に写す関数 <code>\n -&gt; [n, n * n]</code>を引数に<code>concatMap</code>を呼び出しています。結果は、1から5の数と、そのそれぞれの数の平方からなる、10個の数になります。</p>
<p><code>concatMap</code>がどのように結果を連結しているのかに注目してください。渡された関数を元の配列のそれぞれの要素について一度づつ呼び出し、その関数はそれぞれ配列を生成します。最後にそれらの配列を単一の配列に押し潰し、それが結果となります。</p>
<p><code>map</code>と<code>filter</code>、<code>concatMap</code>は、「配列内包表記」(array comprehensions)と呼ばれる配列に関するあらゆる関数の基盤を形成しています。</p>
<h2 id="配列内包表記"><span class="header-section-number">4.9</span> 配列内包表記</h2>
<p>数 <code>n</code> の２つの因数を見つけたいとしましょう。これを行うための簡単​​な方法のひとつとしては、総当りで行う方法があります。つまり、<code>1</code>から<code>n</code>の数のすべての組み合わせを生成し、それを乗算してみるわけです。もしその積が<code>n</code>なら、<code>n</code>の因数の組み合わせを見つけたということになります。</p>
<p>配列内包表記を使用すると、この計算を実行することができます。<code>psci</code>を対話式の開発環境として使用し、ひとつづつこの手順を進めていきましょう。</p>
<p><code>n</code>以下の数の組み合わせの配列を生成する最初の手順は、<code>concatMap</code>を使えば行うことができます。</p>
<p><code>1 .. n</code>のそれぞれの数を配列<code>1 .. n</code>へとマッピングすることから始めましょう。</p>
<pre class="text"><code>&gt; let pairs n = concatMap (\i -&gt; 1 .. n) (1 .. n)</code></pre>
<p>この関数をテストしてみましょう。</p>
<pre class="text"><code>&gt; pairs 3
[1,2,3,1,2,3,1,2,3]</code></pre>
<p>これは求めているものとはぜんぜん違います。単にそれぞれの組み合わせの２つ目の要素を返すのではなく、ペア全体を保持することができるように、内側の<code>1 .. n</code>の複製について関数をマッピングする必要があります。</p>
<pre class="text"><code>&gt; let pairs n = concatMap (\i -&gt; map (\j -&gt; [i, j]) (1 .. n)) (1 .. n)

&gt; pairs 3
[[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]</code></pre>
<p>いい感じになってきました。しかし、<code>[1, 2]</code> と <code>[2, 1]</code>の両方があるように、余計な組み合わせが生成されています。<code>j</code>を<code>i</code>から<code>n</code>の範囲に限定することで、２つ目の場合を取り除くことができます。</p>
<pre class="text"><code>&gt; let pairs n = concatMap (\i -&gt; map (\j -&gt; [i, j]) (i .. n)) (1 .. n)

&gt; pairs 3
[[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]</code></pre>
<p>すばらしい！因数の候補のすべての組み合わせを得たので、<code>filter</code>を使って、積が与えられた<code>n</code>であるような組み合わせを選択することができます。</p>
<pre class="text"><code>&gt; :i Data.Foldable

&gt; let factors n = filter (\pair -&gt; product pair == n) (pairs n)
  
&gt; factors 10
[[1,10],[2,5]]</code></pre>
<p>このコードでは、<code>purescript-foldable-traversable</code>ライブラリの<code>Data.Foldable</code>モジュールにある<code>product</code>関数を使っています。</p>
<p>うまくいきました！重複のなく、因数の組み合わせの正しい集合を見つけることができました。</p>
<h2 id="do記法"><span class="header-section-number">4.10</span> 　do記法</h2>
<p>機能は実現できましたが、このコードの可読性は大幅に向上することができます。<code>map</code>や<code>concatMap</code>はとても基本的な関数で、<strong>do記法</strong>(do notation)と呼ばれる特別な構文の基盤をなしています(もっと厳密にいえば、それらの一般化である<code>&lt;$&gt;</code>と<code>&gt;&gt;=</code>が基盤をなしています)。</p>
<p><strong>注意</strong>：<code>map</code>と<code>concatMap</code>が<strong>配列内包表記</strong>を書けるようにしているように、もっと一般的な演算子である<code>&lt;$&gt;</code>と <code>&gt;&gt;=</code>は<strong>モナド内包表記</strong>(monad comprehensions)と呼ばれているものを書けるようにします。本書の後半では<strong>モナド</strong>(monad)の例をたっぷり見ていくことになりますが、それはこの章ではありません。</p>
<p>do記法を使うと、先ほどの<code>factors</code>関数を次のように書き直すことができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">factors ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> [[<span class="dt">Number</span>]]
factors n <span class="fu">=</span> filter (\xs <span class="ot">-&gt;</span> product xs <span class="fu">==</span> n) <span class="fu">$</span> <span class="kw">do</span>
  i <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="fu">..</span> n
  j <span class="ot">&lt;-</span> i <span class="fu">..</span> n
  return [i, j]</code></pre>
<p>予約語 <code>do</code>はdo記法を使うコードのブロックを導入します。このブロックは幾つかの型の式で構成されています。</p>
<ul>
<li>配列の要素を名前に束縛する式。これは後方向きの矢印 <code>&lt;-</code>で 示されていて、その左側は名前、右側は配列の型を持つ式です。</li>
<li>名前に配列の要素を束縛しない式。最後の行の<code>return [i, j]</code>が、この種類の式の一例です。</li>
<li><code>let</code>キーワードを使用し、式に名前を与える式(ここでは使われていません)。</li>
</ul>
<p>この新しい記法を使うとアルゴリズムの構造がわかりやすくなることがあります。心のなかで<code>&lt;-</code>を「選ぶ」という単語に置き換えるとすると、「1からnの間の要素<code>i</code>を選び、それからiからnの間の要素<code>j</code>を選び、<code>[i, j]</code>を返す」というように読むことができるかもしれません。</p>
<p>最後の行の<code>return</code>関数は予約語では<strong>ない</strong>ことに注意してください。これは、他の関数と同様に<code>psci</code>で評価することができる、通常の関数です。ただし、<code>psci</code>で評価するには型を明示しなければなりません。</p>
<pre class="text"><code>&gt; return [1, 2] :: [[Number]]
[[1, 2]]</code></pre>
<p>配列の場合、<code>return</code>は単に１要素の配列を作成します。実際に、<code>return</code>の代わりにこの形式を使うように<code>factors</code>関数を変更することもできます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">factors ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> [[<span class="dt">Number</span>]]
factors n <span class="fu">=</span> filter (\xs <span class="ot">-&gt;</span> product xs <span class="fu">==</span> n) <span class="fu">$</span> <span class="kw">do</span>
  i <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="fu">..</span> n
  j <span class="ot">&lt;-</span> i <span class="fu">..</span> n
  [[i, j]]</code></pre>
<p>そして、結果は同じになります。</p>
<h2 id="ガード"><span class="header-section-number">4.11</span> ガード</h2>
<p><code>factors</code>関数を更に改良する方法としては、filterを配列内包表記の内側に移動するというものがあります。これは <code>purescript-control</code> ライブラリにある <code>Control.MonadPlus</code>モジュールの<code>guard</code>関数を使用することで可能になります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">factors ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> [[<span class="dt">Number</span>]]
factors n <span class="fu">=</span> <span class="kw">do</span>
  i <span class="ot">&lt;-</span> range <span class="dv">1</span> n
  j <span class="ot">&lt;-</span> range i n
  guard <span class="fu">$</span> i <span class="fu">*</span> j <span class="fu">==</span> n
  return [i, j]</code></pre>
<p><code>return</code>と同じように、<code>guard</code>関数は予約語<strong>ではありません</strong>。どのように動作するかを理解するために、 <code>psci</code>で通常の関数のように<code>guard</code>を適用してみましょう。</p>
<p><code>guard</code>関数の型は、ここで必要になる以上に一般的な型です。</p>
<pre class="text"><code>&gt; :i Control.MonadPlus
&gt; :t guard

forall m. (MonadPlus m) =&gt; Boolean -&gt; m Unit</code></pre>
<p>今回の場合は、<code>psci</code>は次の型を報告するものと考えてください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Boolean</span> <span class="ot">-&gt;</span> [<span class="dt">Unit</span>]</code></pre>
<p>次の計算の結果から、配列における<code>guard</code>関数について今知りたいことはすべてわかります。</p>
<pre class="text"><code>&gt; :i Data.Array
&gt; length $ guard true

1

&gt; length $ guard false
  
0</code></pre>
<p>つまり、 <code>guard</code>が<code>true</code>に評価される式を渡された場合、単一の要素を持つ配列を返すのです。もし式が <code>false</code>と評価された場合は、その結果は空です。</p>
<p>ガードが失敗した場合、配列内包表記の現在の分岐は、結果なしで早めに終了されることを意味します。これは、<code>guard</code> の呼び出しが、途中の配列に対して<code>filter</code>を使用するのと同じだということです。これらが同じ結果になることを確認するために、 <code>factors</code>の二つの定義を試してみてください。</p>
<blockquote>
<h2 id="演習-4" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単)<code>factors</code>関数を使用して、整数の引数が素数であるかどうかを調べる関数 <code>isPrime</code>を定義してみましょう。</p></li>
<li><p>(やや難しい)　2つの配列の<strong>直積集合</strong>を見つけるための関数を書いてみましょう。直積集合とはつまり、要素<code>a</code>、<code>b</code>のすべての組み合わせの集合です。ここで<code>a</code>は最初の配列の要素、<code>b</code>は２つ目の配列の要素です。</p></li>
<li><p>(やや難しい) <strong>ピタゴラスの三つ組数</strong>とは、<code>a² + b² = c²</code>を満たすような３つの数の配列 <code>[a, b, c]</code>のことです。配列内包表記の中で<code>guard</code>関数を使用して、数<code>n</code>を引数に取り、どの要素も<code>n</code>より小さいようなピタゴラスの三つ組数すべてを求める関数を書いてみましょう。その関数は<code>Number -&gt; [[Number]]</code>という型を持っていなければなりません。</p></li>
<li><p>(難しい) <code>Data.Foldable</code>から <code>any</code>関数を探しましょう。配列内包表記の代わりに<code>any</code>関数を使用して<code>factors</code>関数を書き換えてみましょう。<strong>注意</strong>：<code>psci</code> によって報告される<code>any</code>の型は、必要以上に一般的です。この演習での目的には、<code>any</code> の型は<code>forall a. (a -&gt; Boolean) -&gt; [a] -&gt; Boolean</code> であると考えることができます。</p></li>
<li><p>(鬼のように難しい)<code>factors</code>関数を使用して、数 <code>n</code>のすべての<strong>因数分解</strong>を求める関数<code>factorizations</code>を定義してみましょう。数<code>n</code>の因数分解とは、それらの積が<code>n</code>であるような整数の配列のことです。<strong>ヒント</strong>：１は因数ではないと考えてください。また、無限再帰に陥らないように注意しましょう。</p></li>
</ol>
</blockquote>
<h2 id="畳み込み"><span class="header-section-number">4.12</span> 畳み込み</h2>
<p>再帰を利用して実装される興味深い関数としては、配列に対する左畳込み(left fold)と右畳み込み(right fold)があります。</p>
<p><code>psci</code>を使って、<code>Data.Foldable</code>モジュールをインポートし、<code>foldl</code>と<code>foldr</code>関数の型を調べることから始めましょう。</p>
<pre class="text"><code>&gt; :i Data.Foldable

&gt; :t foldl
forall a b f. (Foldable f) =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b

&gt; :t foldr
forall a b f. (Foldable f) =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b</code></pre>
<p>これらの型は、現在興味があるものよりも一般的です。この章の目的では、 <code>psci</code>は以下の(より具体的な)答えを与えていたと考えておきましょう。</p>
<pre class="text"><code>&gt; :t foldl
forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b

&gt; :t foldr
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</code></pre>
<p>どちらの型でも、<code>a</code>は配列の要素の型に対応しています。型'b'は、配列を走査(traverse)したときの結果を蓄積する「累積器」(accumulator)の型だと考えることができます。</p>
<p><code>foldl</code>関数と<code>foldr</code>関数の違いは走査の方向です。 <code>foldr</code>が「右から」配列を畳み込むのに対して、<code>foldl</code>は「左から」配列を畳み込みます。</p>
<p>これらの関数の動きを見てみましょう。<code>foldl</code>を使用して数の配列の和を求めてみます。型 <code>a</code>は <code>Number</code>になり、結果の型<code>b</code>も<code>Number</code>として選択することができます。ここでは、次の要素を累積器に加算する<code>Number -&gt; Number -&gt; Number</code>という型の関数、<code>Number</code>型の累積器の初期値、和を求めたい<code>Number</code>の配列という、3つの引数を提供する必要があります。最初の引数としては、加算演算子を使用することができますし、累積器の初期値はゼロになります。</p>
<pre class="text"><code>&gt; foldl (+) 0 (1 .. 5)
15</code></pre>
<p>この場合では、引数が逆になっていても <code>(+)</code>関数は同じ結果を返すので、<code>foldl</code>と<code>foldr</code>のどちらでも問題ありません。</p>
<pre class="text"><code>&gt; foldr (+) 0 (1 .. 5)
15</code></pre>
<p><code>foldl</code>と<code>foldr</code>の違いを説明するために、畳み込み関数の選択が影響する例も書いてみましょう。加算関数の代わりに、文字列連結を使用して文字列を作ってみます。</p>
<pre class="text"><code>&gt; foldl (\acc n -&gt; acc ++ show n) &quot;&quot; [1,2,3,4,5]
&quot;12345&quot;

&gt; foldr (\n acc -&gt; acc ++ show n) &quot;&quot; [1,2,3,4,5]
&quot;54321&quot;</code></pre>
<p>これは、2つの関数の​​違いを示しています。左畳み込み式は、以下の関数適用と同等です。</p>
<pre class="text"><code>(((((&quot;&quot; ++ show 1) ++ show 2) ++ show 3) ++ show 4) ++ show 5)</code></pre>
<p>それに対し、右畳み込みは以下に相当します。</p>
<pre class="text"><code>(((((&quot;&quot; ++ show 5) ++ show 4) ++ show 3) ++ show 2) ++ show 1)</code></pre>
<h2 id="末尾再帰"><span class="header-section-number">4.13</span> 末尾再帰</h2>
<p>再帰はアルゴリズムを定義するための強力な手法ですが、問題も抱えています。入力が大きすぎる場合、JavaScriptで再帰関数を評価しようとするとスタックオーバーフローでエラーを起こす可能性があるのです。</p>
<p><code>psci</code>で次のコードを入力すると、この問題を簡単に検証できます。</p>
<pre class="text"><code>&gt; let f 0 = 0
      f n = 1 + f (n - 1)

&gt; f 10
10
  
&gt; f 10000
RangeError: Maximum call stack size exceeded</code></pre>
<p>これは問題です。関数型プログラミングの基本的な手法として再帰を採用しようとするなら、無限かもしれない再帰でも扱える方法が必要です。</p>
<p>PureScriptは<strong>末尾再帰最適化</strong>(tail recursion optimization)の形でこの問題に対する部分的な解決策を提供しています。</p>
<p><strong>注意</strong>：この問題へのより完全な解決策としては、いわゆる<strong>トランポリン</strong>(trampolining)を使用したライブラリで実装する方法がありますが、それはこの章で扱う範囲を超えています。</p>
<p>末尾再帰の最適化が可能かどうかには条件があります。<strong>末尾位置</strong>(tail position)にある関数の再帰的な呼び出しは、スタックフレームが確保されない<strong>ジャンプ</strong>に置き換えることができます。それが関数が戻るより前の最後の呼び出しであるとき、呼び出しは<strong>末尾位置</strong>にあるといいます。なぜこの例でスタックオーバーフローを観察したのかはこれが理由です。この<code>f</code>の再帰呼び出しは、末尾位置<strong>ではない</strong>からです。</p>
<p>実際には、PureScriptコンパイラは再帰呼び出しをジャンプに置き換えるのではなく、再帰的な関数全体を<strong>whileループ</strong>に置き換えます。</p>
<p>以下はすべての再帰呼び出しが末尾位置にある再帰関数の例です。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fact ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span>
fact <span class="dv">0</span> acc <span class="fu">=</span> acc
fact n acc <span class="fu">=</span> fact (n <span class="fu">-</span> <span class="dv">1</span>) (acc <span class="fu">*</span> n)</code></pre>
<p><code>fact</code>への再帰呼び出しは、この関数の中で起こる最後のものである、つまり末尾位置にあることに注意してください。</p>
<h2 id="累積器"><span class="header-section-number">4.14</span> 累積器</h2>
<p>末尾再帰ではない関数を末尾再帰関数に変える一般的な方法としては、<strong>累積器引数</strong>(accumulator parameter)を使用する方法があります。結果を累積するために返り値を使うと末尾再帰を妨げることがありますが、それとは対照的に累積器引数は返り値を<strong>累積</strong>する関数へ追加される付加的な引数です。</p>
<p>たとえば、入力配列を逆順にする、この配列の再帰を考えてみましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">reverse<span class="ot"> ::</span> forall a<span class="fu">.</span> [a] <span class="ot">-&gt;</span> [a]
reverse [] <span class="fu">=</span> []
reverse (x <span class="fu">:</span> xs) <span class="fu">=</span> reverse xs <span class="fu">++</span> [x]</code></pre>
<p>この実装は末尾再帰ではないので、大きな入力配列に対して実行されると、生成されたJavaScriptはスタックオーバーフローを発生させるでしょう。しかし、代わりに、結果を蓄積するための２つ目の引数を関数に導入することで、これを末尾再帰に変えることができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">reverse<span class="ot"> ::</span> forall a<span class="fu">.</span> [a] <span class="ot">-&gt;</span> [a]
reverse <span class="fu">=</span> reverse&#39; []
  <span class="kw">where</span>
  reverse&#39; acc [] <span class="fu">=</span> acc
  reverse&#39; acc (x <span class="fu">:</span> xs) <span class="fu">=</span> reverse&#39; (x <span class="fu">:</span> acc) xs</code></pre>
<p>ここでは、配列を逆転させる作業を補助関数 <code>reverse'</code>に委譲しています。関数 `reverse'が末尾再帰的であることに注目してください。 その唯一の再帰呼び出しは、最後の場合の末尾位置にあります。これは、生成されたコードが<strong>whileループ</strong>となり、大きな入力でもスタックが溢れないことを意味します。</p>
<p><code>reverse</code> のふたつめの実装を理解するためには、部分的に構築された結果を状態として扱うために、補助関数<code>reverse'</code>で累積器引数の使用することが必須であることに注意してください。結果は空の配列で始まりますが、入力配列の要素ひとつごとに、ひとつづつ大きくなっていきます。後の要素は配列の先頭に追加されるので、結果は元の配列の逆になります！</p>
<p>累積器を「状態」と考えることもできますが、直接に変更がされているわけではないことにも注意してください。この累積器は不変の配列であり、計算に沿って状態受け渡すために、単に関数の引数を使います。</p>
<h2 id="明示的な再帰より畳み込みを選ぶ"><span class="header-section-number">4.15</span> 明示的な再帰より畳み込みを選ぶ</h2>
<p>末尾再帰を使用して再帰関数を記述することができれば末尾再帰最適化の恩恵を受けることができるので、すべての関数をこの形で書こうとする誘惑にかられます。しかし、多くの関数は配列やそれに似たデータ構造に対する折り畳みとして直接書くことができることを忘れがちです。<code>map</code>や<code>fold</code>のようなコンビネータを使って直接アルゴリズムを書くことには、コードの単純さという利点があります。これらのコンビネータはよく知られており、アルゴリズムの<strong>意図</strong>をはっきりとさせるのです。</p>
<p>例えば、 先ほどの<code>reverse</code>の例は、畳み込みとして少なくとも2つの方法で書くことができます。<code>foldr</code>を使用すると次のようになります。</p>
<pre class="text"><code>&gt; :i Data.Foldable
&gt; let reverse :: forall a. [a] -&gt; [a]
      reverse = foldr (\x xs -&gt; xs ++ [x]) []
  
&gt; reverse [1, 2, 3]
  
[3,2,1]</code></pre>
<p><code>foldl</code> を使って <code>reverse</code>を書くことは、読者への課題として残しておきます。</p>
<blockquote>
<h2 id="演習-5" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単) <code>foldl</code>を使って、真偽値の配列の要素すべてが真かどうか調べてみてください。</p></li>
<li><p>(やや難しい) 関数 <code>foldl (==) false xs</code> が真を返すような配列<code>xs</code>とはどのようなものか説明してください。</p></li>
<li><p>(やや難しい) 累積器引数を使用して、次の関数を末尾再帰形に書きなおしてください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">count ::</span> forall a<span class="fu">.</span> (a <span class="ot">-&gt;</span> <span class="dt">Boolean</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Number</span>
count _ [] <span class="fu">=</span> <span class="dv">0</span>
count p (x <span class="fu">:</span> xs) <span class="fu">=</span> <span class="kw">if</span> p x <span class="kw">then</span> <span class="dv">1</span> <span class="fu">+</span> count p xs <span class="kw">else</span> count p xs</code></pre></li>
<li><p>(やや難しい) <code>foldl</code>を使って<code>reverse</code>を書いてみましょう。</p></li>
</ol>
</blockquote>
<h2 id="仮想ファイルシステム"><span class="header-section-number">4.16</span> 仮想ファイルシステム</h2>
<p>この節では、これまで学んだことを応用して、模擬的なファイルシステムで動作する関数を書いていきます。事前に定義されたAPIで動作するように、マップ、畳み込み、およびフィルタを使用します。</p>
<p><code>Data.Path</code>モジュールでは、次のように仮想ファイルシステムのAPIが定義されています。</p>
<ul>
<li>ファイルシステム内のパスを表す型<code>Path</code>があります。</li>
<li>ルートディレクトリを表すパス <code>root</code>があります。</li>
<li><code>ls</code>関数はディレクトリ内のファイルを列挙します。</li>
<li><code>filename</code>関数は<code>Path</code>のファイル名を返します。</li>
<li><code>size</code>関数は<code>Path</code>が示すファイルの大きさを返します。</li>
<li><code>isDirectory</code>関数はファイルかディレクトリかを調べます。</li>
</ul>
<p>型については、型定義は次のようになっています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">root ::</span> <span class="dt">Path</span>

<span class="ot">ls ::</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> [<span class="dt">Path</span>]

<span class="ot">filename ::</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> <span class="dt">String</span>

<span class="ot">size ::</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Number</span>

<span class="ot">isDirectory ::</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> <span class="dt">Boolean</span></code></pre>
<p><code>psci</code> でこのAPIを試してみましょう。</p>
<pre class="text"><code>&gt; :i Data.Path

&gt; root
/

&gt; isDirectory root
true

&gt; ls root
[/bin/,/etc/,/home/]</code></pre>
<p><code>FileOperations</code>モジュールでは、<code>Data.Path</code> APIを操作するための関数を定義されています。<code>Data.Path</code>モジュールを変更したり実装を理解する必要はありません。すべて<code>FileOperations</code>モジュールだけで作業を行います。</p>
<h2 id="すべてのファイルの一覧"><span class="header-section-number">4.17</span> すべてのファイルの一覧</h2>
<p>それでは、内側のディレクトリまで、すべてのファイルを列挙する関数を書いてみましょう。この関数は以下のような型を持つでしょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">allFiles ::</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> [<span class="dt">Path</span>]</code></pre>
<p>再帰を使うとこの関数を定義することができます。まずは<code>ls</code>を使用してディレクトリの直接の子を列挙します。それぞれの子について再帰的に<code>allFiles</code>を適用すると、それぞれパスの配列が返ってくるでしょう。<code>concatMap</code>を適用すると、この結果を同時に平坦化することができます。</p>
<p>最後に、<code>:</code> 演算子を使って現在のファイルも含めます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">allFiles file <span class="fu">=</span> file <span class="fu">:</span> concatMap allFiles (ls file)</code></pre>
<p>それでは<code>psci</code> でこの関数を試してみましょう。</p>
<pre class="text"><code>&gt; :i FileOperations
&gt; :i Data.Path

&gt; allFiles root
  
[/,/bin/,/bin/cp,/bin/ls,/bin/mv,/etc/,/etc/hosts, ...]</code></pre>
<p>すばらしい！do記法で配列内包表記を使ってもこの関数を書くことができるので見ていきましょう。</p>
<p>逆向きの矢印は配列から要素を選択するのに相当することを思い出してください。最初の手順は、引数の直接の子から要素を選択することです。それから、単にそのファイルに対してこの再帰関数を呼びします。do記法を使用しているので、再帰的な結果をすべて連結する<code>concatMap</code>が暗黙に呼び出されています。</p>
<p>新しいコードは次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">allFiles&#39; ::</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> [<span class="dt">Path</span>]
allFiles&#39; file <span class="fu">=</span> file <span class="fu">:</span> <span class="kw">do</span>
  child <span class="ot">&lt;-</span> ls file
  allFiles&#39; child</code></pre>
<p><code>psci</code> で新しいコードを試してみてください。同じ結果が返ってくるはずです。どちらのほうがわかりやすいかの選択はお任せします。</p>
<blockquote>
<h2 id="演習-6" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単) ディレクトリのすべてのサブディレクトリの中まで、ディレクトリを除くすべてのファイルを返すような関数<code>onlyFiles</code>を書いてみてください。</p></li>
<li><p>(やや難しい) このファイルシステムで最大と最小のファイルを決定するような畳込みを書いてください。</p></li>
<li><p>(難しい) ファイルを名前で検索する関数<code>whereIs</code>を書いてください。この関数は型<code>Maybe Path</code>の値を返すものとします。この値が存在するなら、そのファイルがそのディレクトリに含まれているということを表します。この関数は次のように振る舞う必要があります。</p>
<pre class="text"><code>&gt; whereIs &quot;/bin/ls&quot;
Just (/bin/)

&gt; whereIs &quot;/bin/cat&quot;
Nothing</code></pre>
<p><strong>ヒント</strong>：do記法で配列内包表記を使用して、この関数を記述してみてください。</p></li>
</ol>
</blockquote>
<h2 id="まとめ-2"><span class="header-section-number">4.18</span> まとめ</h2>
<p>この章では、アルゴリズムを簡潔に表現する手段として、PureScriptでの再帰の基本を説明しました。また、独自の中置演算子や、マップ、フィルタリングや畳み込みなどの配列に対する標準関数、およびこれらの概念を組み合わせた配列内包表記を導入しました。最後に、スタックオーバーフローエラーを回避するために末尾再帰を使用することの重要性、累積器引数を使用して末尾再帰形に関数を変換する方法を示しました。</p>
<h1 id="パターン照合"><span class="header-section-number">5</span> パターン照合</h1>
<h2 id="この章の目標-3"><span class="header-section-number">5.1</span> この章の目標</h2>
<p>この章では代数的データ型とパターン照合という2つの新しい概念を導入します。また、行多相というPureScriptの型システムの興味深い機能についても簡単に取り扱います。</p>
<p><strong>パターン照合</strong>(Pattern matching)は関数​​型プログラミングでは一般的な手法で、複数の場合に実装を分解することにより、開発者は潜在的に複雑な動作の関数を簡潔に書くことができます。</p>
<p>代数的データ型はPureScriptの型システムの機能で、パターン照合とも密接に関連しています。</p>
<p>この章の目的は、代数的データ型やパターン照合を使用して、単純なベクターグラフィックスを描画し操作するためのライブラリを書くことです。</p>
<h2 id="プロジェクトの準備-2"><span class="header-section-number">5.2</span> プロジェクトの準備</h2>
<p>この章のソースコードはファイル<code>src/data/Picture.purs</code>で定義されています。</p>
<p>このプロジェクトはこれまで見てきたBowerパッケージを引き続き使用しますが、それに加えて次の新しい依存関係が追加されます。</p>
<ul>
<li><code>purescript-globals</code>: 一般的なJavaScriptの値や関数の取り扱いを可能にします。</li>
<li><code>purescript-math</code>: JavaScriptの <code>Math</code>オブジェクトの関数群を利用可能にします。</li>
</ul>
<p><code>Data.Picture</code>モジュールは、簡単な図形を表すデータ型<code>Shape</code>や、図形の集合である型<code>Picture</code>、及びこれらの型を扱うための関数を定義しています。</p>
<p>このモジュールでは、データ構造の畳込みを行う関数を提供する<code>Data.Foldable</code>モジュールもインポートします。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Data.Picture</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Foldable</span></code></pre>
<h2 id="単純なパターン照合"><span class="header-section-number">5.3</span> 単純なパターン照合</h2>
<p>それではコード例を見ることから始めましょう。パターン照合を使用して2つの整数の最大公約数を計算する関数は、次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">gcd<span class="ot"> ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span>
gcd n <span class="dv">0</span> <span class="fu">=</span> n
gcd <span class="dv">0</span> m <span class="fu">=</span> m
gcd n m <span class="fu">=</span> <span class="kw">if</span> n <span class="fu">&gt;</span> m <span class="kw">then</span> gcd (n <span class="fu">-</span> m) m <span class="kw">else</span> gcd n (m <span class="fu">-</span> n)</code></pre>
<p>このアルゴリズムはユークリッドの互除法と呼ばれています。その定義をオンラインで検索すると、おそらく上記のコードによく似た数学の方程式が見つかるでしょう。パターン照合の利点のひとつは、上記のようにコードを場合分けして定義することができ、数学関数の定義と似たような簡潔で宣言型なコードを書くことができることです。</p>
<p>パターン照合を使用して書かれた関数は、条件と結果の組み合わせによって動作します。この定義の各行は<strong>選択肢</strong>(alternative)や<strong>場合</strong>(case)と呼ばれています。等号の左辺の式は<strong>パターン</strong>と呼ばれており、それぞれの場合は空白で区切られた1つ以上のパターンで構成されています。等号の右側の式が評価され値が返される前に引数が満たさなければならない条件について、これらの場合は説明しています。それぞれの場合は上からこの順番に試されていき、最初に入力に適合した場合が返り値を決定します。</p>
<p>たとえば、 <code>gcd</code>関数は次の手順で評価されます。</p>
<ul>
<li>まず最初の場合が試されます。第２引数がゼロの場合、関数は <code>n</code>（最初の引数）を返します。</li>
<li>そうでなければ、2番目の場合が試されます。最初の引数がゼロの場合、関数は <code>m</code>（第２引数）を返します。</li>
<li>それ以外の場合、関数は最後の行の式を評価して返します。</li>
</ul>
<p>パターンは値を名前に束縛することができることに注意してください。この例の各行では<code>n</code>という名前と<code>m</code>という名前の両方、またはどちらか一方に、入力された値を束縛しています。これより、入力の引数から名前を選ぶためのさまざまな方法に対応した、さまざまな種類のパターンを見ていくことになります。</p>
<h2 id="単純なパターン"><span class="header-section-number">5.4</span> 単純なパターン</h2>
<p>上記のコード例では、2種類のパターンを示しました。</p>
<ul>
<li><code>Number</code>型の値が正確に一致する場合にのみ適合する、数値リテラルパターン</li>
<li>引数を名前に束縛する、変数パターン</li>
</ul>
<p>単純なパターンには他にも種類があります。</p>
<ul>
<li>文字列リテラルと真偽リテラル</li>
<li>どんな引数とも適合するが名前に束縛はしない、アンダースコア（<code>_</code>）で表されるワイルドカードパターン</li>
</ul>
<p>ここではこれらの単純なパターンを使用した、さらに2つの例を示します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fromString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Boolean</span>
fromString <span class="st">&quot;true&quot;</span> <span class="fu">=</span> true
fromString _      <span class="fu">=</span> false

<span class="ot">toString ::</span> <span class="dt">Boolean</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
toString true  <span class="fu">=</span> <span class="st">&quot;true&quot;</span>
toString false <span class="fu">=</span> <span class="st">&quot;false&quot;</span></code></pre>
<p><code>psci</code>でこれらの関数を試してみてください。</p>
<h2 id="ガード-1"><span class="header-section-number">5.5</span> ガード</h2>
<p>ユークリッドの互除法の例では、<code>m &gt; n</code>のときと<code>m &lt;= n</code>のときの２つに分岐するために<code>if .. then .. else</code>式を使っていました。こういうときには他に<strong>ガード</strong>(guard)を使うという選択肢もあります。</p>
<p>ガードは真偽値の式で、パターンによる制約に加えてそのガードが満たされたときに、その場合の結果になります。ガードを使用してユークリッドの互除法を書き直すと、次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">gcd<span class="ot"> ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span>
gcd n <span class="dv">0</span> <span class="fu">=</span> n
gcd <span class="dv">0</span> n <span class="fu">=</span> n
gcd n m <span class="fu">|</span> n <span class="fu">&gt;</span> m <span class="fu">=</span> gcd (n <span class="fu">-</span> m) m 
gcd n m         <span class="fu">=</span> gcd n (m <span class="fu">-</span> n)</code></pre>
<p>３行目ではガードを使用して、最初の引数が第２引数よりも厳密に大きいという条件を付け加えています。</p>
<p>この例が示すように、ガードは等号の左側に現れ、パイプ文字（<code>|</code>）でパターンのリストと区切られています。</p>
<blockquote>
<h3 id="演習-7" class="unnumbered">演習</h3>
<ol type="1">
<li><p>（簡単）パターン照合を使用して階乗関数を書いてみましょう。<strong>ヒント</strong>:入力がゼロのときとゼロでないときの2つの場合を考えてみましょう。</p></li>
<li><p>（やや難しい）二項係数を計算するための<strong>パスカルの公式</strong>(Pascal's Rule、パスカルの三角形を参照のこと)について調べてみてください。パスカルの公式を利用し、パターン照合を使って二項係数を計算する関数を記述してください。</p></li>
</ol>
</blockquote>
<h2 id="配列のパターン照合"><span class="header-section-number">5.6</span> 配列のパターン照合</h2>
<p>パターンを使って配列を照合する方法を見ていきましょう。配列リテラルパターンとConsパターンという２種類のパターンがあります。</p>
<h3 id="配列リテラルパターン"><span class="header-section-number">5.6.1</span> 配列リテラルパターン</h3>
<p><strong>配列リテラルパターン</strong>(array literal patterns)は、固定長の配列を照合する方法を提供します。たとえば、空の配列であることを特定する関数 <code>isEmpty</code>を書きたいとします。最初の選択肢に空の配列パターン（<code>[]</code>）を用いるとこれを実現できます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isEmpty ::</span> forall a<span class="fu">.</span> [a] <span class="ot">-&gt;</span> <span class="dt">Boolean</span>
isEmpty [] <span class="fu">=</span> true
isEmpty _ <span class="fu">=</span> false</code></pre>
<p>次の関数では、長さ5の配列と適合し、配列の5つの要素をそれぞれ異なった方法で束縛しています。　　</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">takeFive ::</span> [<span class="dt">Number</span>] <span class="ot">-&gt;</span> <span class="dt">Number</span>
takeFive [<span class="dv">0</span>, <span class="dv">1</span>, a, b, _] <span class="fu">=</span> a <span class="fu">*</span> b
takeFive _ <span class="fu">=</span> <span class="dv">0</span></code></pre>
<p>最初のパターンは、第１要素と第２要素がそれぞれ0と1であるような、５要素の配列にのみ適合します。その場合、関数は第3要素と第4要素の積を返します。それ以外の場合は、関数は0を返します。<code>psci</code>で試してみると、たとえば次のようになります。</p>
<pre class="text"><code>&gt; let takeFive [0, 1, a, b, _] = a * b
      takeFive _ = 0
  
&gt; takeFive [0, 1, 2, 3, 4]
6

&gt; takeFive [1, 2, 3, 4, 5]
0

&gt; takeFive []
0</code></pre>
<h3 id="consパターン"><span class="header-section-number">5.6.2</span> Consパターン</h3>
<p><strong>Consパターン</strong>は空でない配列を照合するのに使います。配列の先頭の要素(head)と、配列から先頭を取り除いた残りの配列(tail)へと、配列を分離する方法を提供します。</p>
<p>Consパターンは、コロン(<code>:</code>)で区切られた、先頭に対応するパターンと残りに対応するパターンによって構成されています。数の配列の、それぞれの要素の平方を合計する関数は次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sumOfSquares ::</span> [<span class="dt">Number</span>] <span class="ot">-&gt;</span> <span class="dt">Number</span>
sumOfSquares [] <span class="fu">=</span> <span class="dv">0</span>
sumOfSquares (n <span class="fu">:</span> ns) <span class="fu">=</span> n <span class="fu">*</span> n <span class="fu">+</span> sumOfSquares ns</code></pre>
<p>この関数は入力を空の配列と空でない配列の２つの場合に分けて扱っています。配列が空の場合、平方の和はゼロです。そうでない場合は、Consパターンを使用して配列の先頭と残り​​を分離し、先頭の要素を平方し、残りの平方の和に加算しています。</p>
<p>別の例も見てみましょう。次の関数は、数のリスト内のすべての隣接する数の積の合計を求めます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sumOfProducts ::</span> [<span class="dt">Number</span>] <span class="ot">-&gt;</span> <span class="dt">Number</span>
sumOfProducts [] <span class="fu">=</span> <span class="dv">0</span>
sumOfProducts [_] <span class="fu">=</span> <span class="dv">0</span>
sumOfProducts (n <span class="fu">:</span> m <span class="fu">:</span> ns) <span class="fu">=</span> n <span class="fu">*</span> m <span class="fu">+</span> sumOfProducts (m <span class="fu">:</span> ns)</code></pre>
<p>この関数は入力をゼロ要素、１要素、２要素以上の3つの場合に分けています。最後の場合では、最初の2つの要素を乗算し、残りの部分について再帰します。</p>
<blockquote>
<h3 id="演習-8" class="unnumbered">演習</h3>
<ol type="1">
<li><p>（簡単）真偽値の配列のすべての要素が <code>true</code>に等しいかどうかを決定する関数<code>allTrue</code>を書いてみてください。</p></li>
<li><p>（やや難しい）数の配列がソートされているかどうかを調べる関数 <code>isSorted</code>を書いてください。</p></li>
</ol>
</blockquote>
<h2 id="レコードパターンと行多相"><span class="header-section-number">5.7</span> レコードパターンと行多相</h2>
<p><strong>レコードパターン</strong>(Record patterns)は(ご想像のとおり)レコードにマッチします。</p>
<p>レコードパターンはレコードリテラルに見た目が似ていますが、レコードリテラルでラベルと式を<strong>コロン</strong>で区切るのとは異なり、レコードパターンではラベルとパターンを<strong>等号</strong>で区切ります。</p>
<p>たとえば、次のパターンは <code>first</code>と<code>last</code>と呼ばれるフィールドが含まれた任意のレコードにマッチし、これらのフィールドの値はそれぞれ<code>x</code>と<code>y</code>という名前に束縛されます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">showPerson ::</span> {<span class="ot"> first ::</span> <span class="dt">String</span>,<span class="ot"> last ::</span> <span class="dt">String</span> } <span class="ot">-&gt;</span> <span class="dt">String</span>
showPerson { first <span class="fu">=</span> x, last <span class="fu">=</span> y } <span class="fu">=</span> y <span class="fu">++</span> <span class="st">&quot;, &quot;</span> <span class="fu">++</span> x</code></pre>
<p>レコードパターンはPureScriptの型システムの興味深い機能である<strong>行多相</strong>(row polymorphism)の良い例となっています。上の<code>showPerson</code>を型シグネチャなしで定義していたとします。この型はどのように推論されるのでしょうか？面白いことに、推論される型は上で与えた型とは同じではありません。</p>
<pre class="text"><code>&gt; let showPerson { first = x, last = y } = y ++ &quot;, &quot; ++ x

&gt; :t showPerson
forall r. { first :: String, last :: String | r } -&gt; String</code></pre>
<p>この型変数 <code>r</code>とは何でしょうか？<code>psci</code> <code>で</code>showPerson`を使ってみると、面白いことがわかります。</p>
<pre class="text"><code>&gt; showPerson { first: &quot;Phil&quot;, last: &quot;Freeman&quot; }
&quot;Freeman, Phil&quot;

&gt; showPerson { first: &quot;Phil&quot;, last: &quot;Freeman&quot;, location: &quot;Los Angeles&quot; }
&quot;Freeman, Phil&quot;</code></pre>
<p>レコードにそれ以外のフィールドが追加されていても、<code>showPerson</code>関数はそのまま動作するのです。型が<code>String</code>であるようなフィールド<code>first</code>と<code>last</code>がレコードに少なくとも含まれていれば、関数適用は正しく型付けされます。しかし、フィールドが<strong>不足</strong>していると、<code>showPerson</code>の呼び出しは<strong>不正</strong>となります。</p>
<pre class="text"><code>&gt; showPerson { first: &quot;Phil&quot; }

Object does not have property last</code></pre>
<p><code>showPerson</code>の推論された型シグネチャは、<code>String</code>であるような<code>first</code>と<code>last</code>というフィールドと、<strong>それ以外の任意のフィールドを</strong>持った任意のレコードを引数に取り、<code>String</code>を返す、というように読むことができます。</p>
<p>この関数はレコードフィールドの行<code>r</code>について多相的なので、行多相と呼ばれるわけです。</p>
<p>次のように書くことができることにも注意してください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">let</span> showPerson p <span class="fu">=</span> p<span class="fu">.</span>last <span class="fu">++</span> <span class="st">&quot;, &quot;</span> <span class="fu">++</span> p<span class="fu">.</span>first</code></pre>
<p>この場合も、<code>psci</code>は先ほどと同じ型を推論するでしょう。</p>
<p>後ほど<strong>拡張可能作用</strong>(Extensible effects)について議論するときに、再び行多相について見ていくことになります。</p>
<h2 id="入れ子になったパターン"><span class="header-section-number">5.8</span> 入れ子になったパターン</h2>
<p>配列パターンとレコードパターンはどちらも小さなパターンを組み合わせることで大きなパターンを構成しています。これまでの例では配列パターンとレコードパターンの内部に単純なパターンを使用していましたが、パターンが自由に<strong>入れ子</strong>にすることができることも知っておくのが大切です。入れ子になったパターンを使うと、潜在的に複雑なデータ型に対して関数が条件分岐できるようになります。</p>
<p>たとえば、次のコードでは、レコードパターンと配列パターンを組み合わせて、レコードの配列と照合させています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Person</span> <span class="fu">=</span> {<span class="ot"> height ::</span> <span class="dt">Number</span> }

<span class="ot">totalHeight ::</span> [<span class="dt">Person</span>] <span class="ot">-&gt;</span> <span class="dt">Number</span>
totalHeight [] <span class="fu">=</span> <span class="dv">0</span>
totalHeight ({ height <span class="fu">=</span> h } <span class="fu">:</span> ps) <span class="fu">=</span> h <span class="fu">+</span> totalHeight ps</code></pre>
<h2 id="名前付きパターン"><span class="header-section-number">5.9</span> 名前付きパターン</h2>
<p>パターンには<strong>名前を付ける</strong>ことができ、入れ子になったパターンを使うときにスコープに追加の名前を導入することができます。任意のパターンに名前を付けるには、<code>@</code>記号を使います。</p>
<p>たとえば、次のコードは1つ以上の要素を持つ任意の配列と適合しますが、配列の先頭を<code>x</code>という名前、配列全体を<code>arr</code>という名前に束縛します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dup ::</span> forall a<span class="fu">.</span> [a] <span class="ot">-&gt;</span> [a]
dup arr<span class="fu">@</span>(x <span class="fu">:</span> _) <span class="fu">=</span> x <span class="fu">:</span> arr
dup [] <span class="fu">=</span> []</code></pre>
<p>その結果、<code>dup</code>は空でない配列の先頭の要素を複製します。</p>
<pre class="text"><code>&gt; dup [1, 2, 3]
[1, 1, 2, 3]</code></pre>
<blockquote>
<h3 id="演習-9" class="unnumbered">演習</h3>
<ol type="1">
<li><p>（簡単）レコードパターンを使って、その人の市町村を探す関数 <code>getCity</code> を定義してみましょう。<code>Person</code>は<code>Address</code>型の<code>address</code>フィールドを含むレコードとして表現し、<code>Address</code>は<code>city</code>フィールドを含まなければなりません。</p></li>
<li><p>（やや難しい）行多相を考慮すると、<code>getCity</code>関数の最も一般的な型は何でしょうか？先ほど定義した<code>totalHeight</code>関数についてはどうでしょうか？</p></li>
<li><p>（やや難しい）パターンと連結演算子(<code>++</code>)だけを使って、配列の配列を平坦化する<code>flatten</code>関数を書いてみましょう。<strong>ヒント</strong>: この関数は<code>forall a. [[a]] -&gt; [a]</code>.という型を持っていなければなりません。</p></li>
</ol>
</blockquote>
<h2 id="case式"><span class="header-section-number">5.10</span> Case式</h2>
<p>パターンはソースコードの最上位にある関数だけに現れるわけではありません。<code>case</code>式を使用すると計算の途中の値に対してパターン照合を使うことができます。case式には無名関数に似た種類の便利さがあります。関数に名前を与えることがいつも望ましいわけではありません。パターン照合を使いたいためだけで関数に名前をつけるようなことを避けられるようになります。</p>
<p>例を示しましょう。次の関数は、配列の&quot;longest zero suffix&quot;(和がゼロであるような、最も長い配列の末尾)を計算します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lzs ::</span> [<span class="dt">Number</span>] <span class="ot">-&gt;</span> [<span class="dt">Number</span>]
lzs [] <span class="fu">=</span> []
lzs xs<span class="fu">@</span>(_ <span class="fu">:</span> t) <span class="fu">=</span> <span class="kw">case</span> sum xs <span class="kw">of</span>
  <span class="dv">0</span> <span class="ot">-&gt;</span> xs
  _ <span class="ot">-&gt;</span> lzs t</code></pre>
<p>例えば次のようになります。</p>
<pre class="text"><code>&gt; lzs [1, 2, 3, 4]
[]

&gt; lzs [1, -1, -2, 3]
[-1, -2, 3]</code></pre>
<p>この関数は場合ごとの分析によって動作します。もし配列が空なら、唯一の選択肢は空の配列を返すことです。配列が空でない場合は、さらに2つの場合に分けるためにまず<code>case</code>式を使用します。配列の合計がゼロであれば、配列全体を返します。そうでなければ、配列の残りに対して再帰します。</p>
<h2 id="パターン照合の失敗"><span class="header-section-number">5.11</span> パターン照合の失敗</h2>
<p>case式のパターンを順番に照合していって、もし選択肢のいずれの場合も入力が適合しなかった時は何が起こるのでしょうか？この場合、<strong>パターン照合失敗</strong>によって、case式は実行時に失敗します。</p>
<p>簡単な例でこの動作を見てみましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">patternFailure ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span>
patternFailure <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span></code></pre>
<p>この関数はゼロの入力に対してのみ適合する単一の場合を含みます。このファイルをコンパイルして<code>psci</code>でそれ以外の値を与えてテストすると、実行時エラーが発生します。</p>
<pre class="text"><code>&gt; patternFailure 10

Failed pattern match</code></pre>
<p>どんな入力の組み合わせに対しても値を返すような関数は<strong>全関数</strong>(total function)と呼ばれ、そうでない関数は<strong>部分関数</strong>(partial function)と呼ばれています。</p>
<p>一般的には、可能な限り全関数として定義したほうが良いと考えられています。もしその関数が正しい入力に対して値を返さないことがあるとわかっているなら、大抵は<code>a</code>に対して型<code>Maybe a</code>の返り値にし、 失敗を示すときには<code>Nothing</code>を使うようにしたほうがよいでしょう。この方法なら、型安全な方法で値の有無を示すことができます。</p>
<p>戻り値の型として<code>Maybe Number</code>を使うよう書き直した<code>patternFailure</code>関数は次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">patternFailure ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Number</span>
patternFailure <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Just</span> <span class="dv">0</span>
patternFailure _ <span class="fu">=</span> <span class="dt">Nothing</span></code></pre>
<h2 id="代数的データ型"><span class="header-section-number">5.12</span> 代数的データ型</h2>
<p>この節では、PureScriptの型システムでパターン照合に原理的に関係している<strong>代数的データ型</strong>(Algebraic data type, ADT）と呼ばれる機能を導入します。</p>
<p>しかしまずは、ベクターグラフィックスライブラリの実装というこの章の課題を解決する基礎として、簡単な例を切り口にして考えていきましょう。</p>
<p>直線、矩形、円、テキストなどの単純な図形の種類を表現する型を定義したいとします。オブジェクト指向言語では、おそらくインターフェイスもしくは抽象クラス<code>Shape</code>を定義し、使いたいそれぞれの図形について具体的なサブクラスを定義するでしょう。</p>
<p>しかしながら、この方針は大きな欠点をひとつ抱えています。<code>Shape</code>を抽象的に扱うためには、実行したいと思う可能性のあるすべての操作を事前に把握し、<code>Shape</code>インターフェイスに定義する必要があるのです。このため、モジュール性を壊さずに新しい操作を追加することが難しくなります。</p>
<p>もし図形の種類が事前にわかっているなら、代数的データ型はこうした問題を解決する型安全な方法を提供します。モジュール性のある方法で<code>Shape</code>に新たな操作を定義し、型安全なまま保守することを可能にします。</p>
<p>代数的データ型として表現された<code>Shape</code>がどのように記述されるかを次に示します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Shape</span>
  <span class="fu">=</span> <span class="dt">Circle</span> <span class="dt">Point</span> <span class="dt">Number</span>
  <span class="fu">|</span> <span class="dt">Rectangle</span> <span class="dt">Point</span> <span class="dt">Number</span> <span class="dt">Number</span>
  <span class="fu">|</span> <span class="dt">Line</span> <span class="dt">Point</span> <span class="dt">Point</span>
  <span class="fu">|</span> <span class="dt">Text</span> <span class="dt">Point</span> <span class="dt">String</span></code></pre>
<p>次のように <code>Point</code>型を代数的データ型として定義することもできます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Point</span> <span class="fu">=</span> <span class="dt">Point</span>
  {<span class="ot"> x ::</span> <span class="dt">Number</span>
  ,<span class="ot"> y ::</span> <span class="dt">Number</span>
  }</code></pre>
<p>この<code>Point</code>データ型は、興味深い点をいくつか示しています。</p>
<ul>
<li>代数的データ型の構築子に格納されるデータは、プリミティブ型に限定されるわけではありません。構築子はレコード、配列、あるいは他の代数的データ型を含めることもできます。</li>
<li>代数的データ型は複数の構築子があるデータを記述するのに便利ですが、構築子がひとつだけのときでも便利です。</li>
<li>代数的データ型の構築子は、代数的データ型自身と同じ名前の場合もあります。これはごく一般的であり、<code>Point</code><strong>データ構築子</strong>と<code>Point</code><strong>型構築子</strong>を混同しないようにすることが大切です。これらは異なる名前空間にあります。</li>
</ul>
<p>この宣言ではいくつかの構築子の和として<code>Shape</code>を定義しており、各構築子に含まれたデータはそれぞれ区別されます。<code>Shape</code>は、中央<code>Point</code>と半径を持つ<code>Circle</code>か、<code>Rectangle</code>、<code>Line</code>、<code>Text</code>のいずれかです。他には<code>Shape</code> 型の値を構築する方法はありません。</p>
<p>代数的データ型の定義は予約語 <code>data</code>から始まり、それに新しい型の名前と任意個の型引数が続きます。その型のデータ構築子は等号の後に定義され、パイプ文字（<code>|</code>）で区切られます。</p>
<p>それではPureScriptの標準ライブラリから別の例を見てみましょう。オプショナルな値を定義するのに使われる<code>Maybe</code>型を本書の冒頭で扱いました。<code>purescript-maybe</code>パッケージでは<code>Maybe</code>を次のように定義しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="fu">=</span> <span class="dt">Nothing</span> <span class="fu">|</span> <span class="dt">Just</span> a</code></pre>
<p>この例では型引数 <code>a</code>の使用方法を示しています。パイプ文字を「または」と読むことにすると、この定義は「<code>Maybe a</code>型の値は、無い(<code>Nothing</code>)、またはただの(<code>Just</code>)型<code>a</code>の値だ」と英語のように読むことができます。</p>
<p>データ構築子は再帰的なデータ構造を定義するために使用することもできます。更に例を挙げると、要素が型 <code>a</code>の単方向連結リストのデータ型を定義はこのようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</code></pre>
<p>この例は <code>purescript-lists</code>パッケージから持ってきました。ここで<code>Nil</code>構築子は空のリストを表しており、<code>Cons</code>は先頭となる要素と他の配列から空でないリストを作成するために使われます。<code>Cons</code>の２つ目のフィールドでデータ型 <code>List a</code>を使用しており、再帰的なデータ型になっていることに注目してください。</p>
<h2 id="代数的データ型の使用"><span class="header-section-number">5.13</span> 代数的データ型の使用</h2>
<p>代数的データ型の構築子を使用して値を構築するのはとても簡単です。対応する構築子に含まれるデータに応じた引数を用意し、その構築子を単に関数のように適用するだけです。</p>
<p>例えば、上で定義した<code>Line</code>構築子は２つの<code>Point</code>を必要としていますので、<code>Line</code>構築子を使って<code>Shape</code>を構築するには、型<code>Point</code>のふたつの引数を与えなければなりません。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">exampleLine ::</span> <span class="dt">Shape</span>
exampleLine <span class="fu">=</span> <span class="dt">Line</span> origin origin
  <span class="kw">where</span>
<span class="ot">  origin ::</span> <span class="dt">Point</span>
  origin <span class="fu">=</span> <span class="dt">Point</span> { x<span class="fu">:</span> <span class="dv">0</span>, y<span class="fu">:</span> <span class="dv">0</span> }</code></pre>
<p><code>origin</code>を構築するため、レコードを引数として<code>Point</code>構築子を適用しています。</p>
<p>代数的データ型で値を構築することは簡単ですが、これをどうやって使ったらよいのでしょうか？ここで代数的データ型とパターン照合との重要な接点が見えてきます。代数的データ型の値がどの構築子から作られたかを調べたり、代数的データ型からフィールドの値を取り出す唯一の方法は、パターン照合を使用することです。</p>
<p>例を見てみましょう。<code>Shape</code>を<code>String</code>に変換したいとしましょう。<code>Shape</code>を構築するのにどの構築子が使用されたかを調べるには、パターン照合を使用しなければなりません。これには次のようにします。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">showPoint ::</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
showPoint (<span class="dt">Point</span> { x <span class="fu">=</span> x, y <span class="fu">=</span> y }) <span class="fu">=</span>
  <span class="st">&quot;(&quot;</span> <span class="fu">++</span> show x <span class="fu">++</span> <span class="st">&quot;, &quot;</span> <span class="fu">++</span> show y <span class="fu">++</span> <span class="st">&quot;)&quot;</span>

<span class="ot">showShape ::</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
showShape (<span class="dt">Circle</span> c r)      <span class="fu">=</span> <span class="fu">...</span>
showShape (<span class="dt">Rectangle</span> c w h) <span class="fu">=</span> <span class="fu">...</span>
showShape (<span class="dt">Line</span> start end)  <span class="fu">=</span> <span class="fu">...</span>
showShape (<span class="dt">Circle</span> loc text) <span class="fu">=</span> <span class="fu">...</span></code></pre>
<p>各構築子はパターンとして使用することができ、構築子への引数はそのパターンで束縛することができます。<code>showShape</code>の最初の場合を考えてみましょう。もし<code>Shape</code>が<code>Circle</code>構築子適合した場合、２つの変数パターン<code>c</code>と<code>r</code>を使って<code>Circle</code>の引数（中心と半径）がスコープに導入されます。その他の場合も同様です。</p>
<p><code>showPoint</code>は、パターン照合の別の例にもなっています。<code>showPoint</code>はひとつの場合しかありませんが、<code>Point</code>構築子の中に含まれたレコードのフィールドに適合する、入れ子になったパターンが使われています。</p>
<blockquote>
<h3 id="演習-10" class="unnumbered">演習</h3>
<ol type="1">
<li><p>（簡単）半径<code>10</code>で中心が原点にある円を表す<code>Shape</code>の値を構築してください。</p></li>
<li><p>（やや難しい）引数の<code>Shape</code>を原点を中心として2倍に拡大する、<code>Shape</code>から<code>Shape</code>への関数を書いてみましょう。</p></li>
<li><p>（やや難しい） <code>Shape</code>からテキストを抽出する関数を書いてください。この関数は<code>Maybe String</code>を返さなければならず、もし入力が<code>Text</code>を使用して構築されたのでなければ、返り値には<code>Nothing</code>構築子を使ってください。</p></li>
</ol>
</blockquote>
<h2 id="newtype宣言"><span class="header-section-number">5.14</span> newtype宣言</h2>
<p>代数的データ型の特別な場合に、<strong>newtype</strong>と呼ばれる重要なものあります。newtypeは予約語<code>data</code>の代わりに予約語<code>newtype</code>を使用して導入します。</p>
<p>newtype宣言では<strong>過不足なくひとつだけの</strong>構築子を定義しなければならず、その構築子は<strong>過不足なくひとつだけの</strong>引数を取る必要があります。つまり、newtype宣言は既存の型に新しい名前を与えるものなのです。実際、newtypeの値は、元の型と同じ実行時表現を持っています。しかし、これらは型システムの観点から区別されます。これは型安全性の追加の層を提供するのです。</p>
<p>例として、ピクセルとインチのような単位を表現するために、<code>Number</code> の型レベルの別名を定義したくなる場合があるかもしれません。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Pixels</span> <span class="fu">=</span> <span class="dt">Pixels</span> <span class="dt">Number</span>
<span class="kw">newtype</span> <span class="dt">Inches</span> <span class="fu">=</span> <span class="dt">Inches</span> <span class="dt">Number</span></code></pre>
<p>こうすると<code>Inches</code>を期待している関数に<code>Pixels</code>型の値を渡すことは不可能になりますが、実行時の効率に余計な負荷が加わることはありません。</p>
<p>newtypeは次の章で<strong>型クラス</strong>を扱う際に重要になります。newtypeは実行時の表現を変更することなく型に異なる振る舞いを与えることを可能にするからです。</p>
<h2 id="ベクターグラフィックスライブラリ"><span class="header-section-number">5.15</span> ベクターグラフィックスライブラリ</h2>
<p>これまで定義してきたデータ型を使って、ベクターグラフィックスを扱う簡単なライブラリを作成していきましょう。</p>
<p>ただの<code>Shape</code>の配列であるような、<code>Picture</code>という型同義語を定義しておきます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Picture</span> <span class="fu">=</span> [<span class="dt">Shape</span>]</code></pre>
<p>デバッグしていると<code>Picture</code>を<code>String</code>として表示できるようにしたくなることもあるでしょう。これはパターン照合を使用して定義された次の関数で行うことができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">showPicture ::</span> <span class="dt">Picture</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
showPicture picture <span class="fu">=</span> <span class="st">&quot;[&quot;</span> <span class="fu">++</span> go picture <span class="fu">++</span> <span class="st">&quot;]&quot;</span>
  <span class="kw">where</span>
<span class="ot">  go ::</span> <span class="dt">Picture</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
  go [] <span class="fu">=</span> <span class="st">&quot;&quot;</span>
  go [x] <span class="fu">=</span> showShape x
  go (x <span class="fu">:</span> xs) <span class="fu">=</span> showShape x <span class="fu">++</span> <span class="st">&quot;, &quot;</span> <span class="fu">++</span> go xs</code></pre>
<p>再帰が <code>where</code>ブロックで定義された補助関数を使用して処理されていることに注目してください。この関数<code>go</code>は関数<code>showPicture</code>の内部でのみ参照可能で、モジュールの使用者が参照することはできません。</p>
<p><code>go</code>は、空の配列、１要素の配列、それ以外の、3つの場合を扱います。この方針だと、文字列の末尾に余分なコンマ文字が出力されるのを避けることができます。</p>
<p>試してみましょう。<code>grunt</code>でこのモジュールをコンパイルし、<code>psci</code>で開きます。</p>
<pre class="text"><code>$ grunt
$ psci

&gt; :i Data.Picture

&gt; showPicture [Line (Point { x: 0, y: 0 }) (Point { x: 1, y: 1 })]

&quot;[Line [start: (0, 0), end: (1, 1)]]&quot;</code></pre>
<h2 id="外接矩形の算出"><span class="header-section-number">5.16</span> 外接矩形の算出</h2>
<p>このモジュールのコード例には、<code>Picture</code>の最小外接矩形を計算する関数<code>bounds</code>が含まれています。</p>
<p><code>Bounds</code>は外接矩形を定義するデータ型です。また、構築子をひとつだけ持つ代数的データ型として定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Bounds</span> <span class="fu">=</span> <span class="dt">Bounds</span>
  {<span class="ot"> top    ::</span> <span class="dt">Number</span>
  ,<span class="ot"> left   ::</span> <span class="dt">Number</span>
  ,<span class="ot"> bottom ::</span> <span class="dt">Number</span>
  ,<span class="ot"> right  ::</span> <span class="dt">Number</span>
  }</code></pre>
<p><code>Picture</code>内の<code>Shape</code>の配列を走査し、最小の外接矩形を累積するため、<code>bounds</code>は<code>Data.Foldable</code>の<code>foldl</code>関数を使用しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bounds ::</span> <span class="dt">Picture</span> <span class="ot">-&gt;</span> <span class="dt">Bounds</span>
bounds <span class="fu">=</span> foldl combine emptyBounds
  <span class="kw">where</span>
<span class="ot">  combine ::</span> <span class="dt">Bounds</span> <span class="ot">-&gt;</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> <span class="dt">Bounds</span>
  combine b shape <span class="fu">=</span> shapeBounds shape \<span class="fu">/</span> b</code></pre>
<p>畳み込みの初期値として空の<code>Picture</code>の最小外接矩形を求める必要がありますが、<code>emptyBounds</code>で定義される空の外接矩形がその条件を満たしています。</p>
<p>累積関数 <code>combine</code>は<code>where</code>ブロックで定義されています。 <code>combine</code>は<code>foldl</code>の再帰呼び出しで計算された外接矩形と、配列内の次の<code>Shape</code>を引数にとり、ユーザ定義の演算子<code>\/</code>を使ってふたつの外接矩形の和を計算しています。<code>shapeBounds</code>関数は、パターン照合を使用して、単一の図形の外接矩形を計算します。</p>
<blockquote>
<h3 id="演習-11" class="unnumbered">演習</h3>
<ol type="1">
<li><p>（やや難しい） ベクターグラフィックライブラリを拡張し、<code>Shape</code>の面積を計算する新しい操作<code>area</code>を追加してください。この演習では、テキストの面積は0であるものとしてください。</p></li>
<li><p>（難しい） <code>Shape</code>を拡張し、新しいデータ構築子<code>Clipped</code>を追加してください。<code>Clipped</code>は他の<code>Picture</code>を矩形に切り抜き出ます。切り抜かれた<code>Picture</code>の境界を計算できるよう、<code>shapeBounds</code>関数を拡張してください。これは<code>Shape</code>を再帰的なデータ型にすることに注意してください。</p></li>
</ol>
</blockquote>
<h2 id="まとめ-3"><span class="header-section-number">5.17</span> まとめ</h2>
<p>この章では、関数型プログラミングから基本だが強力なテクニックであるパターン照合を扱いました。複雑なデータ構造の部分と照合するために、簡単なパターンだけでなく配列パターンやレコードパターンをどのように使用するかを見てきました。</p>
<p>またこの章では、パターン照合に密接に関連する代数的データ型を導入しました。代数的データ型がデータ構造のわかりやすい記述をどのように可能にするか、新たな操作でデータ型を拡張するためのモジュール性のある方法を提供することを見てきました。</p>
<p>最後に、多くの既存のJavaScript関数に型を与えるために、強力な抽象化である行多相を扱いました。この本の後半ではこれらの概念を再び扱います。</p>
<p>本書では今後も代数的データ型とパターン照合を使用するので、今のうちにこれらに習熟しておくと後で役立つでしょう。これ以外にも独自の代数的データ型を作成し、パターン照合を使用してそれらを使う関数を書くことを試してみてください。</p>
<h1 id="型クラス"><span class="header-section-number">6</span> 型クラス</h1>
<h2 id="章の目標"><span class="header-section-number">6.1</span> 章の目標</h2>
<p>この章では、PureScriptの型システムによって可能になる強力な抽象化の形式、型クラスを導入します。</p>
<p>この章ではデータ構造をハッシュするためのライブラリを題材に説明していきます。データ自身の構造について直接考えることなく複雑なデータ構造をハッシュするために、型クラスの仕組みがどのようにして働くのかを見ていきます。</p>
<p>またPureScriptのPreludeと標準ライブラリに含まれる標準的な型クラスも見ていきます。PureScriptのコードは概念を簡潔に表現するために型クラスの強力さに大きく依存しているので、これらのクラスに慣れておくと役に立つでしょう。</p>
<h2 id="プロジェクトの準備-3"><span class="header-section-number">6.2</span> プロジェクトの準備</h2>
<p>この章のソースコードは、ファイル <code>src/data/Hashable.purs</code>で定義されています。</p>
<p>このプロジェクトには以下のBower依存関係があります。</p>
<ul>
<li><code>purescript-maybe</code>: オプショナルな値を表す <code>Maybe</code>データ型が定義されています。</li>
<li><code>purescript-tuples</code>: 値の組を表す <code>Tuple</code>データ型が定義されています。</li>
<li><code>purescript-either</code>: 非交和を表す <code>Either</code>データ型が定義されています。</li>
<li><code>purescript-strings</code>: 文字列を操作する関数が定義されています。</li>
</ul>
<p>モジュール <code>Data.Hashable</code>は、これらのBowerパッケージによって提供されるモジュールをいくつかインポートします。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Data.Hashable</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Maybe</span>
<span class="kw">import </span><span class="dt">Data.Tuple</span>
<span class="kw">import </span><span class="dt">Data.Either</span>
<span class="kw">import </span><span class="dt">Data.String</span>
<span class="kw">import </span><span class="dt">Data.Function</span></code></pre>
<h2 id="見せてください"><span class="header-section-number">6.3</span> 見せてください！</h2>
<p>型クラスの最初に扱う例は、すでに何回か見てきた関数に関係します。<code>show</code>は何らかの値を取りそれを文字列として表示する関数です。</p>
<p><code>show</code>は<code>Prelude</code>モジュールの<code>Show</code>と呼ばれる型クラスで次のように定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Show</span> a <span class="kw">where</span>
<span class="ot">  show ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre>
<p>このコードでは、型変数 <code>a</code>でパラメータ化された、<code>Show</code>という新しい<strong>型クラス</strong>(type class)を宣言しています。</p>
<p>型クラス<strong>インスタンス</strong>には、型クラスで定義された関数の、その型に特殊化された実装が含まれています。</p>
<p>例えば、Preludeにある<code>Boolean</code>値に対する<code>Show</code>型クラスインスタンスの定義は次のとおりです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> showBoolean ::</span> <span class="dt">Show</span> <span class="dt">Boolean</span> <span class="kw">where</span>
  show true <span class="fu">=</span> <span class="st">&quot;true&quot;</span>
  show false <span class="fu">=</span> <span class="st">&quot;false&quot;</span></code></pre>
<p>このコードは <code>showBool​​ean</code>という名前の型クラスのインスタンスを宣言します。</p>
<p>PureScriptでは、生成されたJavaScriptの可読性を良くするために型クラスインスタンスには名前をつけます。このとき、<strong><code>Boolean</code>型は<code>Show</code>型クラスに属している</strong>といいます。</p>
<p><code>psci</code>で<code>Show</code>型クラスについて異なる型でいくつかの値を表示してみましょう。</p>
<pre class="text"><code>&gt; show true

&quot;true&quot;

&gt; show 1.0

&quot;1&quot;

&gt; show &quot;Hello World&quot;

&quot;\&quot;Hello World\&quot;&quot;</code></pre>
<p>この例ではさまざまなプリミティブ型の値を<code>show</code>しましたが、もっと複雑な型を持つ値を<code>show</code>することもできます。</p>
<pre class="text"><code>&gt; i Data.Tuple
&gt; show $ Tuple 1 true
&quot;Tuple (1) (true)&quot;

&gt; :i Data.Maybe
&gt; show $ Just &quot;testing&quot;
&quot;Just (\&quot;testing\&quot;)&quot;</code></pre>
<p>型<code>Data.Either</code>の値を表示しようとすると、興味深いエラーメッセージが表示されます。</p>
<pre class="text"><code>&gt; :i Data.Either
&gt; show $ Left 10
  
Error in declaration it
No instance found for Prelude.Show (Data.Either.Either Prim.String u8)</code></pre>
<p>ここでの問題は<code>show</code>しようとしている型に対する<code>Show</code>インスタンスが存在しないということではなく、<code>psci</code>がこの型を推論できなかったということです。このエラーメッセージで<strong>未知の型</strong><code>u8</code>と表示されているのがそれです。</p>
<p><code>::</code>演算子を使って式に対して型注釈を加えると、<code>psci</code>が正しい型クラスインスタンスを選ぶことができるようになります。</p>
<pre class="text"><code>&gt; show (Left 10 :: Either Number String)
  
&quot;Left (10)&quot;</code></pre>
<p><code>Show</code>インスタンスをまったく持っていない型もあります。関数の型<code>-&gt;</code>がその一例です。<code>Number</code>から<code>Number</code>への関数を<code>show</code>しようとすると、型検証器によってその通りのエラーメッセージが表示されます。</p>
<pre class="text"><code>&gt; show $ \n -&gt; n + 1
  
Error in declaration it
No instance found for Prelude.Show (Prim.Number -&gt; Prim.Number)</code></pre>
<blockquote>
<h2 id="演習-12" class="unnumbered">演習</h2>
<ol type="1">
<li>(簡単)前章の<code>showShape</code>関数を使って、<code>Shape</code>型に対しての<code>Show</code>インスタンスを定義してみましょう。</li>
</ol>
</blockquote>
<h2 id="標準的な型クラス"><span class="header-section-number">6.4</span> 標準的な型クラス</h2>
<p>この節では、Preludeや標準ライブラリで定義されている標準的な型クラスをいくつか見ていきましょう。これらの型クラスはPureScript特有の抽象化の基礎としてあちこちで使われているので、これらの関数の基本についてよく理解しておくことを強くお勧めします。</p>
<h3 id="eq型クラス"><span class="header-section-number">6.4.1</span> Eq型クラス</h3>
<p><code>Eq</code>型クラスは等値演算子(<code>==</code>)と不等値演算子(<code>/=</code>)を定義します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span>
<span class="ot">  (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Boolean</span>
<span class="ot">  (/=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Boolean</span></code></pre>
<p>異なる型の2つの値を比較しても意味がありませんから、いずれの演算子も2つの引数が同じ型を持つ必要があることに注意してください。</p>
<p><code>psci</code> で<code>Eq</code>型クラスを試してみましょう。</p>
<pre class="text"><code>&gt; 1 == 2
false

&gt; &quot;Test&quot; == &quot;Test&quot;
true</code></pre>
<h3 id="ord型クラス"><span class="header-section-number">6.4.2</span> Ord型クラス</h3>
<p><code>Ord</code>型クラスは順序付け可能な型に対して2つの値を比較する<code>compare</code>関数を定義します。<code>compare</code>関数が定義されていると、比較演算子 <code>&lt;</code>、<code>&gt;</code>と、その仲間<code>&lt;=</code>、<code>&gt;=</code>も定義されます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Ordering</span> <span class="fu">=</span> <span class="dt">LT</span> <span class="fu">|</span> <span class="dt">EQ</span> <span class="fu">|</span> <span class="dt">GT</span>

<span class="kw">class</span> (<span class="dt">Eq</span> a) <span class="fu">&lt;=</span> <span class="dt">Ord</span> a <span class="kw">where</span>
<span class="ot">  compare ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span></code></pre>
<p><code>compare</code>関数は2つの値を比較して<code>Ordering</code>の3つの値のうちいずれかを返します。</p>
<ul>
<li><code>LT</code> - 最初の引数が2番目の値より小さいとき</li>
<li><code>EQ</code> - 最初の引数が2番目の値と等しい(または比較できない)とき</li>
<li><code>GT</code> - 最初の引数が2番目の値より大きいとき</li>
</ul>
<p><code>compare</code>関数についても<code>psci</code>で試してみましょう。</p>
<pre class="text"><code>&gt; compare 1 2
LT

&gt; compare &quot;A&quot; &quot;Z&quot;
LT</code></pre>
<h3 id="num型クラス"><span class="header-section-number">6.4.3</span> 　Num型クラス</h3>
<p><code>Num</code>型クラスは加算、減算、乗算、除算などの数値演算子を使用可能な型を示します。必要に応じて再利用できるように、これらの演算子を抽象化するわけです。</p>
<p><strong>注意</strong>: 関数呼び出しが型クラスの実装に基いて呼び出されるのとは対照的に、型クラス<code>Eq</code>や<code>Ord</code>、<code>Num</code>などはPureScriptでは特別に扱われ、<code>1 + 2 * 3</code>のような単純な式は単純なJavaScriptへと変換されます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Num</span> a <span class="kw">where</span>
<span class="ot">  (+) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">  (-) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">  (*) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">  (/) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">  (%) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">  negate ::</span> a <span class="ot">-&gt;</span> a</code></pre>
<h3 id="半群とモノイド"><span class="header-section-number">6.4.4</span> 半群とモノイド</h3>
<p><code>Semigroup</code>(半群)型クラスは、連結演算子 <code>&lt;&gt;</code>を提供する型を示します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Semigroup</span> a <span class="kw">where</span>
<span class="ot">  (&lt;&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</code></pre>
<p>普通の文字列連結について文字列は半群をなしますし、同様に配列も半群をなします。その他の標準的なインスタンスの幾つかは、 <code>purescript-monoid</code>パッケージで提供されています。</p>
<p>以前に見た<code>++</code>連結演算子は、<code>&lt;&gt;</code>の別名として提供されています。</p>
<p><code>purescript-monoid</code>パッケージで提供されている<code>Monoid</code>型クラスは、<code>mempty</code>と呼ばれる空の値の概念で<code>Semigroup</code>型クラスを拡張します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Semigroup</span> m) <span class="fu">&lt;=</span> <span class="dt">Monoid</span> m <span class="kw">where</span>
<span class="ot">  mempty ::</span> m</code></pre>
<p>文字列や配列はモノイドの簡単な例になっています。</p>
<p><code>Monoid</code>型クラスインスタンスでは、「空」の値から始めて新たな値を合成していき、その型で<strong>累積</strong>した結果を返すにはどうするかを記述する型クラスです。例えば、畳み込みを使っていくつかのモノイドの値の配列を連結する関数を書くことができます。<code>psci</code>で試すと次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="fu">:</span>i <span class="dt">Data.Monoid</span>
<span class="fu">&gt;</span> <span class="fu">:</span>i <span class="dt">Data.Foldable</span>
  
<span class="fu">&gt;</span> foldl (<span class="fu">&lt;&gt;</span>) mempty [<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot; &quot;</span>, <span class="st">&quot;World&quot;</span>]  
<span class="st">&quot;Hello World&quot;</span>
  
<span class="fu">&gt;</span> foldl (<span class="fu">&lt;&gt;</span>) mempty [[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">4</span>, <span class="dv">5</span>], [<span class="dv">6</span>]]
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</code></pre>
<p><code>purescript-monoid</code>パッケージにはモノイドと半群の多くの例を提供しており、これらを本書で扱っていきます。</p>
<h3 id="foldable型クラス"><span class="header-section-number">6.4.5</span> Foldable型クラス</h3>
<p><code>Monoid</code>型クラスは畳み込みの結果になるような型を示しますが、<code>Foldable</code>型クラスは、畳み込みの元のデータとして使えるような型構築子を示しています。</p>
<p>また、<code>Foldable</code>型クラスは、配列や<code>Maybe</code>などのいくつかの標準的なコンテナのインスタンスを含む<code>purescript-foldable-traversable</code>パッケージで提供されています。</p>
<p><code>Foldable</code>クラスに属する関数の型シグネチャは、これまで見てきたものよりも少し複雑です。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Foldable</span> f <span class="kw">where</span>
<span class="ot">  foldr ::</span> forall a b<span class="fu">.</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> b
<span class="ot">  foldl ::</span> forall a b<span class="fu">.</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> b
<span class="ot">  foldMap ::</span> forall a m<span class="fu">.</span> (<span class="dt">Monoid</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> m</code></pre>
<p>この定義は<code>f</code>を配列の型構築子だと特殊化して考えてみるとわかりやすくなります。この場合、すべての<code>a</code>について<code>f a</code>を<code>[a]</code>に置き換える事ができますが、<code>foldl</code>と<code>foldr</code>の型が、最初に見た配列に対する畳み込みの型になるとわかります。</p>
<p><code>foldMap</code>についてはどうでしょうか？これは<code>forall m. (Monoid m)=&gt;(a -&gt; m) -&gt; [a]  -&gt; m</code>になります。この型シグネチャは、型<code>m</code>が<code>Monoid</code>型クラスのインスタンスであればどんな型でも返り値の型として選ぶことができると言っています。配列の要素をそのモノイドの値へと変換する関数を提供すれば、そのモノイドの構造を利用して配列を畳み込み、ひとつの値にして返すことができます。</p>
<p>それでは<code>psci</code> で<code>foldMap</code>を試してみましょう。</p>
<pre class="text"><code>&gt; :i Data.Foldable

&gt; foldMap show [1, 2, 3, 4, 5]
&quot;12345&quot;</code></pre>
<p>ここではモノイドとして文字列を選び、<code>Number</code>を文字列として表示する<code>show</code>関数を使いました。それから、数の配列を渡し、それぞれの数を<code>show</code>してひとつの文字列へと連結した結果出力されました。</p>
<p>畳み込み可能な型は配列だけではありません。<code>purescript-foldable-traversable</code>では<code>Maybe</code>や<code>Tuple</code>のような型の<code>Foldable</code>インスタンスが定義されており、<code>purescript-lists</code>のような他のライブラリでは、そのライブラリのそれぞれのデータ型に対して<code>Foldable</code>インスタンスが定義されています。<code>Foldable</code>は<strong>順序付きコンテナ</strong>(ordered container)の概念を抽象化するのです。</p>
<h3 id="関手と型クラス則"><span class="header-section-number">6.4.6</span> 関手と型クラス則</h3>
<p>PureScriptで副作用を伴う関数型プログラミングのスタイルを可能にするための<code>Functor</code>と<code>Applicative</code>、<code>Monad</code>といった型クラスがPreludeでは定義されています。これらの抽象については本書で後ほど扱いますが、まずは「持ち上げ演算子」<code>&lt;$&gt;</code>の形ですでに見てきた<code>Functor</code>型クラスの定義を見てみましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span>
<span class="ot">  (&lt;$&gt;) ::</span> forall a b<span class="fu">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre>
<p>演算子<code>&lt;$&gt;</code>は関数をそのデータ構造まで「持ち上げる」(lift)ことができます。ここで「持ち上げ」という言葉の具体的な定義は問題のデータ構造に依りますが、すでにいくつかの単純な型についてその動作を見てきました。</p>
<pre class="text"><code>&gt; :i Data.Array
&gt; (\n -&gt; n &lt; 3) &lt;$&gt; [1, 2, 3, 4, 5]
  
[true, true, false, false, false]

&gt; :i Data.Maybe
&gt; Data.String.length &lt;$&gt; Just &quot;testing&quot;
  
Just (7)</code></pre>
<p><code>&lt;$&gt;</code>演算子は様々な構造の上でそれぞれ異なる振る舞いをしますが、<code>&lt;$&gt;</code>演算子の意味はどのように理解すればいいのでしょうか。</p>
<p>直感的には、<code>&lt;$&gt;</code>演算子はコンテナのそれぞれの要素へ関数を適用し、その結果から元のデータと同じ形状を持った新しいコンテナを構築するのだというように理解することができます。しかし、この概念を厳密にするにはどうしたらいいでしょうか？。</p>
<p><code>Functor</code> の型クラスのインスタンスは、<strong>関手則</strong>(functor laws)と呼ばれる法則を順守するものと期待されています。</p>
<ul>
<li><code>id &lt;$&gt; xs = xs</code></li>
<li><code>g &lt;$&gt; (f &lt;$&gt; xs) = (g &lt;&lt;&lt; f) &lt;$&gt; xs</code></li>
</ul>
<p>最初の法則は<strong>恒等射律</strong>(identity law)です。これは、恒等関数をその構造まで持ち上げると、元の構造をそのまま返す恒等射になるということと言っています。恒等関数は入力を変更しませんから、これは理にかなっています。</p>
<p>第二の法則は<strong>合成律</strong>(composition law)です。構造をひとつの関数で写してから２つめの関数で写すのは、２つの関数の合成で構造を写すのと同じだ、と言っています。</p>
<p>「持ち上げ」の一般的な意味が何であれ、データ構造に対する持ち上げ関数の正しい定義はこれらの法則に従っていなければなりません。</p>
<p>標準の型クラスの多くには、このような法則が付随しています。一般に、型クラスに与えられた法則は、型クラスの関数に構造を与え、インスタンスについて調べられるようにします。興味のある読者は、すでに見てきた標準の型クラスに属する法則について調べてみてもよいでしょう。</p>
<blockquote>
<h2 id="演習-13" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単)次のnewtypeは複素数を表します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Complex</span> <span class="fu">=</span> <span class="dt">Complex</span> 
    {<span class="ot"> real ::</span> <span class="dt">Number</span>
    ,<span class="ot"> imaginary ::</span> <span class="dt">Number</span> 
    }</code></pre>
<p><code>Complex</code>について、<code>Show</code>と<code>Eq</code>のインスタンスを定義してください。</p></li>
<li><p>(やや難しい)次は型<code>a</code>の要素の空でない配列の型を定義しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">NonEmpty</span> a <span class="fu">=</span> <span class="dt">NonEmpty</span> a [a]</code></pre>
<p><code>[]</code>についての<code>Semigroup</code>インスタンスを再利用し、空でない配列についての<code>Semigroup</code>インスタンスを書いてみてください。</p></li>
<li><p>(やや難しい) <code>NonEmpty</code>の<code>Functor</code>インスタンスを書いてみましょう。</p></li>
<li><p>(難しい) <code>NonEmpty</code>の<code>Foldable</code>インスタンスを書いてみましょう。<strong>ヒント</strong>：配列の <code>Foldable</code>インスタンスを再利用してみましょう。</p></li>
</ol>
</blockquote>
<h2 id="型注釈"><span class="header-section-number">6.5</span> 型注釈</h2>
<p>型クラスを使うと、関数の型に制約を加えることができます。例を示しましょう。 <code>Eq</code>型クラスのインスタンスで定義された等値性を使って、３つの値が等しいかどうかを調べる関数を書きたいとします。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">threeAreEqual ::</span> forall a<span class="fu">.</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Boolean</span>
threeAreEqual a1 a2 a3 <span class="fu">=</span> a1 <span class="fu">==</span> a2 <span class="fu">&amp;&amp;</span> a2 <span class="fu">==</span> a3</code></pre>
<p>この型宣言は<code>forall</code>を使って定義された通常の多相型のようにも見えます。しかし、太い矢印 <code>=&gt;</code>で型の残りの部分から区切られた、括弧内の型クラス制約があります。</p>
<p>インポートされたモジュールのどれかに<code>a</code>に対する<code>Eq</code>インスタンスが存在するなら、どんな型<code>a</code>を選んでも<code>threeAsEqual</code>を呼び出すことができる、とこの型は言っています。</p>
<p>制約された型には複数の型クラスインスタンスを含めることができますし、インスタンスの型は単純な型変数に限定されません。<code>Ord</code>と<code>Show</code>のインスタンスを使って2つの値を比較する例を次に示します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">showCompare ::</span> forall a<span class="fu">.</span> (<span class="dt">Ord</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>
showCompare a1 a2 <span class="fu">|</span> a1 <span class="fu">&lt;</span> a2 <span class="fu">=</span> 
  show a1 <span class="fu">++</span> <span class="st">&quot; is less than &quot;</span> <span class="fu">++</span> show a2
showCompare a1 a2 <span class="fu">|</span> a1 <span class="fu">&gt;</span> a2 <span class="fu">=</span> 
  show a1 <span class="fu">++</span> <span class="st">&quot; is greater than &quot;</span> <span class="fu">++</span> show a2
showCompare a1 a2 <span class="fu">=</span> 
  show a1 <span class="fu">++</span> <span class="st">&quot; is equal to &quot;</span> <span class="fu">++</span> show a2</code></pre>
<p>型クラスで制約された関数を使うときには重要な制限があります。PureScriptコンパイラは制約された型を推論しません。型注釈の提供は必須になります。</p>
<p><code>psci</code> で<code>Num</code>のような標準の型クラスのいずれかを使って、このことを試してみましょう。</p>
<pre class="text"><code>&gt; :t \x -&gt; x + x

Error in declaration it
No instance found for Prelude.Num u2</code></pre>
<p>ここで、数を倍にするこの関数の型を、数の型の<code>Num</code>インスタンスを使って見つけようとしますが、<code>psci</code>は<code>x</code>の型が不明であるときはこの関数の制約された型を推論しないので、<code>psci</code>は未知の型の型クラスインスタンスを見つけることができないという旨を報告します。</p>
<p>たとえば<code>x</code>が数であることを表すには、次のように型検証器に指示しなければいけません。</p>
<pre class="text"><code>&gt; :t \x -&gt; x + (x :: Number)

Prim.Number -&gt; Prim.Number</code></pre>
<h2 id="インスタンスの重複"><span class="header-section-number">6.6</span> インスタンスの重複</h2>
<p>PureScriptには型クラスのインスタンスに関する<strong>重複インスタンス規則</strong>(Overlapping instances rule)という規則があります。型クラスのインスタンスが関数呼び出しのところで必要とされるときはいつでも、PureScriptは正しいインスタンスを選択するために型検証器によって推論された情報を使用します。そのとき、その型の適切なインスタンスがちょうどひとつだけ存在しなければなりません。</p>
<p>これを実証するために、適当な型に対して2つの異なる型クラスのインスタンスを作成してみましょう。次のコードでは、型 <code>T</code>の2つの重複する<code>Show</code>インスタンスを作成しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Overlapped</span> <span class="kw">where</span>

<span class="kw">data</span> <span class="dt">T</span> <span class="fu">=</span> <span class="dt">T</span>

<span class="kw">instance</span><span class="ot"> showT1 ::</span> <span class="dt">Show</span> <span class="dt">T</span> <span class="kw">where</span>
  show _ <span class="fu">=</span> <span class="st">&quot;Instance 1&quot;</span>
  
<span class="kw">instance</span><span class="ot"> showT2 ::</span> <span class="dt">Show</span> <span class="dt">T</span> <span class="kw">where</span>
  show _ <span class="fu">=</span> <span class="st">&quot;Instance 2&quot;</span></code></pre>
<p>このモジュールはエラーなくコンパイルされます。<code>psci</code>を起動し、型<code>T</code>の<code>Show</code>インスタンスを見つけようとすると、重複インスタンス規則が適用され、エラーになります。</p>
<pre class="text"><code>&gt; show T
  
Compiling Overlapped
Error in declaration it
Overlapping instances found for Prelude.Show Overlapped.T</code></pre>
<p>重複インスタンスルールが適用されるのは、型クラスのインスタンスの自動選択が予測可能な処理であるようにするためです。もし型に対してふたつの型クラスインスタンスを許し、モジュールインポートの順序に従ってどちらかを選ぶようにすると、実行時のプログラムの振る舞いが予測できなくなってしまい好ましくありません。</p>
<p>適切な法則を満たすふたつ妥当な型クラスインスタンスが存在しうるなら、既存の型を包むnewtypeを定義するのが一般的な方法です。重複インスタンスのルールの下でも、異なるnewtypesなら異なる型クラスインスタンスを持つことが許されるので、問題はなくなります。この手法はPureScriptの標準ライブラリでも使われており、例えば<code>purescript-monoid</code>では、<code>Maybe a</code>型は<code>Monoid</code>型クラスの妥当なインスタンスを複数持っています。</p>
<h2 id="インスタンスの依存関係"><span class="header-section-number">6.7</span> インスタンスの依存関係</h2>
<p>制約された型を使うと関数の実装が型クラスインスタンスに依存できるように、型クラスインスタンスの実装は他の型クラスインスタンスに依存することができます。これにより、型を使ってプログラムの実装を推論するという、プログラム推論の強力な形式を提供します。</p>
<p><code>Show</code>型クラスを例に考えてみましょう。要素を<code>show</code>する方法があるとき、その要素の配列を<code>show</code>する型クラスインスタンスを書くことができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> showArray ::</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Show</span> [a] <span class="kw">where</span>
  show xs <span class="fu">=</span> <span class="st">&quot;[&quot;</span> <span class="fu">++</span> go xs <span class="fu">++</span> <span class="st">&quot;]&quot;</span>
    <span class="kw">where</span>
    go [] <span class="fu">=</span> <span class="st">&quot;&quot;</span>
    go [x] <span class="fu">=</span> show x
    go (x <span class="fu">:</span> xs) <span class="fu">=</span> show x <span class="fu">++</span> <span class="st">&quot;, &quot;</span> <span class="fu">++</span> go xs</code></pre>
<p>PureScriptのPreludeに、このコードの最適化されたものが含まれています。</p>
<p>ここで、関数 <code>show</code>は様々な型の入力に対して使われていることに注意してください。<code>[a]</code>つまり要素が型<code>a</code>の配列の入力に対して動作するように<code>show</code>を定義しています。しかし、 <code>go</code>関数では、入力の先頭の要素を名前<code>x</code>として導入し、<code>show x</code>というように呼び出しています。ここでの<code>show</code>は型 <code>a</code>の<strong>要素</strong>に適用されています。</p>
<p>プログラムがコンパイルされると、<code>Show</code>の正しい型クラスのインスタンスは<code>show</code>の引数の推論された型に基づいて選ばれますが、このあたりの複雑さに開発者が関与することはありません。</p>
<blockquote>
<h2 id="演習-14" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単) <code>Eq a</code>と<code>Eq [a]</code>のインスタンスを再利用して、型<code>NonEmpty a</code>に対する<code>Eq</code>インスタンスを書いてみましょう。</p></li>
<li><p>(やや難しい) <code>Ord</code>のインスタンスを持つ任意の型<code>a</code>について、その他のどんな値よりも大きい「無限大」の値を新たに追加することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Extended</span> a <span class="fu">=</span> <span class="dt">Finite</span> a <span class="fu">|</span> <span class="dt">Infinite</span></code></pre>
<p><code>a</code>の<code>Ord</code>インスタンスを再利用して、<code>Extended a</code>の<code>Ord</code>インスタンスを書いてみましょう。</p></li>
<li><p>(難しい)　順序付きコンテナを定義する(そして<code>Foldable</code>のインスタンスを持っている)ような型構築子<code>f</code>が与えられたとき、追加の要素を先頭に含めるような新たなコンテナ型を作ることができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">OneMore</span> f a <span class="fu">=</span> <span class="dt">OneMore</span> a (f a)</code></pre>
<p>このコンテナ<code>OneMore f</code>もまた順序を持っています。ここで、新しい要素は任意の<code>f</code>の要素よりも前にきます。この<code>OneMore f</code>の<code>Foldable</code>インスタンスを書いてみましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> foldableOneMore ::</span> (<span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> <span class="dt">Foldable</span> (<span class="dt">OneMore</span> f) <span class="kw">where</span>
  <span class="fu">...</span></code></pre></li>
</ol>
</blockquote>
<h2 id="多変数型クラス"><span class="header-section-number">6.8</span> 多変数型クラス</h2>
<p>型クラスは必ずしもひとつの型だけを型変数としてとるわけではありません。型変数がひとつだけなのが最も一般的ですが、実際には型クラスは<strong>ゼロ個以上の</strong>型変数を持つことができます。</p>
<p>それでは2つの型引数を持つ型クラスの例を見てみましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Stream</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Maybe</span>
<span class="kw">import </span><span class="dt">Data.Tuple</span>
<span class="kw">import </span><span class="dt">Data.String</span>

<span class="kw">class</span> <span class="dt">Stream</span> list element <span class="kw">where</span>
<span class="ot">  uncons ::</span> list <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Tuple</span> element list)

<span class="kw">instance</span><span class="ot"> streamArray ::</span> <span class="dt">Stream</span> [a] a <span class="kw">where</span>
  uncons [] <span class="fu">=</span> <span class="dt">Nothing</span>
  uncons (x <span class="fu">:</span> xs) <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Tuple</span> x xs)

<span class="kw">instance</span><span class="ot"> streamString ::</span> <span class="dt">Stream</span> <span class="dt">String</span> <span class="dt">String</span> <span class="kw">where</span>
  uncons <span class="st">&quot;&quot;</span> <span class="fu">=</span> <span class="dt">Nothing</span>
  uncons s <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Tuple</span> (take <span class="dv">1</span> s) (drop <span class="dv">1</span> s))</code></pre>
<p>この<code>Stream</code>モジュールでは、<code>uncons</code>関数を使ってストリームの先頭から要素を取り出すことができる、要素のストリームのような型を示すクラス <code>Stream</code>が定義されています。</p>
<p><code>Stream</code>型クラスは、ストリーム自身の型だけでなくその要素の型も型変数として持っていることに注意してください。これによって、ストリームの型が同じでも要素の型について異なる型クラスインスタンスを定義することができます。</p>
<p>このモジュールでは、<code>uncons</code>がパターン照合で配列の先頭の要素を取り除くような配列のインスタンスと、文字列から最初の文字を取り除くような文字列のインスタンスという、 ２つの型クラスインスタンスが定義されています。</p>
<p>任意のストリーム上で動作する関数を記述することができます。例えば、ストリームの要素に基づいたモノイドで結果を累積する関数は次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Monoid</span>

<span class="ot">foldStream ::</span> forall l e m<span class="fu">.</span> (<span class="dt">Stream</span> l e, <span class="dt">Monoid</span> m) <span class="ot">=&gt;</span> (e <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> l <span class="ot">-&gt;</span> m
foldStream f list <span class="fu">=</span>
  <span class="kw">case</span> uncons list <span class="kw">of</span>
    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> mempty
    <span class="dt">Just</span> (<span class="dt">Tuple</span> head tail) <span class="ot">-&gt;</span> f head <span class="fu">&lt;&gt;</span> foldStream f tail</code></pre>
<p><code>psci</code>で使って、異なる<code>Stream</code>の型や異なる<code>Monoid</code>の型について<code>foldStream</code>を呼び出してみましょう。</p>
<h2 id="型変数のない型クラス"><span class="header-section-number">6.9</span> 型変数のない型クラス</h2>
<p>ゼロ個の型変数を持つ型クラスを定義することもできます！型システムによってコードの大域的な性質の追跡ができるようになる、関数についてのコンパイル時表明に関係しています。</p>
<p>たとえば、型システムを使って部分関数の使用を追跡したいとしましょう。型引数のない型クラス<code>Partial</code>を定義し、すべての部分関数を<code>Partial</code>制約で注釈します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Partial</span> <span class="kw">where</span>

<span class="kw">class</span> <span class="dt">Partial</span>

head<span class="ot"> ::</span> forall a<span class="fu">.</span> (<span class="dt">Partial</span>) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
head (x <span class="fu">:</span> _) <span class="fu">=</span> x

tail<span class="ot"> ::</span> forall a<span class="fu">.</span> (<span class="dt">Partial</span>) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]
tail (_ <span class="fu">:</span> xs) <span class="fu">=</span> xs</code></pre>
<p><code>Partial</code>モジュールの<code>Partial</code>型クラスのインスタンスを定義していないことに注意してください。こうすると目的を達成できます。このままの定義では<code>head</code>関数を使用しようとすると型エラーになるのです。</p>
<pre class="text"><code>&gt; Partial.head [1, 2, 3]
  
Error in declaration it
No instance found for Partial.Partial </code></pre>
<p>このライブラリを使うには、2つの選択肢があります。</p>
<ul>
<li><p>このモジュールで<code>Partial</code>型クラスのインスタンスを定義し、そのモジュールの関数が部分的であることを了承したと表明します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Partial</span>

<span class="kw">instance</span><span class="ot"> partial ::</span> <span class="dt">Partial</span></code></pre></li>
<li><p>あるいは、これらの部分関数を利用するすべての関数で <code>Partial</code>制約を再発行する方法もあります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">secondElement ::</span> forall a<span class="fu">.</span> (<span class="dt">Partial</span>) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
secondElement xs <span class="fu">=</span> head (tail xs)</code></pre></li>
</ul>
<h2 id="上位クラス"><span class="header-section-number">6.10</span> 上位クラス</h2>
<p>インスタンスを別のインスタンスに依存させることによって型クラスのインスタンス間の関係を表現することができるように、いわゆる<strong>上位クラス</strong>(superclass)を使って型クラス間の関係を表現することができます。</p>
<p>あるクラスのどんなインスタンスも、その他のあるクラスのインスタンスで必要とされているとき、前者の型クラスは後者の型クラスの上位クラスであるといい、クラス定義で逆向きの太い矢印を使い上位クラス関係を示します。</p>
<p>すでに上位クラスの関係の一例について見ています。<code>Eq</code>クラスは<code>Ord</code>の上位クラスです。<code>Ord</code>クラスのすべての型クラスインスタンスについて、その同じ型に対応する<code>Eq</code>インスタンスが存在しなければなりません。<code>compare</code>関数が2つの値が比較できないと報告した時は、それらが実は同値であるかどうかを決定するために<code>Eq</code>クラスを使いたくなることが多いでしょうから、これは理にかなっています。</p>
<p>一般に、下位クラスの法則が上位クラスのメンバに言及しているとき、上位クラス関係を定義するのは理にかなっています。例えば、<code>Ord</code>と<code>Eq</code>のインスタンスのどんな組についても、もしふたつの値が<code>Eq</code>インスタンスのもとで同値であるなら、<code>compare</code>関数は<code>EQ</code>を返すはずだとみなすのは妥当です。言い換えれば、<code>a == b</code>ならば<code>compare a b == EQ</code>です。法則の階層上のこの関係は、<code>Eq</code>と<code>Ord</code>の間の上位クラス関係を説明します。</p>
<p>この場合に上位クラス関係を定義する別の考え方としては、この２つのクラスの間には明らかに&quot;is-a&quot;の関係があることです。下位クラスのすべてのメンバは、上位クラスのメンバでもあるということです。</p>
<blockquote>
<h3 id="演習-15" class="unnumbered">演習</h3>
<ol type="1">
<li><p>(やや難しい) 次の<code>Action</code>クラスは、ある型の動作(action)を定義する、多変数型クラスです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Monoid</span> m) <span class="fu">&lt;=</span> <span class="dt">Action</span> m a <span class="kw">where</span>
<span class="ot">  act ::</span> m <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</code></pre>
<p><strong>act</strong>はモノイドがどうやって他の型の値を変更するのに使われるのかを説明する関数です。この動作が　モノイドの連結演算子に従っていると期待しましょう。例えば、乗算を持つ自然数のモノイドは、文字列の何度かの繰り返しとして文字列に対して<strong>動作</strong>します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> repeatAction ::</span> <span class="dt">Action</span> <span class="dt">Number</span> <span class="dt">String</span> <span class="kw">where</span>
  act <span class="dv">0</span> _ <span class="fu">=</span> <span class="st">&quot;&quot;</span>
  act n s <span class="fu">=</span> s <span class="fu">++</span> act (n <span class="fu">-</span> <span class="dv">1</span>) s</code></pre>
<p><code>Action</code>クラスが<code>Monoid</code>クラスとどのように連携するかを説明する、妥当な法則を書いてみましょう。</p></li>
<li><p>(やや難しい) インスタンス <code>Action m a =&gt; Action m [a]</code>を書いてみましょう。ここで、 配列上の動作は要素の順序で実行されるように定義されるものとします。</p></li>
<li><p>(難しい) 以下のnewtypeが与えられたとき、<code>Action m (Self m)</code>のインスタンスを書いてみましょう。ここで、モノイド<code>m</code>は連結によって自身に作用するものとします。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Self</span> m <span class="fu">=</span> <span class="dt">Self</span> m</code></pre></li>
<li><p>(やや難しい) 引数のない型クラス<code>Unsafe</code>を定義し、型安全性を欠いていることを表現する制約としてそれを使い、<code>Prelude.Unsafe</code>モジュールから<code>unsafeIndex</code>関数の別バージョンを定義してみましょう。また、その関数を使って、 <code>Unsafe</code>制約を失わないように、配列の最後の要素を選択する<code>last</code>を定義してみましょう。</p></li>
</ol>
</blockquote>
<h2 id="ハッシュの型クラス"><span class="header-section-number">6.11</span> ハッシュの型クラス</h2>
<p>この最後の節では、章の残りを費やしてデータ構造をハッシュするライブラリを作ります。</p>
<p>このライブラリの目的は説明だけであり、堅牢なハッシングの仕組みの提供を目的としていないことに注意してください。</p>
<p>ハッシュ関数に期待される性質とはどのようなものでしょうか？</p>
<ul>
<li>ハッシュ関数は決定的でなくてはなりません。つまり、同じ値には同じハッシュ値を対応させなければなりません</li>
<li>ハッシュ関数はいろいろなハッシュ値の集合で結果が一様に分布しなければなりません。</li>
</ul>
<p>最初の性質はまさに型クラスの法則のように見える一方で、２番目の性質はもっとぼんやりとした規約に従っていて、PureScriptの型システムによって確実に強制できるようなものではなさそうです。しかし、これは型クラスについて次のような直感的理解を与えるはずです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">HashCode</span> <span class="fu">=</span> <span class="dt">Number</span>

<span class="kw">class</span> (<span class="dt">Eq</span> a) <span class="fu">&lt;=</span> <span class="dt">Hashable</span> a <span class="kw">where</span>
<span class="ot">  hash ::</span> a <span class="ot">-&gt;</span> <span class="dt">HashCode</span> </code></pre>
<p>これに、<code>a == b</code>ならば<code>hash a == hash b</code>という関係性の法則が付随しています。</p>
<p>この節の残りの部分を費やして、<code>Hashable</code>型クラスに関連付けられているインスタンスと関数のライブラリを構築していきます。</p>
<p>決定的な方法でハッシュ値を結合する方法が必要になります。２つのハッシュ値を混ぜて結果を0-65535の間に分布させる次のような関数がその要求を満たしています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&lt;#&gt;) ::</span> <span class="dt">HashCode</span> <span class="ot">-&gt;</span> <span class="dt">HashCode</span> <span class="ot">-&gt;</span> <span class="dt">HashCode</span>
(<span class="fu">&lt;#&gt;</span>) h1 h2 <span class="fu">=</span> (<span class="dv">73</span> <span class="fu">*</span> h1 <span class="fu">+</span> <span class="dv">51</span> <span class="fu">*</span> h2) <span class="fu">%</span> <span class="dv">65536</span></code></pre>
<p>この演算子を使うと、２つのハッシュ値<code>h1</code>、<code>h2</code>を、<code>h1 &lt;#&gt; h2</code>.というように中置で連結することができます。</p>
<p>それでは、入力の種類を制限する<code>Hashable</code>制約を使う関数を書いてみましょう。ハッシュ関数を必要とするよくある目的としては、2つの値が同じハッシュ値にハッシュされるかどうかを決定することです。<code>hashEqual</code>関係はそのような機能を提供します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">hashEqual ::</span> forall a<span class="fu">.</span> (<span class="dt">Hashable</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Boolean</span>
hashEqual <span class="fu">=</span> (<span class="fu">==</span>) <span class="ot">`on`</span> hash</code></pre>
<p>この関数はハッシュ同値性を定義するために<code>Data.Function</code>の<code>on</code>関数を使っていますが、このハッシュ同値性の定義は『それぞれの値が<code>hash</code>関数に渡されたあとで２つの値が等しいなら、それらの値は「ハッシュ同値」である』というように宣言的に読めるはずです。</p>
<p>プリミティブ型の<code>Hashable</code>インスタンスをいくつか書いてみましょう。まずは文字列のインスタンスです。<code>Data.String</code>モジュールにある<code>length</code>、<code>charCodeAt</code>という名前の関数を使います。以下の <code>Hashable</code>インスタンスは、累積されたハッシュ値と文字コードを<code>&lt;＃&gt;</code>演算子を使って連結するという動作を、文字列中の文字に対して反復します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> hashString ::</span> <span class="dt">Hashable</span> <span class="dt">String</span> <span class="kw">where</span>
  hash s <span class="fu">=</span> go <span class="dv">0</span> <span class="dv">0</span>
    <span class="kw">where</span>
<span class="ot">    go ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">HashCode</span> <span class="ot">-&gt;</span> <span class="dt">HashCode</span>
    go i acc <span class="fu">|</span> i <span class="fu">&gt;=</span> length s <span class="fu">=</span> acc
    go i acc <span class="fu">=</span> go (i <span class="fu">+</span> <span class="dv">1</span>) acc <span class="fu">&lt;#&gt;</span> charCodeAt i s</code></pre>
<p><code>Number</code>型のインスタンスについてはどうでしょうか。小数や無限大が出現するせいでJavaScriptの<code>Number</code>型を扱うといろいろ問題が生じますが、ここでは説明が目的なので、単純に<code>show</code>で計算された数値の文字列表現をハッシュすることにします。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> hashNumber ::</span> <span class="dt">Hashable</span> <span class="dt">Number</span> <span class="kw">where</span>
  hash n <span class="fu">=</span> hash (show n)</code></pre>
<p><code>Number</code> の型クラスインスタンスは必ず<code>String</code>の型クラスインスタンスを使うことに注意してください。</p>
<p><code>Boolean</code>型のインスタンスではさらに簡単です。単に型の2つの値に2つのハッシュ値を静的に割り当てるだけです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> hashBoolean ::</span> <span class="dt">Hashable</span> <span class="dt">Boolean</span> <span class="kw">where</span>
  hash false <span class="fu">=</span> <span class="dv">0</span>
  hash true  <span class="fu">=</span> <span class="dv">1</span></code></pre>
<p>これらの <code>Hashable</code>インスタンスが先ほどの型クラスの法則を満たしていることを証明するにはどうしたらいいでしょうか。同じ値が等しいハッシュ値を持っていることを確認する必要があります。<code>String</code>と<code>Boolean</code>の場合は、<code>Eq</code>の意味では同じ値でも厳密には同じではない、というような文字列や真偽値は存在しないので簡単です。</p>
<p>数値の場合は同じ数が同​​じ文字列表現を持っていることを簡単に説明しておかなければなりませんが、そうすれば後は文字列に対してすでに与えられた証明に従うことができます。</p>
<p>もっと面白い型についてはどうでしょうか。<code>&lt;#&gt;</code>使って入力配列の要素のハッシュ値を組み合わせた、配列の<code>Hashable</code>インスタンスは、次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> hashArray ::</span> (<span class="dt">Hashable</span> a) <span class="ot">=&gt;</span> <span class="dt">Hashable</span> [a] <span class="kw">where</span>
  hash [] <span class="fu">=</span> <span class="dv">0</span>
  hash (x <span class="fu">:</span> xs) <span class="fu">=</span> hash x <span class="fu">&lt;#&gt;</span> hash xs</code></pre>
<p>この場合、配列の長さに関する帰納を使うと、型クラスの法則を証明することができます。長さゼロの唯一の配列は <code>[]</code>です。配列の<code>Eq</code>の定義により、任意の二つの空でない配列は、それらの先頭の要素が同じで配列の残りの部分が等しいとき、その時に限り等しくなります。この帰納的な仮定により、配列の残りの部分は同じハッシュ値を持ちますし、もし<code>Hashable a</code>インスタンスがこの法則を満たすなら、先頭の要素も同じハッシュ値をもつことがわかります。したがって、２つの配列は同じハッシュ値を持ち、<code>Hashable [a]</code>も同様に型クラス法則を満たしています。</p>
<p>この章のソースコードには、 <code>Maybe</code>と<code>Tuple</code>型のインスタンスなど、他にも <code>Hashable</code>インスタンスの例が含まれています。</p>
<blockquote>
<h3 id="演習-16" class="unnumbered">演習</h3>
<ol type="1">
<li><p>(簡単) <code>psci</code>を使って、各インスタンスのハッシュ関数をテストしてください。</p></li>
<li><p>(やや難しい) 同値性の近似として<code>hashEqual</code>関数のハッシュ同値性を使い、配列が重複する要素を持っているかどうかを調べる関数を書いてください。ハッシュ値が一致したペアが見つかった場合は、<code>==</code>を使って値の同値性を厳密に検証することを忘れないようにしてください。</p></li>
<li><p>(やや難しい) 型クラスの法則を満たす、次のnewtypeの <code>Hashable</code>インスタンスを書いてください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Uniform</span> <span class="fu">=</span> <span class="dt">Uniform</span> <span class="dt">Number</span>

<span class="kw">instance</span><span class="ot"> eqUniform ::</span> <span class="dt">Eq</span> <span class="dt">Uniform</span> <span class="kw">where</span>
  (<span class="fu">==</span>) (<span class="dt">Uniform</span> u1) (<span class="dt">Uniform</span> u2) <span class="fu">=</span> u1 <span class="fu">%</span> <span class="fl">1.0</span> <span class="fu">==</span> u2 <span class="fu">%</span> <span class="fl">1.0</span> 
  (<span class="fu">/=</span>) (<span class="dt">Uniform</span> u1) (<span class="dt">Uniform</span> u2) <span class="fu">=</span> u1 <span class="fu">%</span> <span class="fl">1.0</span> <span class="fu">/=</span> u2 <span class="fu">%</span> <span class="fl">1.0</span> </code></pre>
<p>newtypeの<code>Uniform</code>とその<code>Eq</code>インスタンスは、同じ小数部分を持っているかの同値関係を持つ数の型を表しています。そのインスタンスが型クラスの法則を満たしていることを証明してください。</p></li>
<li><p>(難しい) <code>Maybe</code>、<code>Either</code>、<code>Tuple</code>の<code>Hashable</code>インスタンスが型クラスの法則を満たしていることを証明してください。</p></li>
</ol>
</blockquote>
<h2 id="まとめ-4"><span class="header-section-number">6.12</span> まとめ</h2>
<p>この章では、型に基づく抽象化で、コードの再利用のための強力な形式化を可能にする<strong>型クラス</strong>を導入しました。PureScriptの標準ライブラリから標準の型クラスを幾つか見てきました。また、ハッシュ値を計算する型クラスに基づく独自のライブラリを定義しました。</p>
<p>この章では型クラス法則の考え方を導入するとともに、抽象化のための型クラスを使うコードについて、その性質を証明する手法を導入しました。型クラス法則は<strong>等式推論</strong>(equational reasoning)と呼ばれる大きな分野の一部であり、プログラミング言語の性質と型システムはプログラムについて論理的な推論をできるようにするために使われています。これは重要な考え方で、本書では今後あらゆる箇所で立ち返る話題となるでしょう。</p>
<h1 id="applicativeによる検証"><span class="header-section-number">7</span> Applicativeによる検証</h1>
<h2 id="この章の目標-4"><span class="header-section-number">7.1</span> この章の目標</h2>
<p>この章では、<code>Applicative</code>型クラスによって表現される<strong>Applicative関手</strong>(applicative functor)という重要な抽象化と新たに出会うことになります。名前が難しそうに思えても心配しないでください。フォームデータの検証という実用的な例を使ってこの概念を説明していきます。Applicative関手を使うと、大量の決まり文句を伴うような入力項目の内容を検証するためのコードを、簡潔で宣言的な記述へと変えることができるようになります。</p>
<p>また、<strong>Traversable関手</strong>(traversable functor)を表現する<code>Traversable</code>という別の型クラスにも出会います。現実の問題への解決策からこの概念が自然に生じるということがわかるでしょう。</p>
<p>この章では第3章から引き続き電話帳を例として扱います。今回は電話番号だけでなく住所を含む<strong>住所録</strong>のデータ型を定義し、これらの型の値を検証する関数を書きます。これらの関数は、例えばデータ入力フォームの一部で、使用者へエラーを表示するウェブユーザインターフェイスで使われると考えてください。　　　　</p>
<h2 id="プロジェクトの準備-4"><span class="header-section-number">7.2</span> プロジェクトの準備</h2>
<p>この章のソース·コードは、<code>src/Data/AddressBook.purs</code>と<code>src/Data/AddressBook/Validation.purs</code>というファイルで定義されています。</p>
<p>このプロジェクトは多くのBower依存関係を持っていますが、その大半はすでに見てきたものです。新しい依存関係は２つです。</p>
<ul>
<li><code>purescript-control</code> - <code>Applicative</code> のような型クラスを使用して制御フローを抽象化する関数が定義されています</li>
<li><code>purescript-validation</code> - この章の主題である<strong><code>Applicative</code>による検証</strong>のための関手が定義されています。</li>
</ul>
<p><code>Data.AddressBook</code>モジュールには、このプロジェクトのデータ型とそれらの型に対する<code>Show</code>インスタンスが定義されており、<code>Data.AddressBook.Validation</code>モジュールにはそれらの型の検証規則含まれています。</p>
<h2 id="関数適用の一般化"><span class="header-section-number">7.3</span> 関数適用の一般化</h2>
<p><strong>Applicative関手</strong>の概念を理解するために、まずは以前に見た型構築子<code>Maybe</code>について考えてみましょう。</p>
<p>このモジュールのソースコードでは、次のような型を持つ<code>address</code>関数が定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">address ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Address</span></code></pre>
<p>この関数は、通りの名前、市、州という３つの文字列から型<code>Address</code>の値を構築するために使います。</p>
<p>この関数は簡単に適用できますので、<code>psci</code>でどうなるか見てみましょう。</p>
<pre class="text"><code>&gt; :i Data.AddressBook

&gt; address &quot;123 Fake St.&quot; &quot;Faketown&quot; &quot;CA&quot;
Address { street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; }</code></pre>
<p>しかし、通り、市、州の３つすべてが必ずしも入力されないものとすると、3つの場合それぞれで省略可能である値を示すために<code>Maybe</code>型を使用したくなります。</p>
<p>考えられる場合のひとつとしては、市が省略されている場合があるかもしれません。もし<code>address</code>関数を直接適用しようとすると、型検証器からエラーが表示されます。</p>
<pre class="text"><code>&gt; :i Data.Maybe
&gt; address (Just &quot;123 Fake St.&quot;) Nothing (Just &quot;CA&quot;)

Cannot unify Data.Maybe.Maybe u2 with Prim.String.</code></pre>
<p><code>address</code>は型<code>Maybe String</code>ではなく文字列型の引数を取るので、もちろんこれは予想どおりの型エラーです。</p>
<p>しかし、<code>Maybe</code>型で示される省略可能な値を扱うために<code>address</code>関数を「持ち上げ」ることができるはずだと期待することは理にかなっています。実際、<code>Control.Apply</code>で提供されている関数<code>lift3</code>がまさに求めているものです。</p>
<pre class="text"><code>&gt; :i Control.Apply
&gt; lift3 address (Just &quot;123 Fake St.&quot;) Nothing (Just &quot;CA&quot;)

Nothing</code></pre>
<p>このとき、引数のひとつ(市)が欠落していたので、結果は、<code>Nothing</code>です。もし3つの引数すべてが<code>Just</code>構築子を使って与えられると、結果は値を含むことになります。</p>
<pre class="text"><code>&gt; lift3 address (Just &quot;123 Fake St.&quot;) (Just &quot;Faketown&quot;) (Just &quot;CA&quot;)
  
Just (Address { street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; })</code></pre>
<p><code>lift3</code>という関数の名前は、3引数の関数を持ち上げるために使用できることを示しています。引数の数が異なる関数を持ち上げる同様の関数が<code>Control.Apply</code>で定義されています。</p>
<h2 id="任意個の引数を持つ関数の持ち上げ"><span class="header-section-number">7.4</span> 任意個の引数を持つ関数の持ち上げ</h2>
<p>これで、<code>lift2</code>や<code>lift3</code>のような関数を使えば、引数が2個や3個の関数を持ち上げることができるのはわかりました。でも、これを任意個の引数の関数へと一般化することはできるのでしょうか。</p>
<p><code>lift3</code> の型を見てみるとわかりやすいでしょう。</p>
<pre class="text"><code>&gt; :t Control.Apply.lift3
forall a b c d f. (Prelude.Apply f) =&gt; (a -&gt; b -&gt; c -&gt; d) -&gt; f a -&gt; f b -&gt; f c -&gt; f d</code></pre>
<p>上の<code>Maybe</code>の例では型構築子<code>f</code>は<code>Maybe</code>ですから、<code>lift3</code>は次のように特殊化されます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">forall a b c d<span class="fu">.</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> c <span class="ot">-&gt;</span> <span class="dt">Maybe</span> d</code></pre>
<p>この型が言っているのは、3引数の任意の関数を取り、その関数を引数と返り値が<code>Maybe</code>で包まれた新しい関数へと持ち上げる、ということです。</p>
<p>もちろんどんな型構築子<code>f</code>についても持ち上げができるわけではないのですが、それでは<code>Maybe</code>型を持ち上げができるようにしているのは何なのでしょうか。さて、先ほどの型の特殊化では、<code>f</code>に対する型クラス制約から<code>Apply</code>型クラスを取り除いていました。<code>Apply</code>はPreludeで次のように定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span>
<span class="ot">  (&lt;$&gt;) ::</span> forall a b<span class="fu">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b
  
<span class="kw">class</span> (<span class="dt">Functor</span> f) <span class="fu">&lt;=</span> <span class="dt">Apply</span> f <span class="kw">where</span>
<span class="ot">  (&lt;*&gt;) ::</span> forall a b<span class="fu">.</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre>
<p><code>Apply</code>型クラスは<code>Functor</code>の下位クラスであり、<code>&lt;$&gt;</code>とよく似た型を持つ追加の関数<code>&lt;*&gt;</code>が定義されています。<code>&lt;$&gt;</code>と<code>&lt;*&gt;</code>の違いは、<code>&lt;$&gt;</code>がただの関数を引数に取るのに対し、<code>&lt;*&gt;</code>の最初の引数は型構築子<code>f</code>で包まれているという点です。これをどのように使うのかはこれからすぐに見ていきますが、その前にまず<code>Maybe</code>型について<code>Apply</code>型クラスをどう実装するのかを見ていきましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> functorMaybe ::</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span>
  (<span class="fu">&lt;$&gt;</span>) f (<span class="dt">Just</span> a) <span class="fu">=</span> <span class="dt">Just</span> (f a)
  (<span class="fu">&lt;$&gt;</span>) f <span class="dt">Nothing</span>  <span class="fu">=</span> <span class="dt">Nothing</span>
  
<span class="kw">instance</span><span class="ot"> applyMaybe ::</span> <span class="dt">Apply</span> <span class="dt">Maybe</span> <span class="kw">where</span>
  (<span class="fu">&lt;*&gt;</span>) (<span class="dt">Just</span> f) (<span class="dt">Just</span> x) <span class="fu">=</span> <span class="dt">Just</span> (f x)
  (<span class="fu">&lt;*&gt;</span>) _        _        <span class="fu">=</span> <span class="dt">Nothing</span></code></pre>
<p>この型クラスのインスタンスが言っているのは、任意のオプショナルな値にオプショナルな関数を適用することができ、その両方が定義されている時に限り結果も定義される、ということです。</p>
<p>それでは、<code>&lt;$&gt;</code>と<code>&lt;*&gt;</code>を一緒に使ってどうやって引数が任意個の関数を持ち上げるのかを見ていきましょう。</p>
<p>１引数の関数については、<code>&lt;$&gt;</code>をそのまま使うだけです。</p>
<p>２引数の関数についても考えてみます。型<code>a -&gt; b -&gt; c</code>を持つカリー化された関数<code>f</code>があるとしましょう。これは型<code>a -&gt; (b -&gt; c)</code>と同じですから、<code>&lt;$&gt;</code> を<code>f</code>に適用すると型<code>f a -&gt; f (b -&gt; c)</code>の新たな関数を得ることになります。持ち上げられた(型<code>f a</code>の)最初の引数にその関数を部分適用すると、型<code>f (b -&gt; c)</code>の新たな包まれた関数が得られます。それから、２番目の持ち上げられた(型<code>f b</code>の)引数へ<code>&lt;*&gt;</code>を適用することができ、型<code>f c</code>の最終的な値を得ます。</p>
<p>まとめると、もし <code>x :: f a</code>と<code>y :: f b</code>があるなら、式<code>(f &lt;$&gt; x) &lt;*&gt; y</code>は型<code>f c</code>を持つことがわかりました。Preludeで定義された優先順位の規則に従うと、<code>f &lt;$&gt; x &lt;*&gt; y</code>というように括弧を外すことができます。</p>
<p>一般的にいえば、最初の引数に<code>&lt;$&gt;</code>を使い、残りの引数に対しては<code>&lt;*&gt;</code>を使います。<code>lift3</code>で説明すると次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lift3 ::</span> forall a b c d f<span class="fu">.</span> (<span class="dt">Prelude.Apply</span> f) <span class="ot">=&gt;</span> 
                           (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> 
                           f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c <span class="ot">-&gt;</span> f d
lift3 f x y z <span class="fu">=</span> f <span class="fu">&lt;$&gt;</span> x <span class="fu">&lt;*&gt;</span> y <span class="fu">&lt;*&gt;</span> z</code></pre>
<p>この式の型がちゃんと整合しているかの確認は、読者への演習として残しておきます。</p>
<p>例として、<code>&lt;$&gt;</code>と<code>&lt;*&gt;</code>をそのまま使うと、<code>Maybe</code>上に<code>address</code>関数を持ち上げることができます。</p>
<pre class="text"><code>&gt; address &lt;$&gt; Just &quot;123 Fake St.&quot; &lt;*&gt; Just &quot;Faketown&quot; &lt;*&gt; Just &quot;CA&quot;

Just (Address { street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; })

&gt; address &lt;$&gt; Just &quot;123 Fake St.&quot; &lt;*&gt; Nothing &lt;*&gt; Just &quot;CA&quot;

Nothing</code></pre>
<p>このように、引数が異なる他のいろいろな関数を<code>Maybe</code>上に持ち上げてみてください。</p>
<h2 id="applicative型クラス"><span class="header-section-number">7.5</span> Applicative型クラス</h2>
<p>これに関連する<code>Applicative</code>という型クラスが存在しており、次のように定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Apply</span> f) <span class="fu">&lt;=</span> <span class="dt">Applicative</span> f <span class="kw">where</span>
<span class="ot">  pure ::</span> forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> f a</code></pre>
<p><code>Applicative</code>は<code>Apply</code>の下位クラスであり、 <code>pure</code>関数が定義されています。 <code>pure</code>は値を取り、その型の型構築子<code>f</code>で包まれた値を返します。</p>
<p><code>Maybe</code>についての<code>Applicative</code>インスタンスは次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> applicativeMaybe ::</span> <span class="dt">Applicative</span> <span class="dt">Maybe</span> <span class="kw">where</span>
  pure x <span class="fu">=</span> <span class="dt">Just</span> x</code></pre>
<p>Applicative関手は関数を持ち上げることを可能にする関手だと考えるとすると、<code>pure</code>は引数のない関数の持ち上げだというように考えることができます。</p>
<h2 id="applicativeに対する直感的理解"><span class="header-section-number">7.6</span> Applicativeに対する直感的理解</h2>
<p>PureScriptの関数は純粋であり、副作用は持っていません。Applicative関手は、関手<code>f</code>によって表現されたある種の副作用を提供するような、より大きな「プログラミング言語」を扱えるようにします。</p>
<p>たとえば、関手<code>Maybe</code>はオプショナルな値の副作用を表現しています。その他の例としては、型<code>err</code>のエラーの可能性の副作用を表す<code>Either err</code>や、大域的な構成を読み取る副作用を表すArrow関手(arrow functor)<code>r -&gt;</code>があります。ここでは<code>Maybe</code>関手についてだけを考えることにします。</p>
<p>もし関手<code>f</code>が作用を持つより大きなプログラミング言語を表すとすると、<code>Apply</code>と<code>Applicative</code>インスタンスは小さなプログラミング言語(PureScript)から新しい大きな言語へと値や関数を持ち上げることを可能にします。</p>
<p><code>pure</code>は純粋な(副作用がない)値をより大きな言語へと持ち上げますし、関数については上で述べたとおり<code>&lt;$&gt;</code>と<code>&lt;*&gt;</code>を使うことができます。</p>
<p>ここで新たな疑問が生まれます。もしPureScriptの関数と値を新たな言語へ埋め込むのに<code>Applicative</code>が使えるなら、どうやって新たな言語は大きくなっているというのでしょうか。この答えは関手<code>f</code>に依存します。もしなんらかの<code>x</code>について<code>pure x</code>で表せないような型<code>f a</code>の式を見つけたなら、その式はそのより大きな言語だけに存在する項を表しているということです。</p>
<p><code>f</code>が<code>Maybe</code>のときの式<code>Nothing</code>がその例になっています。<code>Nothing</code>を何らかの<code>x</code>について<code>pure x</code>というように書くことはできません。したがって、PureScriptは省略可能な値を表す新しい項 <code>Nothing</code>を含むように拡大されたと考えることができます。</p>
<h2 id="その他の作用について"><span class="header-section-number">7.7</span> その他の作用について</h2>
<p>それでは、他にも<code>Applicative</code>関手へと関数を持ち上げる例をいろいろ見ていきましょう。</p>
<p>次は、<code>psci</code>で定義された3つの名前を結合して完全な名前を作る簡単なコード例です。</p>
<pre class="text"><code>&gt; let fullName first middle last = last ++ &quot;, &quot; ++ first ++ &quot; &quot; ++ middle 

&gt; fullName &quot;Phillip&quot; &quot;A&quot; &quot;Freeman&quot;
Freeman, Phillip A</code></pre>
<p>この関数は、クエリパラメータとして与えられた3つの引数を持つ、(とても簡単な!)ウェブサービスの実装であるとしましょう。使用者が3つの引数すべてを与えたことを確かめたいので、引数が存在するかどうかを表す<code>Maybe</code>型をつかうことになるでしょう。<code>fullName</code>を<code>Maybe</code>の上へ持ち上げると、省略された引数を確認するウェブサービスを実装することができます。</p>
<pre class="text"><code>&gt; :i Data.Maybe
&gt; fullName &lt;$&gt; Just &quot;Phillip&quot; &lt;*&gt; Just &quot;A&quot; &lt;*&gt; Just &quot;Freeman&quot;
  
Just (&quot;Freeman, Phillip A&quot;)

&gt; fullName &lt;$&gt; Just &quot;Phillip&quot; &lt;*&gt; Nothing &lt;*&gt; Just &quot;Freeman&quot;
  
Nothing</code></pre>
<p>この持ち上げた関数は、引数のいずれかが <code>Nothing</code>なら<code>Nothing</code>返すことに注意してください。</p>
<p>これで、もし引数が不正ならWebサービスからエラー応答を送信することができるので、なかなかいい感じです。しかし、どのフィールドが間違っていたのかを応答で表示できると、もっと良くなるでしょう。</p>
<p><code>Meybe</code>上へ持ち上げる代わりに<code>Either String</code>上へ持ち上げるようにすると、エラーメッセージを返すことができるようになります。まずは入力を<code>Either String</code>を使ってエラーを発信できる計算に変換する演算子を書きましょう。</p>
<pre class="text"><code>&gt; let (&lt;?&gt;) Nothing  err = Left err
      (&lt;?&gt;) (Just a) _ = Right a</code></pre>
<p><strong>注意</strong>： <code>Either err</code>Applicative関手において、<code>Left</code>構築子は失敗を表しており、<code>Right</code>構築子は成功を表しています。</p>
<p>これで<code>Either String</code>上へ持ち上げることで、それぞれの引数について適切なエラーメッセージを提供できるようになります。</p>
<pre class="text"><code>&gt; let fullNameEither first middle last = 
    fullName &lt;$&gt; (first  &lt;?&gt; &quot;First name was missing&quot;)
             &lt;*&gt; (middle &lt;?&gt; &quot;Middle name was missing&quot;)
             &lt;*&gt; (last   &lt;?&gt; &quot;Last name was missing&quot;)
  
&gt; :t fullNameEither
Maybe String -&gt; Maybe String -&gt; Maybe String -&gt; Either String String</code></pre>
<p>この関数は<code>Maybe</code>の3つの省略可能な引数を取り、<code>String</code>のエラーメッセージか<code>String</code>の結果のどちらかを返します。</p>
<p>いろいろな入力でこの関数を試してみましょう。</p>
<pre class="text"><code>&gt; fullNameEither (Just &quot;Phillip&quot;) (Just &quot;A&quot;) (Just &quot;Freeman&quot;)
Right (&quot;Freeman, Phillip A&quot;)

&gt; fullNameEither (Just &quot;Phillip&quot;) Nothing (Just &quot;Freeman&quot;)
Left (&quot;Middle name was missing&quot;)

&gt; fullNameEither (Just &quot;Phillip&quot;) (Just &quot;A&quot;) Nothing
Left (&quot;Last name was missing&quot;)</code></pre>
<p>このとき、すべてのフィールドが与えられば成功の結果が表示され、そうでなければ省略されたフィールドのうち最初のものに対応するエラーメッセージが表示されます。しかし、もし複数の入力が省略されているとき、最初のエラーしか見ることができません。</p>
<pre class="text"><code>&gt; fullNameEither Nothing Nothing Nothing
  
Left (&quot;First name was missing&quot;)</code></pre>
<p>これでも十分なときもありますが、エラー時に<strong>すべての</strong>省略されたフィールドの一覧がほしいときは、<code>Either String</code>よりも強力なものが必要です。この章の後半でこの解決策を見ていきます。</p>
<h2 id="作用の結合"><span class="header-section-number">7.8</span> 作用の結合</h2>
<p>抽象的にApplicative関手を扱う例として、Applicative関手<code>f</code>によって表現された副作用を総称的に組み合わせる関数をどのように書くのかをこの節では示します。</p>
<p>これはどういう意味でしょうか？何らかの<code>a</code>について型 <code>f a</code>の包まれた引数の配列があるとしましょう。型<code>[f a]</code>の配列があるということです。直感的には、これは<code>f</code>によって追跡される副作用を持つ、返り値の型が<code>a</code>の計算の配列を表しています。これらの計算のすべてを順番に実行することができれば、<code>[a]</code>型の結果の配列を得るでしょう。しかし、まだ<code>f</code> によって追跡される副作用が残ります。つまり、元の配列の中の作用を「結合する」ことにより、型<code>[f a]</code>の何かを型<code>f [a]</code>の何かへと変換することができると考えられます。</p>
<p>任意の固定長配列の長さ <code>n</code> について、その引数を要素に持った長さ<code>n</code>の配列を構築するような<code>n</code>引数の関数が存在します。たとえば、もし <code>n</code>が<code>3</code>なら、関数は<code>\x y z -&gt; [x, y, z]</code>です。 この関数の型は<code>a -&gt; a -&gt; a -&gt; [a]</code>です。<code>Applicative</code>インスタンスを使うと、この関数を<code>f</code>の上へ持ち上げて関数型<code>f a -&gt; f a -&gt; f a -&gt; f [a]</code>を得ることができます。しかし、いかなる<code>n</code>についてもこれが可能なので、いかなる引数の<strong>配列</strong>についても同じように持ち上げられることが確かめられます。</p>
<p>したがって、次のような関数を書くことができるはずです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">combineArray ::</span> forall f a<span class="fu">.</span> (<span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> [f a] <span class="ot">-&gt;</span> f [a]</code></pre>
<p>この関数は副作用を持つかもしれない引数の配列をとり、それぞれの副作用を適用することで、<code>f</code>に包まれた単一の配列を返します。</p>
<p>この関数を書くためには、引数の配列の長さについて考えます。配列が空の場合はどんな作用も実行する必要はありませんから、<code>pure</code>を使用して単に空の配列を返すことができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">combineArray [] <span class="fu">=</span> pure []</code></pre>
<p>実際のところ、これが可能な唯一の​​定義です！</p>
<p>入力の配列が空でないならば、型<code>f a</code>の先頭要素と、型<code>[f a]</code>の配列の残りについて考えます。また、再帰的に配列の残りを結合すると、型<code>f [a]</code>の結果を得ることができます。<code>&lt;$&gt;</code>と<code>&lt;*&gt;</code>を使うと、<code>cons</code>関数を先頭と配列の残りの上に持ち上げることができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">combineArray (x <span class="fu">:</span> xs) <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> x <span class="fu">&lt;*&gt;</span> combineArray xs</code></pre>
<p>繰り返しになりますが、これは与えられた型に基づいている唯一の妥当な実装です。</p>
<p><code>Maybe</code>型構築子を例にとって、<code>psci</code>でこの関数を試してみましょう。</p>
<pre class="t"><code>&gt; combineArray [Just 1, Just 2, Just 3]
Just [1,2,3]

&gt; combineArray [Just 1, Nothing, Just 2]
Nothing</code></pre>
<p><code>Meybe</code>へ特殊化して考えると、配列のすべての要素が<code>Just</code>であるとき、そのときに限りこの関数は<code>Just</code>を返します。そうでなければ、<code>Nothing</code>を返します。オプショナルな結果を返す計算の配列は、そのすべての計算が結果を持っていたときに全体も結果を持っているという、オプショナルな値に対応したより大きな言語での振る舞いに対する直感的な理解とこれは一致しています。</p>
<p>しかも、<code>combineArray</code>関数はどんな<code>Applicative</code>に対しても機能します！<code>Either err</code>を使ってエラーを発信するかもしれなかったり、<code>r -&gt;</code>を使って大域的な状態を読み取る計算を連鎖させるときにも<code>combineArray</code>関数を使うことができるのです。</p>
<p><code>combineArray</code>関数については、後ほど<code>Traversable</code>関手について考えるときに再び扱います。</p>
<blockquote>
<h2 id="演習-17" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単) <code>lift2</code>を使って、オプショナルな引数に対して働く、数に対する演算子 <code>+</code>、 <code>-</code>、 <code>*</code>、<code>/</code>の持ち上げられたバージョンを書いてください。</p></li>
<li><p>(やや難しい) 上で与えられた<code>lift3</code>の定義について、<code>&lt;$&gt;</code>と<code>&lt;*&gt;</code> の型が整合していることを確認して下さい。</p></li>
<li><p>(難しい) 型<code>forall a f. (Applicative f) =&gt; Maybe (f a) -&gt; f (Maybe a)</code>を持つ関数<code>combineMaybe</code>を書いてください。この関数は副作用をもつオプショナルな計算をとり、オプショナルな結果をもつ副作用のある計算を返します。</p></li>
</ol>
</blockquote>
<h2 id="applicativeによる検証-1"><span class="header-section-number">7.9</span> Applicativeによる検証</h2>
<p>この章のソースコードでは電話帳アプリケーションで使われるいろいろなデータ型が定義されています。詳細はここでは割愛しますが、<code>Data.AddressBook</code>モジュールからエクスポートされる重要な関数は次のような型を持っています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">address ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Address</span>

<span class="ot">phoneNumber ::</span> <span class="dt">PhoneType</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">PhoneNumber</span>

<span class="ot">person ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Address</span> <span class="ot">-&gt;</span> [<span class="dt">PhoneNumber</span>] <span class="ot">-&gt;</span> <span class="dt">Person</span></code></pre>
<p>ここで、 <code>PhoneType</code>は次のような代数的データ型として定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">PhoneType</span> <span class="fu">=</span> <span class="dt">HomePhone</span> <span class="fu">|</span> <span class="dt">WorkPhone</span> <span class="fu">|</span> <span class="dt">CellPhone</span> <span class="fu">|</span> <span class="dt">OtherPhone</span></code></pre>
<p>これらの関数は住所録の項目を表す<code>Person</code>を構築するのに使います。例えば、<code>Data.AddressBook</code>には次のような値が定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">examplePerson ::</span> <span class="dt">Person</span>
examplePerson <span class="fu">=</span> 
  person <span class="st">&quot;John&quot;</span> <span class="st">&quot;Smith&quot;</span> 
         (address <span class="st">&quot;123 Fake St.&quot;</span> <span class="st">&quot;FakeTown&quot;</span> <span class="st">&quot;CA&quot;</span>) 
     [ phoneNumber <span class="dt">HomePhone</span> <span class="st">&quot;555-555-5555&quot;</span>
         , phoneNumber <span class="dt">CellPhone</span> <span class="st">&quot;555-555-0000&quot;</span>
     ]</code></pre>
<p><code>psci</code>でこれらの値使ってみましょう(結果は整形されています)。</p>
<pre class="text"><code>&gt; :i Data.AddressBook
&gt; examplePerson 

Person { 
  firstName: &quot;John&quot;, 
  lastName: &quot;Smith&quot;, 
  address: Address { 
    street: &quot;123 Fake St.&quot;, 
    city: &quot;FakeTown&quot;, 
    state: &quot;CA&quot; 
  }, 
  phones: [ PhoneNumber { 
    type: HomePhone, 
    number: &quot;555-555-5555&quot; 
  }, PhoneNumber { 
    type: CellPhone, 
    number: &quot;555-555-0000&quot; 
  }] 
}</code></pre>
<p>前の章では型<code>Person</code>のデータ構造を検証するのに<code>Either String</code>関手をどのように使うかを見ました。例えば、データ構造の２つの名前を検証する関数が与えられたとき、データ構造全体を次のように検証することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">nonEmpty ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Unit</span>
nonEmpty <span class="st">&quot;&quot;</span> <span class="fu">=</span> <span class="dt">Left</span> <span class="st">&quot;Field cannot be empty&quot;</span>
nonEmpty _  <span class="fu">=</span> <span class="dt">Right</span> unit

<span class="ot">validatePerson ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Person</span>
validatePerson (<span class="dt">Person</span> o) <span class="fu">=</span>
  person <span class="fu">&lt;$&gt;</span> (nonEmpty o<span class="fu">.</span>firstName <span class="fu">*&gt;</span> pure o<span class="fu">.</span>firstName)
         <span class="fu">&lt;*&gt;</span> (nonEmpty o<span class="fu">.</span>lastName  <span class="fu">*&gt;</span> pure o<span class="fu">.</span>lastName)
         <span class="fu">&lt;*&gt;</span> pure o<span class="fu">.</span>address
         <span class="fu">&lt;*&gt;</span> pure o<span class="fu">.</span>phones</code></pre>
<p>最初の２行では<code>nonEmpty</code>関数を使って空文字列でないことを検証しています。もし入力が空なら<code>nonEMpty</code>はエラーを返し(<code>Left</code>構築子で示されています)、そうでなければ<code>Right</code>構築子を使って空の値(<code>unit</code>)を正常に返します。２つの検証を実行し、右辺の検証の結果を返すことを示す連鎖演算子<code>*&gt;</code>を使っています。ここで、入力を変更せずに返す検証器として右辺では単に<code>pure</code>を使っています。</p>
<p>最後の２行では何の検証も実行せず、単に<code>address</code>フィールドと<code>phones</code>フィールドを残りの引数として<code>person</code>関数へと提供しています。</p>
<p>この関数は<code>psci</code>でうまく動作するように見えますが、以前見たような制限があります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> validatePerson <span class="fu">$</span> person <span class="st">&quot;&quot;</span> <span class="st">&quot;&quot;</span> (address <span class="st">&quot;&quot;</span> <span class="st">&quot;&quot;</span> <span class="st">&quot;&quot;</span>) []
  
<span class="dt">Left</span> (<span class="st">&quot;Field cannot be empty&quot;</span>)</code></pre>
<p><code>Either String</code>Applicative関手は遭遇した最初のエラーだけを返します。でもこの入力では、名前の不足と姓の不足という２つのエラーがわかるようにしたくなるでしょう。</p>
<p><code>purescript-validation</code>ライブラリは別のApplicative関手も提供されています。これは単に<code>V</code>と呼ばれていて、何らかの<strong>半群</strong>(Semigroup)でエラーを返す機能があります。たとえば、<code>V [String]</code>を使うと、新しいエラーを配列の最後に連結していき、<code>String</code>の配列をエラーとして返すことができます。</p>
<p><code>Data.Validation</code>モジュールは<code>Data.AddressBook</code>モジュールのデータ構造を検証するために <code>V [String]</code>Applicative関手を使っています。</p>
<p><code>Data.AddressBook.Validation</code>モジュールにある検証の例としては次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Errors</span> <span class="fu">=</span> [<span class="dt">String</span>]

<span class="ot">nonEmpty ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">V</span> <span class="dt">Errors</span> <span class="dt">Unit</span>
nonEmpty field <span class="st">&quot;&quot;</span> <span class="fu">=</span> invalid [<span class="st">&quot;Field &#39;&quot;</span> <span class="fu">++</span> field <span class="fu">++</span> <span class="st">&quot;&#39; cannot be empty&quot;</span>]
nonEmpty _     _  <span class="fu">=</span> pure unit

<span class="ot">lengthIs ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">V</span> <span class="dt">Errors</span> <span class="dt">Unit</span>
lengthIs field len value <span class="fu">|</span> S.length value <span class="fu">/=</span> len <span class="fu">=</span> 
  invalid [<span class="st">&quot;Field &#39;&quot;</span> <span class="fu">++</span> field <span class="fu">++</span> <span class="st">&quot;&#39; must have length &quot;</span> <span class="fu">++</span> show len]
lengthIs _     _   _     <span class="fu">=</span> 
  pure unit

<span class="ot">validateAddress ::</span> <span class="dt">Address</span> <span class="ot">-&gt;</span> <span class="dt">V</span> <span class="dt">Errors</span> <span class="dt">Address</span> 
validateAddress (<span class="dt">Address</span> o) <span class="fu">=</span> 
  address <span class="fu">&lt;$&gt;</span> (nonEmpty <span class="st">&quot;Street&quot;</span> o<span class="fu">.</span>street <span class="fu">*&gt;</span> pure o<span class="fu">.</span>street)
          <span class="fu">&lt;*&gt;</span> (nonEmpty <span class="st">&quot;City&quot;</span>   o<span class="fu">.</span>city   <span class="fu">*&gt;</span> pure o<span class="fu">.</span>city)
          <span class="fu">&lt;*&gt;</span> (lengthIs <span class="st">&quot;State&quot;</span> <span class="dv">2</span> o<span class="fu">.</span>state <span class="fu">*&gt;</span> pure o<span class="fu">.</span>state)</code></pre>
<p><code>validateAddress</code>は<code>Address</code>を検証します。<code>street</code>と<code>city</code>が空でないかどうか、<code>state</code>の文字列の長さが2であるかどうかを検証します。</p>
<p><code>nonEmpty</code>と<code>lengthIs</code>の２つの検証関数はいずれも、<code>Data.Validation</code>モジュールで提供されている<code>invalid</code>関数をエラーを示すために使っていることに注目してください。<code>[String]</code>半群を扱っているので、<code>invalid</code>は引数として文字列の配列を取ります。</p>
<p><code>psci</code> でこの関数を使ってみましょう。</p>
<pre class="text"><code>&gt; :i Data.AddressBook
&gt; :i Data.AddressBook.Validation

&gt; validateAddress $ address &quot;&quot; &quot;&quot; &quot;&quot;
  
Invalid ([ &quot;Field &#39;Street&#39; cannot be empty&quot;
         , &quot;Field &#39;City&#39; cannot be empty&quot;
         , &quot;Field &#39;State&#39; must have length 2&quot;
         ])

&gt; validateAddress $ address &quot;&quot; &quot;&quot; &quot;CA&quot;
  
Invalid ([ &quot;Field &#39;Street&#39; cannot be empty&quot;
         , &quot;Field &#39;City&#39; cannot be empty&quot;
         ])</code></pre>
<p>これで、すべての検証エラーの配列を受け取ることができるようになりました。</p>
<h2 id="正規表現検証器"><span class="header-section-number">7.10</span> 正規表現検証器</h2>
<p><code>validatePhoneNumber</code>関数では引数の形式を検証するために正規表現を使っています。重要なのは<code>matches</code>検証関数で、この関数は<code>Data.String.Regex</code>モジュールのて定義されている<code>Regex</code>を使って入力を検証しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">matches ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">R.Regex</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">V</span> <span class="dt">Errors</span> <span class="dt">Unit</span>
matches _     regex value <span class="fu">|</span> R.test regex value <span class="fu">=</span> 
  pure unit
matches field _     _     <span class="fu">=</span> 
  invalid [<span class="st">&quot;Field &#39;&quot;</span> <span class="fu">++</span> field <span class="fu">++</span> <span class="st">&quot;&#39; did not match the required format&quot;</span>]</code></pre>
<p>繰り返しになりますが、<code>pure</code>は常に成功する検証を表しており、エラーの配列の伝達には<code>invalid</code>が使われています。</p>
<p>これまでと同じような感じで、<code>validatePhoneNumber</code>は<code>matches</code>関数から構築されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">validatePhoneNumber ::</span> <span class="dt">PhoneNumber</span> <span class="ot">-&gt;</span> <span class="dt">V</span> <span class="dt">Errors</span> <span class="dt">PhoneNumber</span>
validatePhoneNumber (<span class="dt">PhoneNumber</span> o) <span class="fu">=</span> 
  phoneNumber <span class="fu">&lt;$&gt;</span> pure o<span class="fu">.</span><span class="st">&quot;type&quot;</span>
              <span class="fu">&lt;*&gt;</span> (matches <span class="st">&quot;Number&quot;</span> phoneNumberRegex o<span class="fu">.</span>number <span class="fu">*&gt;</span> pure o<span class="fu">.</span>number)</code></pre>
<p>また、<code>psci</code>でいろいろな有効な入力や無効な入力に対して、この検証器を実行してみてください。</p>
<pre class="text"><code>&gt; validatePhoneNumber $ phoneNumber HomePhone &quot;555-555-5555&quot;
  
Valid (PhoneNumber { type: HomePhone, number: &quot;555-555-5555&quot; })

&gt; validatePhoneNumber $ phoneNumber HomePhone &quot;555.555.5555&quot;
  
Invalid ([&quot;Field &#39;Number&#39; did not match the required format&quot;])</code></pre>
<blockquote>
<h2 id="演習-18" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単) 正規表現の検証器を使って、<code>Address</code>型の<code>state</code>フィールドが2文字のアルファベットであることを確かめてください。<strong>ヒント</strong>： <code>phoneNumberRegex</code>のソースコードを参照してみましょう。</p></li>
<li><p>(やや難しい) <code>matches</code>検証器を使って、文字列に全く空白が含まれないことを検証する検証関数を​​書いてください。この関数を使って、適切な場合に<code>nonEmpty</code>を置き換えてください。</p></li>
</ol>
</blockquote>
<h2 id="traversable関手"><span class="header-section-number">7.11</span> Traversable関手</h2>
<p>残った検証器は、これまで見てきた検証器を組み合わせて<code>Person</code>全体を検証する<code>validatePerson</code>です。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">arrayNonEmpty ::</span> forall a<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">V</span> <span class="dt">Errors</span> <span class="dt">Unit</span>
arrayNonEmpty field [] <span class="fu">=</span> 
  invalid [<span class="st">&quot;Field &#39;&quot;</span> <span class="fu">++</span> field <span class="fu">++</span> <span class="st">&quot;&#39; must contain at least one value&quot;</span>]
arrayNonEmpty _     _  <span class="fu">=</span> 
  pure unit

<span class="ot">validatePerson ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">V</span> <span class="dt">Errors</span> <span class="dt">Person</span>
validatePerson (<span class="dt">Person</span> o) <span class="fu">=</span>
  person <span class="fu">&lt;$&gt;</span> (nonEmpty <span class="st">&quot;First Name&quot;</span> o<span class="fu">.</span>firstName <span class="fu">*&gt;</span> 
              pure o<span class="fu">.</span>firstName)
         <span class="fu">&lt;*&gt;</span> (nonEmpty <span class="st">&quot;Last Name&quot;</span>  o<span class="fu">.</span>lastName  <span class="fu">*&gt;</span> 
              pure o<span class="fu">.</span>lastName)
         <span class="fu">&lt;*&gt;</span> validateAddress o<span class="fu">.</span>address
         <span class="fu">&lt;*&gt;</span> (arrayNonEmpty <span class="st">&quot;Phone Numbers&quot;</span> o<span class="fu">.</span>phones <span class="fu">*&gt;</span> 
              traverse validatePhoneNumber o<span class="fu">.</span>phones)</code></pre>
<p>ここに今まで見たことのない興味深い関数がひとつあります。最後の行で使われている<code>traverse</code>です。</p>
<p><code>traverse</code>は<code>Data.Traversable</code>モジュールの<code>Traversable</code>型クラスで定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Functor</span> t, <span class="dt">Foldable</span> t) <span class="fu">&lt;=</span> <span class="dt">Traversable</span> t <span class="kw">where</span>
<span class="ot">  traverse ::</span> forall a b f<span class="fu">.</span> (<span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f (t b)
<span class="ot">  sequence ::</span> forall a f<span class="fu">.</span> (<span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> t (f a) <span class="ot">-&gt;</span> f (t a)</code></pre>
<p><code>Traversable</code>は<strong>Traversable関手</strong>の型クラスを定義します。これらの関数の型は少し難しそうに見えるかもしれませんが、<code>validatePerson</code>は良いきっかけとなる例です。</p>
<p>すべてのTraversable関手は<code>Functor</code>と<code>Foldable</code>のどちらでもあります(<strong>Foldable 関手</strong>は構造をひとつの値へとまとめる、畳み込み操作を提供する型構築子であったことを思い出してください)。それ加えて、<code>Traversable</code>関手はその構造に依存した副作用のあつまりを連結する機能を提供します。</p>
<p>複雑そうに聞こえるかもしれませんが、配列の場合に特殊化して簡単に考えてみましょう。配列型構築子は<code>Traversable</code>である、つまり次のような関数が存在するということです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">traverse ::</span> forall a b f<span class="fu">.</span> (<span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> f [b]</code></pre>
<p>直感的には、Applicative関手<code>f</code>と、型<code>a</code>の値をとり型<code>b</code>の値を返す(<code>f</code>で追跡される副作用を持つ)関数が与えられたとき、型<code>[a]</code>の配列の要素それぞれにこの関数を適用し、型<code>[b]</code>の(<code>f</code>で追跡される副作用を持つ)結果を得ることができます。</p>
<p>まだよくわからないでしょうか。それでは、更に<code>f</code>を<code>V Errors</code>Applicative関手に特殊化して考えてみましょう。<code>traversable</code>が次のような型の関数だとしましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">traverse ::</span> forall a b<span class="fu">.</span> (a <span class="ot">-&gt;</span> <span class="dt">V</span> <span class="dt">Errors</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">V</span> <span class="dt">Errors</span> [b]</code></pre>
<p>この型シグネチャは、型<code>a</code>についての検証関数<code>f</code>があれば、<code>traverse f</code>は型<code>[a]</code>の配列についての検証関数であるということを言っています。これはまさに今必要になっている<code>Person</code>データ構造体の<code>phones</code>フィールドを検証する検証器そのものです！それぞれの要素が成功するかどうかを検証する検証関数を作るために、<code>validatePhoneNumber</code>を<code>traverse</code>へ渡しています。</p>
<p>一般に、<code>traverse</code>はデータ構造の要素をひとつづつ辿っていき、副作用のある計算を実行して結果を累積します。</p>
<p><code>Traversable</code>のもう一つの関数、<code>sequence</code>の型シグネチャには見覚えがあるかもしれません。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">sequence<span class="ot"> ::</span> forall a f<span class="fu">.</span> (<span class="dt">Applicative</span> m) <span class="ot">=&gt;</span> t (f a) <span class="ot">-&gt;</span> f (t a)</code></pre>
<p>実際、先ほど書いた<code>combineArray</code>関数は<code>Traversable</code>型の<code>sequence</code>関数が特殊化されたものに過ぎません。<code>t</code>を配列型構築子として、<code>combineArray</code>関数の型をもう一度考えてみましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">combineArray ::</span> forall f a<span class="fu">.</span> (<span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> [f a] <span class="ot">-&gt;</span> f [a]</code></pre>
<p><code>Traversable</code>関手は、作用のある計算の集合を集めてその作用を連鎖させるという、データ構造走査の考え方を把握できるようにするものです。実際、<code>sequence</code>と<code>traversable</code>は<code>Traversable</code>を定義するのにどちらも同じくらい重要です。これらはお互いが互いを利用して実装することができます。これについては興味ある読者への演習として残しておきます。</p>
<p>配列の<code>Traversable</code>インスタンスは<code>Data.Traversable</code>モジュールで与えられています。<code>traverse</code>の定義は次のようになっています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- traverse :: forall a b f. (Applicative f) =&gt; (a -&gt; f b) -&gt; [a] -&gt; f [b]</span>
traverse _ [] <span class="fu">=</span> pure []
traverse f (x <span class="fu">:</span> xs) <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> f x <span class="fu">&lt;*&gt;</span> traverse f xs</code></pre>
<p>入力が空の配列のときには、単に<code>pure</code>を使って空の配列を返すことができます。配列が空でないときは、関数<code>f</code>を使うと先頭の要素から型<code>f b</code>の計算を作成することができます。また、配列の残りに対して<code>traverse</code>を再帰的に呼び出すことができます。最後に、Applicative関手<code>f</code>までcons演算子<code>(:)</code>を持ち上げて、２つの結果を組み合わせます。</p>
<p>Traversable関手の例はただの配列以外にもあります。以前に見た<code>Maybe</code>型構築子も<code>Traversable</code>のインスタンスを持っています。<code>psci</code> で試してみましょう。</p>
<pre class="text"><code>&gt; :i Data.Maybe

&gt; traverse (nonEmpty &quot;Example&quot;) Nothing
  
Valid (Nothing)

&gt; traverse (nonEmpty &quot;Example&quot;) (Just &quot;&quot;)
  
Invalid ([&quot;Field &#39;Example&#39; cannot be empty&quot;])

&gt; traverse (nonEmpty &quot;Example&quot;) (Just &quot;Testing&quot;)
  
Valid (Just (Unit {}))</code></pre>
<p>これらの例では、<code>Nothing</code>の値の走査は検証なしで<code>Nothing</code>の値を返し、<code>Just x</code>を走査すると<code>x</code>を検証するのにこの検証関数が使われるということを示しています。つまり、<code>traverse</code>は型<code>a</code>についての検証関数をとり、<code>Maybe a</code>についての検証関数を返すのです。</p>
<p>他にも、何らかの型<code>a</code>についての<code>Tuple a</code>や<code>Either a</code>や、連結リストの型構築子<code>List</code>といったTraversable関手があります。一般的に、「コンテナ」のようなデータ型のコンストラクタは大抵は<code>Traversable</code>インスタンスを持っています。例として、演習では二分木の型の<code>Traversable</code>インスタンスを書くようになっています。</p>
<blockquote>
<h2 id="演習-19" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(やや難しい) 左から右へと副作用を連鎖させる、次のような二分木データ構造についての<code>Traversable</code>インスタンスを書いてください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Branch</span> (<span class="dt">Tree</span> a) a (<span class="dt">Tree</span> a)</code></pre>
<p>これは木の走査の順序に対応しています。行きがけ順の走査についてはどうでしょうか。帰りがけ順では？</p></li>
<li><p>(やや難しい) <code>Data.Maybe</code>を使って<code>Person</code>の<code>address</code>フィールドを省略可能になるようにコードを変更してください。<strong>ヒント</strong>： <code>traverse</code>を使って型<code>Maybe a</code>のフィールドを検証してみましょう。</p></li>
<li><p>(難しい) <code>traverse</code>を使って<code>sequence</code>を書いてみましょう。また、<code>sequence</code>を使って<code>traverse</code>を書けるでしょうか？</p></li>
</ol>
</blockquote>
<h2 id="applicative関手による並列処理"><span class="header-section-number">7.12</span> Applicative関手による並列処理</h2>
<p>これまでの議論では、Applicative関手がどのように「副作用を結合」させるかを説明するときに、「結合」(combine)という単語を選びました。しかしながら、これらのすべての例において、Applicative関手は作用を「連鎖」(sequence)させる、というように言っても同じく妥当です。<code>Traverse</code>関手はデータ構造に従って作用を順番に結合させる<code>sequence</code>関数を提供する、という直感的理解とこれは一致するでしょう。</p>
<p>しかし一般には、Applicative関手はこれよりももっと一般的です。Applicative関手の規則は、その計算を実行する副作用にどんな順序付けも強制しません。実際、並列に副作用を実行するためのApplicative関手というものは妥当になりえます。</p>
<p>たとえば、<code>V</code>検証関手はエラーの<strong>配列</strong>を返しますが、その代わりに<code>Set</code>半群を選んだとしてもやはり正常に動き、このときどんな順序でそれぞれの検証器を実行しても問題はありません。データ構造に対して並列にこれを実行することさえできるのです！</p>
<p><strong>非同期計算</strong>を表現する型構築子<code>Async</code>は、並列に結果を計算する<code>Applicative</code>インスタンスを持つことができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class="fu">&lt;$&gt;</span> <span class="dt">Async</span> computation1 <span class="fu">&lt;*&gt;</span> <span class="dt">Async</span> computation2</code></pre>
<p>この計算は、<code>computation1</code>と<code>computation2</code>を非同期に使って値を計算を始めるでしょう。そして両方の結果の計算が終わった時に、関数<code>f</code>を使ってひとつの結果へと結合するでしょう。</p>
<p>この考え方の詳細は、本書の後半で<strong>コールバック地獄</strong>の問題に対してApplicative関手を応用するときに見ていきます。</p>
<p>Applicative関手は並列に結合されうる副作用を捕捉する自然な方法です。</p>
<h2 id="まとめ-5"><span class="header-section-number">7.13</span> まとめ</h2>
<p>この章では新しい考え方をたくさん扱いました。</p>
<ul>
<li>関数適用の概念を副作用の考え方を表現する型構築子へと一般化する、<strong>Applicative関手</strong>の概念を導入しました。</li>
<li>データ構造の検証という課題にApplicative関手がどのような解決策を与えるか、単一のエラーの報告からデータ構造を横断するすべてのエラーの報告へ変換できるApplicative関手を見てきました。</li>
<li>要素が副作用を持つ値の結合に使われることのできるコンテナである<strong>Traversable関手</strong>の考え方を表現する、<code>Traversable</code>型クラス導入しました。</li>
</ul>
<p>Applicative関手は多くの問題に対して優れた解決策を与える興味深い抽象化です。本書を通じて何度も見ることになるでしょう。今回は、<strong>どうやって</strong>検証を行うかではなく、<strong>何を</strong>検証器が検証すべきなのかを定義することを可能にする、宣言的なスタイルで書く手段をApplicative関手は提供しました。一般に、Applicative関手は<strong>領域特化言語</strong>の設計のための便利な道具になります。</p>
<p>次の章では、これに関連する<strong>モナド</strong>という型クラスについて見ていきましょう。</p>
<h1 id="effモナド"><span class="header-section-number">8</span> Effモナド</h1>
<h2 id="この章の目標-5"><span class="header-section-number">8.1</span> この章の目標</h2>
<p>第7章では、オプショナルな型やエラーメッセージ、データの検証など、<strong>副作用</strong>を扱いを抽象化するApplicative関手を導入しました。この章では、より表現力の高い方法で副作用を扱うための別の抽象化、<strong>モナド</strong>を導入します。</p>
<p>この章の目的は、なぜモナドが便利な抽象化なのか、<strong>do記法</strong>とどう関係するのかについて説明することです。ブラウザでユーザインターフェイスを構築する副作用を扱うためのある種のモナドを使って、前の章の住所録の例を作ることにしましょう。これから扱うEffモナドは、PureScriptにおけるとても重要なモナドです。Effモナドはいわゆる<strong>ネイティブな</strong>作用をカプセル化するのに使われます。</p>
<h2 id="プロジェクトの準備-5"><span class="header-section-number">8.2</span> プロジェクトの準備</h2>
<p>このプロジェクトのソースコードは前の章のソースコードの上に構築しますが、そのソースファイルを含めるようにGruntビルドスクリプトを使用しています。</p>
<p>コー​​ドは3つのモジュールに分かれています。</p>
<ul>
<li><code>Main</code> - アプリケーションへのエントリポイントを提供します。</li>
<li><code>Data.AddressBook.UI</code> - ブラウザのユーザインターフェースをレンダリングするための関数を提供します。</li>
<li><code>Control.Monad.Eff.DOM</code> - DOMを操作する関数の簡単なライブラリを提供します。</li>
</ul>
<p>このプロジェクトを実行するには、Gruntでビルドし、<code>html/index.html</code>ファイルをウェブブラウザで開いてください。</p>
<h2 id="モナドとdo記法"><span class="header-section-number">8.3</span> モナドとdo記法</h2>
<p>do記法は<strong>配列内包表記</strong>を扱うときに最初に導入されました。配列内包表記は <code>Data.Array</code>モジュールの<code>concatMap</code>関数の構文糖として提供されています。</p>
<p>次の例を考えてみましょう。２つのサイコロを振って出た目を数え、出た目の合計が<code>n</code>のときそれを得点とすることを考えます。次のような非決定的なアルゴリズムを使うとこれを実現することができます。</p>
<ul>
<li>最初の投擲で値<code>x</code>を<strong>選択</strong>します</li>
<li>２回め投擲で値<code>y</code>を<strong>選択</strong>します</li>
<li>もし<code>x</code>と <code>y</code>の和が<code>n</code>なら組<code>{x, y}</code>を返し、そうでなければ失敗します</li>
</ul>
<p>配列内包表記を使うと、この非決定的アルゴリズムを自然に書くことができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">countThrows ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> [[<span class="dt">Number</span>]]
countThrows n <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> range <span class="dv">1</span> <span class="dv">6</span>
  y <span class="ot">&lt;-</span> range <span class="dv">1</span> <span class="dv">6</span>
  <span class="kw">if</span> x <span class="fu">+</span> y <span class="fu">==</span> n <span class="kw">then</span> return [x, y] <span class="kw">else</span> empty</code></pre>
<p><code>psci</code>で動作を見てみましょう。</p>
<pre class="text"><code>&gt; countThrows 10
[[4,6],[5,5],[6,4]]

&gt; countThrows 12  
[[6,6]]</code></pre>
<p>前の章では、<strong>オプショナルな値</strong>に対応したより大きなプログラミング言語へとPureScriptの関数を埋め込む、<code>Maybe</code>Applicative関手についての直感的理解を養いました。同様に<strong>配列モナド</strong>についても、<strong>非決定選択</strong>に対応したより大きなプログラミング言語へPureScriptの関数を埋め込む、というような直感的理解を得ることができます。</p>
<p>一般に、ある型構築子<code>m</code>のモナドは、型<code>m a</code>の値を持つdo記法を使う方法を提供します。上の配列内包表記では、すべての行に何らかの型<code>a</code>についての型<code>[a]</code>の計算が含まれていることに注目してください。一般に、do記法ブロックのすべての行は、何らかの型<code>a</code>とモナド<code>m</code>について、型<code>m a</code>の計算を含んでいます。モナド<code>m</code>はすべての行で同じでなければなりません(つまり、副作用の種類は固定されます)が、型<code>a</code>は異なることもあります(言い換えると、ここの計算は異なる型の結果を持つことができます)。</p>
<p>型構築子<code>Maybe</code>が適用された、do記法の別の例を見てみましょう。XMLノードを表す型<code>XML</code>と演算子があるとします。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&lt;/&gt;) ::</span> <span class="dt">XML</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">XML</span></code></pre>
<p>この演算子はノードの子の要素を探し、もしそのような要素が存在しなければ<code>Nothing</code>を返します。</p>
<p>この場合、do記法を使うと深い入れ子になった要素を検索することができます。XML文書として符号化された利用者情報から、利用者の住んでいる市町村を読み取りたいとします。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">userCity ::</span> <span class="dt">XML</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">XML</span>
userCity root <span class="fu">=</span> <span class="kw">do</span>
  prof <span class="ot">&lt;-</span> root <span class="fu">&lt;/&gt;</span> <span class="st">&quot;profile&quot;</span>
  addr <span class="ot">&lt;-</span> prof <span class="fu">&lt;/&gt;</span> <span class="st">&quot;address&quot;</span>
  city <span class="ot">&lt;-</span> addr <span class="fu">&lt;/&gt;</span> <span class="st">&quot;city&quot;</span>
  return city</code></pre>
<p><code>userCity</code>関数は子の要素である<code>profile</code>を探し、<code>profile</code>要素の中にある<code>address</code>要素、最後に<code>address</code>要素から<code>city</code>要素を探します。これらの要素のいずれかが欠落している場合は、返り値は<code>Nothing</code>になります。そうでなければ、返り値は <code>city</code>ノードから<code>Just</code>を使って構築されています。</p>
<p>最後の行の <code>return</code>関数は予約語ではないことを思い出してください。<code>return</code>は実際にすべての <code>Applicative</code>関手について定義されている<code>pure</code>関数の別名です。JavaScriptのreturn文を連想するかもしれませんが、関数の途中での復帰とはまったく関係がありません。最後の行を<code>Just city</code>へ変更しても同じように正しく動きます。</p>
<h2 id="モナド型クラス"><span class="header-section-number">8.4</span> モナド型クラス</h2>
<p><code>Monad</code>型クラスは次のように定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Apply</span> m) <span class="fu">&lt;=</span> <span class="dt">Bind</span> m <span class="kw">where</span>
<span class="ot">  (&gt;&gt;=) ::</span> forall a b<span class="fu">.</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b

<span class="kw">class</span> (<span class="dt">Applicative</span> m, <span class="dt">Bind</span> m) <span class="fu">&lt;=</span> <span class="dt">Monad</span> m</code></pre>
<p>ここで鍵となる関数は<code>Bind</code>型クラスで定義されている演算子<code>=&gt;&gt;</code>で、これは「束縛」(bind)と呼ばれています。<code>Monad</code>型クラスは、すでに見てきた<code>Applicative</code>型クラスの操作で<code>Bind</code>を拡張します。</p>
<p><code>Bind</code>型クラスの例をいくつか見てみるのがわかりやすいでしょう。配列についての<code>Bind</code>の妥当な定義は次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> bindArray ::</span> <span class="dt">Bind</span> [] <span class="kw">where</span>
  (<span class="fu">&gt;&gt;=</span>) xs f <span class="fu">=</span> f <span class="ot">`concatMap`</span> xs</code></pre>
<p>これは以前にほのめかした配列内包表記と<code>concatMap</code>関数の関係を説明しています。</p>
<p><code>Maybe</code>型構築子についての<code>Bind</code>の実装は次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> bindMaybe ::</span> <span class="dt">Bind</span> <span class="dt">Maybe</span> <span class="kw">where</span>
  (<span class="fu">&gt;&gt;=</span>) <span class="dt">Nothing</span>  _ <span class="fu">=</span> <span class="dt">Nothing</span>
  (<span class="fu">&gt;&gt;=</span>) (<span class="dt">Just</span> a) f <span class="fu">=</span> f a</code></pre>
<p>この定義はdo記法ブロックを通じて伝播された欠落した値についての直感的理解を補強するものです。</p>
<p><code>Bind</code>型クラスとdo記法がどのように関係しているかを見て行きましょう。最初に何らかの計算結果から値を束縛するような、簡単などdo記法ブロックについて考えてみましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span> value <span class="ot">&lt;-</span> someComputation
   whatToDoNext</code></pre>
<p>PureScriptコンパイラはこのようなパターンを見つけるたびにコードを次にように置き換えます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">someComputation <span class="fu">&gt;&gt;=</span> \value <span class="ot">-&gt;</span> whatToDoNext</code></pre>
<p>この計算<code>whatToDoNext</code>は<code>value</code>に依存することができます。</p>
<p>連続した複数の束縛がある場合でも、この規則が先頭のほうから複数回適用されます。例えば、先ほど見た<code>userCity</code>の例では次のように構文糖が脱糖されます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">userCity ::</span> <span class="dt">XML</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">XML</span>
userCity root <span class="fu">=</span> 
  root <span class="fu">&lt;/&gt;</span> <span class="st">&quot;profile&quot;</span> <span class="fu">&gt;&gt;=</span> \prof <span class="ot">-&gt;</span>
    prof <span class="fu">&lt;/&gt;</span> <span class="st">&quot;address&quot;</span> <span class="fu">&gt;&gt;=</span> \addr <span class="ot">-&gt;</span>
      addr <span class="fu">&lt;/&gt;</span> <span class="st">&quot;city&quot;</span> <span class="fu">&gt;&gt;=</span> \city <span class="ot">-&gt;</span>
        return city</code></pre>
<p>do記法を使って表現されたコードは、<code>&gt;&gt;=</code>演算子を使って書かれた同じ意味のコードよりしばしば読みやすくなることも特筆すべき点です。一方で、明示的に<code>&gt;&gt;=</code>を使って束縛が書くと、<strong>point-free</strong>形式でコードを書く機会を増やすことになります。ただし、通常は読みやすさを優先すべきでしょう。</p>
<h2 id="モナド則"><span class="header-section-number">8.5</span> モナド則</h2>
<p><code>Monad</code>型クラスは<strong>モナド則</strong>(monad laws)と呼ばれる3つの規則を持っています。これらは<code>Monad</code>型クラスの理にかなった実装から何を期待できるかを教えてくれます。</p>
<p>do記法を使用してこれらの規則を説明していくのが最も簡単でしょう。</p>
<h3 id="identity律"><span class="header-section-number">8.5.1</span> Identity律</h3>
<p><strong>右単位元則</strong>(right-identity law)が３つの規則の中で最も簡単です。この規則はdo記法ブロックの最後の式であれば、<code>return</code>の呼び出しを排除することが できると言っています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span> 
  x <span class="ot">&lt;-</span> expr
  return x</code></pre>
<p>右単位元則は、この式は単なる<code>expr</code>と同じだと言っています。</p>
<p><strong>左単位元則</strong>(left-identity law)は、もしそれがdo記法ブロックの最初の式であれば、<code>return</code>の呼び出しを除去することができると述べています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span> 
  x <span class="ot">&lt;-</span> return y
  next</code></pre>
<p>このコードの名前<code>x</code>を式<code>y</code>で置き換えたものと<code>next</code>は同じです。</p>
<p>最後の規則は<strong>結合則</strong>(associativity law)です。これは入れ子になったdo記法ブロックをどう扱うのかについて教えてくれます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">c1 <span class="fu">=</span> <span class="kw">do</span> 
  y <span class="ot">&lt;-</span> <span class="kw">do</span> 
    x <span class="ot">&lt;-</span> m1
    m2
  m3</code></pre>
<p>上記のコード片は、次のコードと同じです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">c2 <span class="fu">=</span> <span class="kw">do</span> 
  x <span class="ot">&lt;-</span> m1
  y <span class="ot">&lt;-</span> m2
  m3</code></pre>
<p>これら計算にはそれぞれ、3つのモナドの式 <code>m1</code>、<code>m2</code>、 <code>m3</code>が含まれています。どちらの場合でも<code>m1</code> の結果は名前 <code>x</code>に束縛され、<code>m2</code>の結果は名前 <code>y</code>に束縛されます。</p>
<p><code>c1</code>では２つの式<code>m1</code>と<code>m2</code>がそれぞれのdo記法ブロック内にグループ化されています。</p>
<p><code>c2</code>では<code>m1</code>、<code>m2</code>、<code>m3</code>の３つすべての式が同じdo記法ブロックに現れています。</p>
<p>結合規則は　入れ子になったdo記法ブロックをこのように単純化しても安全であるということを言っています。</p>
<p><strong>注意</strong>: do記法がどのように<code>&gt;&gt;=</code>の呼び出しへと脱糖されるかの定義により、<code>c1</code>と<code>c2</code>はいずれも次のコードと同じです。`</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">c3 <span class="fu">=</span> <span class="kw">do</span> 
  x <span class="ot">&lt;-</span> m1
  <span class="kw">do</span>
    y <span class="ot">&lt;-</span> m2
    m3</code></pre>
<h2 id="モナドと畳み込み"><span class="header-section-number">8.6</span> モナドと畳み込み</h2>
<p>抽象的にモナドを扱う例として、この節では<code>Monad</code>型クラスの何らかの型構築子と一緒に機能するある関数を示していきます。これはモナドによるコードが副作用を伴う「より大きな言語」でのプログラミングと対応しているという直感的理解を補強しますし、モナドによるプログラミングがもたらす一般性も示しています。</p>
<p>これから<code>foldM</code>と呼ばれる関数を書いてみます。これは以前扱った<code>foldl</code>関数をモナドの文脈へと一般化します。型シグネチャは次のようになっています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foldM ::</span> forall m a b<span class="fu">.</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> m a </code></pre>
<p>モナド<code>m</code>が現れている点を除いて、<code>foldl</code>の型と同じであることに注意しましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foldl<span class="ot"> ::</span> forall a b<span class="fu">.</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> a</code></pre>
<p>直感的には、<code>foldM</code>はさまざまな副作用の組み合わせに対応した文脈での配列の畳み込みを行うと捉えることができます。</p>
<p>例として<code>m</code>が<code>Maybe</code>であるとすると、この畳み込みはそれぞれの段階で<code>Nothing</code>を返すことで失敗することができます。それぞれの段階ではオプショナルな結果を返しますから、それゆえ畳み込みの結果もオプショナルになります。</p>
<p>もし<code>m</code>として配列の型構築子<code>[]</code>を選ぶとすると、畳み込みのそれぞれの段階で複数の結果を返すことができ、畳み込みは結果それぞれに対して次の手順を継続します。最後に、結果の集まりは、可能な経路すべての畳み込みから構成されることになります。これはグラフの走査と対応しています！</p>
<p><code>foldM</code>を書くには、単に入力の配列について場合分けをするだけです。</p>
<p>配列が空なら、型<code>a</code>の結果を生成するための選択肢はひとつしかありません。第２引数を返します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foldM _ a [] <span class="fu">=</span> return a</code></pre>
<p><code>a</code>をモナド<code>m</code>まで持ち上げるために<code>return</code>を使わなくてはいけないことも忘れないようにしてください。</p>
<p>配列が空でない場合はどうでしょうか？その場合、型<code>a</code>の値、型<code>b</code>の値、型<code>a -&gt; b -&gt; m a</code>の関数があります。もしこの関数を適用すると、型<code>m a</code>のモナドの結果を手に入れることになります。この計算の結果を逆向きの矢印<code>&lt;-</code>で束縛することができます。</p>
<p>あとは配列の残りに対して再帰するだけです。実装は簡単です。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foldM f a (b <span class="fu">:</span> bs) <span class="fu">=</span> <span class="kw">do</span>
  a&#39; <span class="ot">&lt;-</span> f a b
  foldM f a&#39; bs</code></pre>
<p>do記法を除けば、この実装は配列に対する<code>foldl</code>の実装とほとんど同じであることにも注意してください。</p>
<p><code>psci</code>でこれを定義し、試してみましょう。除算可能かどうかを調べて、失敗を示すために<code>Maybe</code>型構築子を使う、整数の「安全な除算」関数を定義するとしましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">safeDivide ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Number</span>
safeDivide a b <span class="fu">|</span> a <span class="fu">%</span> b <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Just</span> (a <span class="fu">/</span> b)
safeDivide _ _ <span class="fu">=</span> <span class="dt">Nothing</span></code></pre>
<p>これで、<code>foldM</code>で安全な除算の繰り返しを表現することができます。</p>
<pre class="text"><code>&gt; foldM safeDivide 100 [5, 2, 2]
Just (5)

&gt; foldM safeDivide 100 [2, 3, 4]
Nothing</code></pre>
<p>もしいずれかの時点で整数にならない除算が行われようとしたら、<code>foldM safeDivide</code>関数は<code>Nothing</code>を返します。そうでなければ、<code>Just</code>構築子に包まれた除算の繰り返した累積の結果を返します。</p>
<h2 id="モナドとapplicative"><span class="header-section-number">8.7</span> モナドとApplicative</h2>
<p>クラス間に上位クラス関係があるため、<code>Monad</code>型クラスのすべてのインスタンスは<code>Applicative</code>型クラスのインスタンスでもあります。</p>
<p>しかしながら、どんな<code>Monad</code>のインスタンスについても<code>Applicative</code>型クラスの実装が、それ以上の条件なしで存在し、次のような<code>ap</code>が与えられます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ap ::</span> forall m<span class="fu">.</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> m (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b
ap mf ma <span class="fu">=</span> <span class="kw">do</span>
  f <span class="ot">&lt;-</span> mf
  a <span class="ot">&lt;-</span> ma
  return (f a)</code></pre>
<p>もし<code>m</code>が<code>Monad</code>型クラスの規則に従っているなら、<code>pure</code>が<code>return</code>で与えられ、<code>&lt;*&gt;</code>が<code>ap</code>で与えられるような、妥当な<code>Applicative</code>インスタンスが存在します。　　　　</p>
<p>興味のある読者は、これまで登場した<code>[]</code>、<code>Maybe</code>、<code>Either e</code>、<code>V e</code>といったモナドについて、この<code>ap</code>が<code>&lt;*&gt;</code>と一致することを確かめてみてください。</p>
<p>もしすべてのモナドがApplicative関手でもあるなら、Applicative関手についての直感的理解をすべてのモナドについても適用することができるはずです。特に、更なる副作用の組み合わせで増強された「より大きな言語」でのプログラミングとモナドがいろいろな意味で一致することを当然に期待することができます。<code>&lt;$&gt;</code>と<code>&lt;*&gt;</code>を使って、引数が任意個の関数をこの新しい言語へと持ち上げることができるはずです。</p>
<p>しかし、モナドはApplicative関手で可能な以上のことを行うことができ、重要な違いはdo記法の構文で強調されています。利用者情報を符号化したXML文書から利用者の都市を検索する、<code>userCity</code>の例についてもう一度考えてみましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">userCity ::</span> <span class="dt">XML</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">XML</span>
userCity root <span class="fu">=</span> <span class="kw">do</span>
  prof <span class="ot">&lt;-</span> root <span class="fu">&lt;/&gt;</span> <span class="st">&quot;profile&quot;</span>
  addr <span class="ot">&lt;-</span> prof <span class="fu">&lt;/&gt;</span> <span class="st">&quot;address&quot;</span>
  city <span class="ot">&lt;-</span> addr <span class="fu">&lt;/&gt;</span> <span class="st">&quot;city&quot;</span>
  return city</code></pre>
<p>２番目の計算が最初の結果<code>prof</code>に依存し、３番目の計算が２番目の計算の結果<code>addr</code>に依存するというようなことをdo記法は可能にします。<code>Applicative</code>型クラスのインターフェイスだけを使うのでは、このような以前の値への依存は不可能です。</p>
<p><code>pure</code>と<code>&lt;*&gt;</code>だけを使って<code>userCity</code>を書こうとしてみれば、これが不可能であることがわかるでしょう。Applicativeは関数の互いに独立した引数を持ち上げることだけを可能にしますが、モナドはもっと興味深いデータ依存関係に関わる計算を書くことを可能にします。</p>
<p>前の章では<code>Applicative</code>型クラスは並列処理を表現できることを見ました。持ち上げられた関数の引数は互いに独立していますから、これはまさにその通りです。<code>Monad</code>型クラスは計算が前の計算の結果に依存できるようにしますから、同じようにはなりません。モナドはその副作用を順番に組み合わせしなければいけません。</p>
<blockquote>
<h2 id="演習-20" class="unnumbered">演習</h2>
<ol type="1">
<li>（簡単）　<code>purescript-arrays</code>パッケージの<code>Data.Array</code>モジュールから<code>head</code>関数と<code>tail</code>関数の型を探してください。<code>Maybe</code>モナドとdo記法を使い、<code>head</code>と<code>tail</code>を組み合わせて、３要素以上の配列の3番目の要素を返すような関数を作ってください。その関数は適当な<code>Maybe</code>型を返さなければいけません。</li>
<li><p>（やや難しい） 与えられた幾つかの硬貨を組み合わせてできる可能性のあるすべての合計を決定する関数<code>sum</code>を、<code>foldM</code>を使って書いてみましょう。入力の硬貨は、硬貨の価値の配列として与えられます。この関数は次のような結果にならなくてはいけません。</p>
<pre class="text"><code>&gt; sums []
[0]

&gt; sums [1, 2, 10]
[0,1,2,3,10,11,12,13]</code></pre>
<p><strong>ヒント</strong>：<code>foldM</code>を使うと１行でこの関数を書くことが可能です。重複する要素を取り除いたり、結果を昇順に並び替えたりするのに、<code>nub</code>関数や<code>sort</code>関数を使いたくなるかもしれません。</p></li>
<li><p>（やや難しい） <code>Maybe</code>型構築子について、<code>ap</code>関数と<code>&lt;*&gt;</code>演算子が一致することを確認してください。</p></li>
<li><p>（やや難しい） <code>purescript-maybe</code>パッケージで定義されている<code>Maybe</code>型についての<code>Monad</code>インスタンスが、モナド則を満たしていることを検証してください。</p></li>
<li><p>（やや難しい） 配列上の<code>filter</code>の関数を一般化した関数<code>filterM</code>を書いてください。この関数は次の型シグネチャを持つ必要があります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">filterM ::</span> forall m a<span class="fu">.</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m <span class="dt">Boolean</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</code></pre>
<p><code>psci</code>で<code>Maybe</code>と<code>[]</code>モナドを使ってその関数を試してみてください。</p></li>
<li><p>（難しい） すべてのモナドは、次で与えられるような既定の<code>Functor</code>インスタンスがあります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="fu">&lt;$&gt;</span>) f a <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> a
  return (f a)</code></pre>
<p>モナド則を使って、すべてのモナドが次を満たすことを証明してください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">lift2 f (return a) (return b) <span class="fu">=</span> return (f a b)</code></pre>
<p>ここで、 <code>Applicative</code>インスタンスは上で定義された<code>ap</code>関数を使用しています。<code>lift2</code>が次のように定義されていたことを思い出してください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lift2 ::</span> forall f a b c<span class="fu">.</span> (<span class="dt">Applicative</span> f)<span class="fu">.</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c
lift2 f a b <span class="fu">=</span> f <span class="fu">&lt;$&gt;</span> a <span class="fu">&lt;*&gt;</span> b</code></pre></li>
</ol>
</blockquote>
<h2 id="ネイティブな作用"><span class="header-section-number">8.8</span> ネイティブな作用</h2>
<p>ここではPureScriptの中核となる重要なモナド、<code>Eff</code>モナドについて見ていきます。</p>
<p><code>Eff</code>モナドは<code>Control.Monad.Eff</code>モジュール、およびPreludeで定義されています。これはいわゆる<strong>ネイティブな作用</strong>を扱うために使います。</p>
<p>ネイティブな副作用とは何でしょうか。ネイティブな副作用とは、従来のJavaScriptの式が持つ副作用と、PureScript特有の式が持つ副作用を区別するものです。ネイティブな作用には次のようなものがあります。</p>
<ul>
<li>コンソール入出力</li>
<li>乱数生成</li>
<li>例外</li>
<li>変更可能な状態の読み書き</li>
</ul>
<p>また、ブラウザでは次のようなものがあります。</p>
<ul>
<li>DOM操作</li>
<li>XMLHttpRequest / AJAX呼び出し</li>
<li>WebSocketによる相互作用</li>
<li>Local Storageの読み書き</li>
</ul>
<p>すでに「ネイティブでない」副作用の例については数多く見てきています。</p>
<ul>
<li><code>Maybe</code>データ型で表現される省略可能な値</li>
<li><code>Either</code>データ型で表現されるエラー</li>
<li>配列やリストで表現される多価関数</li>
</ul>
<p>これらの区別はわかりにくいので注意してください。エラーメッセージは例外の形でJavaScriptの式の副作用となることがあります。その意味では例外はネイティブな副作用を表していて、<code>Eff</code>を使用して表現することができます。しかし、<code>Either</code>を使用して実装されたエラーメッセージはJavaScriptランタイムの副作用ではなく、<code>Eff</code>を使うスタイルでエラーメッセージを実装するのは適切ではありません。そのため、ネイティブなのは作用自体というより、実行時にどのように実装されているかです。</p>
<h2 id="副作用と純粋性"><span class="header-section-number">8.9</span> 副作用と純粋性</h2>
<p>PureScriptのような言語が純粋であるとすると、疑問が浮かんできます。副作用がないなら、どうやって役に立つ実際のコードを書くことができるというのでしょうか。</p>
<p>その答えはPureScriptの目的は副作用を排除することではないということです。これは、純粋な計算と副作用のある計算とを型システムにおいて区別することができるような方法で、副作用を表現することを目的としているのです。この意味で、言語はあくまで純粋だということです。</p>
<p>副作用のある値は、純粋な値とは異なる型を持っています。このように、例えば副作用のある引数を関数に渡すことはできず、予期せず副作用持つようなことが起こらなくなります。</p>
<p><code>Eff</code>モナドで管理された副作用を実行する唯一の方法は、型<code>Eff eff a</code>の計算をJavaScriptから実行することです。</p>
<p>PureScriptコンパイラは、<code>--main</code>コンパイラオプションを与えることで、アプリケーションの起動時に <code>main</code>計算を呼び出すためのJavaScriptコードを簡単に追加で生成できるようにしています。<code>main</code>は<code>Eff</code>モナドでの計算であることが要求されます。</p>
<p>このように、<code>main</code>によって使われる副作用が期待されることを、開発者は正確に知ることができます。加えて、<code>main</code>がどのような種類の副作用を持つかを制限するのに<code>Eff</code>モナドを使うことができるので、例えば、アプリケーションはコンソールと相互作用するが、それ以外は何もしない、ということを確実に言うことができます。</p>
<h2 id="effモナド-1"><span class="header-section-number">8.10</span> Effモナド</h2>
<p><code>Eff</code>モナドの目的は、副作用のある計算に型付けされたAPIを提供すると同時に、効率的なJavascriptを生成することにあります。これは<strong>拡張可能作用</strong>(extensible effects)のモナドとも呼ばれており、これについては後述します。</p>
<p>例を示しましょう。次のコードでは乱数を生成するための関数が定義されている<code>purescript-random</code>モジュールを使用しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Monad.Eff</span>
<span class="kw">import </span><span class="dt">Control.Monad.Eff.Random</span>

<span class="kw">import </span><span class="dt">Debug.Trace</span>

main <span class="fu">=</span> <span class="kw">do</span>
  n <span class="ot">&lt;-</span> random
  print n</code></pre>
<p>このファイルが<code>Main.purs</code> という名前で保存されているなら、次のコマンドでコンパイルすることができます。</p>
<pre class="text"><code>psc --main Main Main.purs</code></pre>
<p>コンパイルされたJavaScriptを実行すると、コンソールに出力<code>0</code>と <code>1</code>の間で無作為に選ばれた数が表示されるでしょう。</p>
<p>このプログラムは、乱数生成とコンソール入出力というJavaScriptランタイムが提供する２種類のネイティブな作用を、do記法で組み合わせて使っています。</p>
<h2 id="拡張可能作用"><span class="header-section-number">8.11</span> 拡張可能作用</h2>
<p><code>psci</code>でモジュールを読み込み、<code>main</code>の型を調べてみましょう。</p>
<pre class="text"><code>&gt; :t Main.main

forall eff. Eff (trace :: Trace, random :: Random | eff) Unit</code></pre>
<p>この型はかなり複雑そうに見えますが、PureScriptのレコードの比喩で簡単に説明することができます。</p>
<p>レコード型を使った簡単な関数を考えてみましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">fullName person <span class="fu">=</span> person<span class="fu">.</span>firstName <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> person<span class="fu">.</span>lastName</code></pre>
<p>この関数は <code>firstName</code>と<code>lastName</code>というプロパティを含むレコードから完全な名前の文字列を作成します。もし<code>psci</code>でこの関数の型を同様に調べたとすると、次のように表示されるでしょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">forall r<span class="fu">.</span> {<span class="ot"> firstName ::</span> <span class="dt">String</span>,<span class="ot"> lastName ::</span> <span class="dt">String</span> <span class="fu">|</span> r } <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre>
<p>この型は「<strong>少なくとも</strong><code>fullName</code>は<code>firstName</code>と<code>lastName</code>という2つのフィールドを持つようなレコードをとり、<code>String</code>を返す.」というように読みます。</p>
<p>渡したレコードが <code>firstName</code>と<code>lastName</code>いうプロパティさえ持っていれば、その他に余計なフィールドを持っていたとしても<code>fullName</code>は気にしません。</p>
<pre class="text"><code>&gt; firstName { firstName: &quot;Phil&quot;, lastName: &quot;Freeman&quot;, location: &quot;Los Angeles&quot; }

Phil Freeman</code></pre>
<p>同様に、上の<code>main</code>の型は「<code>main</code>は<strong>副作用のある計算</strong>で、乱数生成とコンソール入出力、<strong>およびそれ以外の任意の種類の副作用</strong>を備えた任意の環境で実行することができ、型<code>Unit</code>の値を返す」というように解釈できます。</p>
<p>これは 「拡張可能作用」という名前の由来になっています。必要な副作用さえ備えていれば、その副作用の集まりをいつでも拡張できるということです。</p>
<h2 id="作用の混在"><span class="header-section-number">8.12</span> 作用の混在</h2>
<p>拡張可能作用は<code>Eff</code>モナドで異なる型の副作用を<strong>混在</strong>(interleave)させることを可能にします。</p>
<p>先ほど使った<code>random</code>関数は次のような型を持っています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">forall eff1<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">random ::</span> <span class="dt">Random</span> <span class="fu">|</span> eff1) <span class="dt">Number</span></code></pre>
<p>この作用の集まり<code>(random :: Random | eff1)</code>は<code>main</code>で見たものと同じ<strong>ではありません</strong>。</p>
<p>しかし、作用が一致するように<code>random</code>の型を特殊化できます。<code>eff1</code> に <code>(trace :: Trace | eff)</code>を選べば、これらの２つの作用の集合は同じになります。</p>
<p>同様に <code>trace</code>は<code>main</code>の作用に合わせて特殊化できる型を持っています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">forall eff2<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">trace ::</span> <span class="dt">Trace</span> <span class="fu">|</span> eff2) <span class="dt">Unit</span></code></pre>
<p>この場合は、<code>eff2</code>に<code>(random :: Random | eff)</code>を選ばなくてはなりません。</p>
<p>それが含む副作用を示す<code>random</code>と<code>print</code>の型がポイントで、より大きな副作用の集まりを持ったより大きな計算を構築するために、他の副作用を<strong>混ぜ合わせる</strong>ことができるのです。</p>
<p><code>main</code>の型注釈を与えなくてもよいことに注意してください。<code>psc</code>は<code>random</code>と<code>trace</code>の多相的な型が与えられた<code>main</code>の最も一般的な型を見つけることができます。</p>
<h2 id="effの種"><span class="header-section-number">8.13</span> Effの種</h2>
<p><code>main</code>の型は今まで見てきた他の型とは異なります。それを説明するためには、まず<code>Eff</code> の<strong>種</strong>について考える必要があります。値がその型によって分類されるように、型がその種によって分類されることを思い出してください。これまでは<code>*</code>（型の種）と<code>-&gt;</code>（型構築子のための種を構築する）だけから構築された種のみを見てきました。</p>
<p><code>Eff</code>の種を見るには、<code>psci</code>で<code>:k</code> コマンドを使います。</p>
<pre class="text"><code>&gt; :k Control.Monad.Eff.Eff

 # ! -&gt; * -&gt; *</code></pre>
<p>今まで見たことのない記号が２つあります。</p>
<p><code>!</code>は副作用の型についての<strong>型レベルのラベル</strong>を表す<strong>作用</strong>の種です。これを理解するためには、上の<code>main</code>で見た2つのラベルがいずれも種<code>!</code>を持っていることに注目してください。</p>
<pre class="text"><code>&gt; :k Debug.Trace.Trace

  !

&gt; :k Control.Monad.Eff.Random.Random

  !</code></pre>
<p><code>#</code>種構築子は<strong>行</strong>の種を構築するのに使われます。行とは順序なしラベル付きの集合のことです。</p>
<p>そして、<code>Eff</code>は作用の行と作用の返り値の型という２つの引数を持っています。つまり、 <code>Eff</code>の最初の引数は、作用の型の順序なしラベル付きの集合であり、２つめの引数は返り値の型だということです。</p>
<p>これで、先ほどの<code>main</code>の型を読むことができるようになりました。</p>
<pre class="text"><code>forall eff. Eff (trace :: Trace, random :: Random | eff) Unit</code></pre>
<p><code>Eff</code>の最初の引数は<code>(trace :: Trace, random :: Random | eff)</code>です。これは<code>Trace</code>作用と<code>Random</code>作用を含む行です。パイプ記号<code>|</code>は、ラベルが付けられた作用と、それに混ぜあわせたい<strong>それ以外の任意の作用</strong>を表す<strong>行変数</strong>(row variable)<code>eff</code>を区切っています。</p>
<p><code>Eff</code>の2番目の引数は、計算の戻り値の型<code>Unit</code>です。</p>
<h2 id="オブジェクトと行"><span class="header-section-number">8.14</span> オブジェクトと行</h2>
<p>拡張可能作用とレコードに深いつながりをもたらしている<code>Eff</code>の種を考えてみましょう。</p>
<p>上で定義した関数<code>fullName</code>を考えます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fullName ::</span> forall r<span class="fu">.</span> {<span class="ot"> firstName ::</span> <span class="dt">String</span>,<span class="ot"> lastName ::</span> <span class="dt">String</span> <span class="fu">|</span> r } <span class="ot">-&gt;</span> <span class="dt">String</span>
fullName person <span class="fu">=</span> person<span class="fu">.</span>firstName <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> person<span class="fu">.</span>lastName</code></pre>
<p>種<code>*</code>の型だけが値を持つので、関数の矢印の左辺にある型の種は<code>*</code>でなければなりません。</p>
<p>中括弧は実際には構文糖であり、PureScriptコンパイラによって理解されている完全な型は次のようなものです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fullName ::</span> forall r<span class="fu">.</span> <span class="dt">Object</span> (<span class="ot">firstName ::</span> <span class="dt">String</span>,<span class="ot"> lastName ::</span> <span class="dt">String</span> <span class="fu">|</span> r) <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre>
<p>中括弧がなくなっており、<code>Object</code>構築子が追加されていることに注意してください。<code>Object</code>は<code>Prim</code>モジュールで定義されている組み込みの型構築子です。<code>Object</code>の種を調べてみると、次のようになっています。</p>
<pre class="text"><code>&gt; :k Object

  # * -&gt; *</code></pre>
<p>つまり、<code>Object</code>は<strong>型の行</strong>をとり型を構築する型構築子なのです。これがレコードについての行多相関数を書くことを可能にしているのです。</p>
<p>この型システムでは、拡張可能作用を扱うのに、行多相レコード(拡張可能レコード)を使うときと同じ機構が使われています。唯一の違いは、ラベルに現れる型の<strong>種</strong>です。レコードは型の行によってパラメータ化され、<code>Eff</code>は作用の行によってパラメータ化されるのです。</p>
<p>これと同じ型システムの機能は、型構築子の行や、行の行でパラメータ化される型を構築するのにさえ使われることがあります！</p>
<h2 id="きめ細かな作用"><span class="header-section-number">8.15</span> きめ細かな作用</h2>
<p>作用の行は推論されるので、大抵の場合は<code>Eff</code>を使うときに型注釈は必須ではありませんが、計算でどの作用が期待されるのかをコンパイラに示すために型注釈が使われることがあります。</p>
<p>先ほどの例を、作用の<strong>閉じた</strong>行で注釈すると次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">Eff</span> (<span class="ot">trace ::</span> <span class="dt">Trace</span>,<span class="ot"> random ::</span> <span class="dt">Random</span>) <span class="dt">Unit</span>
main <span class="fu">=</span> <span class="kw">do</span>
  n <span class="ot">&lt;-</span> random
  print n</code></pre>
<p>行変数<code>eff</code>がないことに注意してください。こうすると、異なった作用の型を使う計算を誤って含めることはできません。このように、コードが持つことを許される副作用を制御することができるのです。</p>
<h2 id="ハンドラとアクション"><span class="header-section-number">8.16</span> ハンドラとアクション</h2>
<p><code>trace</code>や<code>random</code>のような関数は<strong>アクション</strong>と呼ばれます。アクションはそれらの関数の右辺に<code>Eff</code>型を持っており、その目的は新たな効果を<strong>導入</strong>することにあります。</p>
<p>これは<code>Eff</code>型が関数の引数の型として現れる<strong>ハンドラ</strong>とは対照的です。アクションが集合へ必要な作用を<strong>追加</strong>するのに対し、ハンドラは集合から作用を<strong>除去</strong>します。</p>
<p>例として、<code>purescript-exceptions</code>パッケージを考えてみます。このパッケージでは<code>throwException</code>と<code>catchException</code>という二つの関数が定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">throwException ::</span> forall a eff<span class="fu">.</span> <span class="dt">Error</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">err ::</span> <span class="dt">Exception</span> <span class="fu">|</span> eff) a

<span class="ot">catchException ::</span> forall a eff<span class="fu">.</span> (<span class="dt">Error</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> eff a) <span class="ot">-&gt;</span> 
                                <span class="dt">Eff</span> (<span class="ot">err ::</span> <span class="dt">Exception</span> <span class="fu">|</span> eff) a <span class="ot">-&gt;</span> 
                                <span class="dt">Eff</span> eff a</code></pre>
<p><code>throwException</code>はアクションです。 <code>Eff</code>は右辺に現れていて、新しく<code>Exception</code>作用を導入します。</p>
<p><code>catchException</code>はハンドラです。 <code>Eff</code>は関数の第２引数の型として出現しており、作用全体としては<code>Exception</code>作用を<strong>除去</strong>します。</p>
<p>特定の作用を必要とするコードの部分を限定するために型システムを使うことができるので、これは便利です。作用のあるコードをハンドラで包むことにより、その作用を許さないコードブロックの中に埋め込むことができます。</p>
<p>例えば、<code>Exception</code>作用を使って例外を投げるコード片を書き、それからそのコードを<code>catchException</code>で包むことによって、例外を許さないコード片の中にその計算を埋め込むことができるのです。</p>
<p>JSONドキュメントからアプリケーションの設定を読みたいとしましょう。文書を構文解析する過程で例外を投げることがあります。設定を読み構文解析するこの処理は、次のような型シグネチャを持つ関数として書くことができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readConfig ::</span> forall eff<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">err ::</span> <span class="dt">Exception</span> <span class="fu">|</span> eff) <span class="dt">Config</span></code></pre>
<p>それから、<code>main</code>関数で<code>catchException</code>を使用して<code>Exception</code>作用を処理することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> catchException printException <span class="fu">$</span> <span class="kw">do</span>
  config <span class="ot">&lt;-</span> readConfig
  runApplication config
  
  <span class="kw">where</span>
  printException e <span class="fu">=</span> trace (stackTrace e)</code></pre>
<p>Preludeでも、副作用<strong>なし</strong>の計算を取り、それを純粋な値として安全に評価する<code>runPure</code>ハンドラが定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Pure</span> a <span class="fu">=</span> forall e<span class="fu">.</span> <span class="dt">Eff</span> e a

<span class="ot">runPure ::</span> forall a<span class="fu">.</span> <span class="dt">Pure</span> a <span class="ot">-&gt;</span> a</code></pre>
<h2 id="可変状態"><span class="header-section-number">8.17</span> 可変状態</h2>
<p>Preludeには<code>ST</code>作用というまた別の作用も定義されています。</p>
<p><code>ST</code>作用は変更可能な状態を操作するために使われます。純粋関数プログラミングを知っているなら、共有される変更可能な状態は問題を引き起こしやすいということも知っているでしょう。しかしながら、<code>ST</code>作用は型システムを使って安全で<strong>局所的な</strong>状態変化を可能にし、状態の共有を制限するのです。</p>
<p><code>ST</code>作用は<code>Control.Monad.ST</code>モジュールで定義されています。これがどのように動作するかを確認するには、そのアクションの型を見る必要があります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">newSTRef ::</span> forall a h eff<span class="fu">.</span> a <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">st ::</span> <span class="dt">ST</span> h <span class="fu">|</span> eff) (<span class="dt">STRef</span> h a)

<span class="ot">readSTRef ::</span> forall a h eff<span class="fu">.</span> <span class="dt">STRef</span> h a <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">st ::</span> <span class="dt">ST</span> h <span class="fu">|</span> eff) a

<span class="ot">writeSTRef ::</span> forall a h eff<span class="fu">.</span> <span class="dt">STRef</span> h a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">st ::</span> <span class="dt">ST</span> h <span class="fu">|</span> eff) a

<span class="ot">modifySTRef ::</span> forall a h eff<span class="fu">.</span> <span class="dt">STRef</span> h a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">st ::</span> <span class="dt">ST</span> h <span class="fu">|</span> eff) a</code></pre>
<p><code>newSTRef</code>は型<code>STRef h a</code>の変更可能な参照領域を新しく作るのに使われます。<code>STRef h a</code>は<code>readSTRef</code>アクションを使って状態を読み取ったり、<code>writeSTRef</code>アクションや<code>modifySTRef</code>アクションで状態を変更するのに使われます。型<code>a</code>は領域に格納された値の型で、型<code>h</code>は型システムの<strong>メモリ領域</strong>を表しています。</p>
<p>例を示します。小さな時間刻みで簡単な更新関数の実行を何度も繰り返すことによって、重力に従って落下する粒子の落下の動きをシミュレートしたいとしましょう。</p>
<p>粒子の位置と速度を保持する変更可能な参照領域を作成し、領域に格納された値を更新するのにforループ(<code>Control.Monad.Eff</code>の<code>forE</code>アクション)を使うことでこれを実現することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Eff</span>
<span class="kw">import </span><span class="dt">Control.Monad.ST</span>

<span class="ot">simulate ::</span> forall eff h<span class="fu">.</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">st ::</span> <span class="dt">ST</span> h <span class="fu">|</span> eff) <span class="dt">Number</span>
simulate x0 v0 time <span class="fu">=</span> <span class="kw">do</span>
  ref <span class="ot">&lt;-</span> newSTRef { x<span class="fu">:</span> x0, v<span class="fu">:</span> v0 }
  forE <span class="dv">0</span> (time <span class="fu">*</span> <span class="dv">1000</span>) <span class="fu">$</span> \i <span class="ot">-&gt;</span> <span class="kw">do</span>
    modifySTRef ref (\o <span class="ot">-&gt;</span>
      { v<span class="fu">:</span> o<span class="fu">.</span>v <span class="fu">-</span> <span class="fl">9.81</span> <span class="fu">*</span> <span class="fl">0.001</span>
      , x<span class="fu">:</span> o<span class="fu">.</span>x <span class="fu">+</span> o<span class="fu">.</span>v <span class="fu">*</span> <span class="fl">0.001</span>
      })
    return unit
  final <span class="ot">&lt;-</span> readSTRef ref
  return final<span class="fu">.</span>x</code></pre>
<p>計算の最後では、参照領域の最終的な値を読み取り、粒子の位置を返しています。</p>
<p>この関数が変更可能な状態を使っていても、その参照区画<code>ref</code>がプログラムの他の部分で使われるのが許されない限り、これは純粋な関数のままであることに注意してください。<code>ST</code>作用が禁止するものが正確には何であるのかについては後ほど見ます。</p>
<p><code>ST</code>作用で計算を実行するには、<code>runST</code>関数を使用する必要があります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runST ::</span> forall a eff<span class="fu">.</span> (forall h<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">st ::</span> <span class="dt">ST</span> h <span class="fu">|</span> eff) a) <span class="ot">-&gt;</span> <span class="dt">Eff</span> eff a</code></pre>
<p>ここで注目して欲しいのは、領域型<code>h</code>が関数矢印の左辺にある<strong>括弧の内側で</strong>量化されているということです。<code>runST</code>に渡したどんなアクションでも、 <strong>任意の領域</strong><code>h</code>がなんであれ動作するということを意味しています。</p>
<p>しかしながら、ひとたび参照領域が<code>newSTRef</code>によって作成されると、その領域の型はすでに固定されており、<code>runST</code>によって限定されたコードの外側で参照領域を使おうとしても型エラーになるでしょう。<code>runST</code>が安全に<code>ST</code>作用を除去できるのはこれが理由なのです！</p>
<p>実際に、<code>ST</code>はこの例の唯一の作用なので、<code>runPure</code>と<code>runST</code>を併用すると<code>simulate</code>を純粋な関数に変えることができます、</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">simulate&#39; ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span>
simulate&#39; x0 v0 time <span class="fu">=</span> runPure (runST (simulate x0 v0 time))</code></pre>
<p><code>psci</code> でこの関数を実行してみてください。</p>
<pre class="text"><code>&gt; Main.simulate&#39; 100 0 0.0
100.00

&gt; Main.simulate&#39; 100 0 1.0
95.10

&gt; Main.simulate&#39; 100 0 2.0
80.39

&gt; Main.simulate&#39; 100 0 3.0
55.87

&gt; Main.simulate&#39; 100 0 4.0
21.54</code></pre>
<p>もし<code>simulate</code>の定義を<code>runST</code>の呼び出しのところへ埋め込むとすると、次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">simulate ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span>
simulate x0 v0 time <span class="fu">=</span> runPure (runST (<span class="kw">do</span>
  ref <span class="ot">&lt;-</span> newSTRef { x<span class="fu">:</span> x0, v<span class="fu">:</span> v0 }
  forE <span class="dv">0</span> (time <span class="fu">*</span> <span class="dv">1000</span>) <span class="fu">$</span> \i <span class="ot">-&gt;</span> <span class="kw">do</span>
    modifySTRef ref (\o <span class="ot">-&gt;</span>  
      { v<span class="fu">:</span> o<span class="fu">.</span>v <span class="fu">-</span> <span class="fl">9.81</span> <span class="fu">*</span> <span class="fl">0.001</span>
      , x<span class="fu">:</span> o<span class="fu">.</span>x <span class="fu">+</span> o<span class="fu">.</span>v <span class="fu">*</span> <span class="fl">0.001</span>  
      })
    return unit  
  final <span class="ot">&lt;-</span> readSTRef ref
  return final<span class="fu">.</span>x))</code></pre>
<p>参照区画はそのスコープから逃れることができないことが<code>psc</code>コンパイラにわかりますし、安全に<code>var</code>に変換することができます。<code>runST</code>の呼び出しの本体に対して生成されたJavaScriptは次のようになります。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> ref = { <span class="dt">x</span>: x0, <span class="dt">v</span>: v0 };

<span class="ot">Control_Monad_Eff</span>.<span class="fu">forE</span>(<span class="dv">0</span>)(time * <span class="dv">1000</span>)(<span class="kw">function</span> (i) {
  <span class="kw">return</span> <span class="kw">function</span> <span class="fu">__do</span>() {
    ref = (<span class="kw">function</span> (o) {
      <span class="kw">return</span> {
        <span class="dt">v</span>: <span class="ot">o</span>.<span class="fu">v</span> - <span class="fl">9.81</span> * <span class="fl">1.0e-3</span>, 
        <span class="dt">x</span>: <span class="ot">o</span>.<span class="fu">x</span> + <span class="ot">o</span>.<span class="fu">v</span> * <span class="fl">1.0e-3</span>
      };
    })(ref);
    <span class="kw">return</span> <span class="ot">Prelude</span>.<span class="fu">unit</span>;
  };
})();

<span class="kw">return</span> <span class="ot">ref</span>.<span class="fu">x</span>;</code></pre>
<p>局所的な変更可能状態を扱うとき、特に<code>Eff</code>モナドで効率のよいループを生成する<code>forE</code>、<code>foreachE</code>、<code>whileE</code>、<code>untilE</code>のようなアクションを一緒に使うときには、<code>ST</code>作用は短いJavaScriptを生成できる良い方法となります。</p>
<blockquote>
<h2 id="演習-21" class="unnumbered">演習</h2>
<ol type="1">
<li><p>（やや難しい） もし分母で分子を割り切れないなら<code>throwException</code>を使って例外を投げるように<code>safeDivide</code>関数を書き直してください。</p></li>
<li><p>（難しい） PIを推定するには次のような簡単な方法があります。単位正方形内にある多数の<code>N</code>個の点を無作為に選び、内接する円に含まれるものの個数<code>n</code>を数えます。このとき<code>4n/N</code>が円周率<code>pi</code>の概算となります。<code>forE</code>関数、<code>Random</code>作用、<code>ST</code>作用を使って、この方法で円周率<code>pi</code>を推定する関数を書いてください。</p></li>
</ol>
</blockquote>
<h2 id="dom作用"><span class="header-section-number">8.18</span> DOM作用</h2>
<p>この章の最後の節では、<code>Eff</code>モナドでの作用についてこれまで学んだことを、実際のDOM操作の問題に応用します。</p>
<p>DOMを直接扱ったり、オープンソースのDOMライブラリを扱う、自由に利用可能なPureScriptパッケージが幾つかあります。</p>
<ul>
<li><a href="http://github.com/aktowns/purescript-simple-dom"><code>purescript-simple-dom</code></a> - JavaScript DOM APIのバインディング</li>
<li><a href="http://github.com/purescript-contrib/purescript-jquery"><code>purescript-jquery</code></a> - <a href="http://jquery.org">jQuery</a>ライブラリのバインディング</li>
<li><a href="http://github.com/purescript-contrib/purescript-react"><code>purescript-react</code></a> - <a href="http://facebook.github.io/react/">React</a>ライブラリへのバインディング</li>
<li><a href="http://github.com/purescript-contrib/purescript-angular"><code>purescript-angular</code></a> - <a href="http://angularjs.org/">AngularJS</a>ライブラリのバインディング</li>
<li><a href="http://github.com/purescript-contrib/purescript-virtual-dom"><code>purescript-virtual-dom</code></a> - <a href="http://github.com/Matt-Esch/virtual-dom">virtual-dom</a>ライブラリの最小限のラッパ</li>
</ul>
<p>しかしながら、これらのライブラリのほとんどはまだ非常に新しくAPIが安定なため、この章の内容を安定させられるように、この章のソースコードの<code>Control.Monad.DOM</code>モジュールにはDOM要素を操作するための最小限の関数群が含まれています。</p>
<p>DOM要素を作成や操作をするための次のようなアクションが含まれています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">body ::</span> forall eff<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Node</span>
<span class="ot">createElement ::</span> forall eff<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Node</span>
<span class="ot">querySelector ::</span> forall eff<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) (<span class="dt">Maybe</span> <span class="dt">Node</span>)</code></pre>
<p>既存の要素の内容やスタイルを変更するためのアクションも用意されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">setText ::</span> forall eff<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Node</span>
<span class="ot">setInnerHTML ::</span> forall eff<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Node</span>
<span class="ot">appendChild ::</span> forall eff<span class="fu">.</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Node</span>
<span class="ot">addClass ::</span> forall eff<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Node</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Node</span></code></pre>
<p>そして、DOMイベントを処理するためのアクションがあります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">addEventListener ::</span> forall eff<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> 
                                <span class="dt">Eff</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Unit</span> <span class="ot">-&gt;</span> 
                                <span class="dt">Node</span> <span class="ot">-&gt;</span> 
                                <span class="dt">Eff</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Node</span></code></pre>
<p>これらが住所録アプリケーションのユーザインターフェイスを作るのに必要なアクションです。</p>
<h2 id="住所録のユーザーインタフェース"><span class="header-section-number">8.19</span> 住所録のユーザーインタフェース</h2>
<p>これから構築しようとしているユーザ·インタフェースは、HTMLとPureScriptファイルに分かれています。HTMLはページ上の要素の配置を定義し、PureScriptのコードはフォームの動的な振る舞いを制御する方法を定義します。</p>
<p>まずは利用者が住所録に新しい項目を追加できるフォームを構築することにしましょう。フォームには、さまざまなフィールド（姓、名前、都市、州など）を入力するテキストボックス、および検証エラーが表示される領域が含まれます。テキストボックスに利用者がテキストを入力すると、検証エラーが更新されます。</p>
<p>シンプルさを保つために、フォームは固定の形状とします。電話番号は種類（自宅、携帯電話、仕事、その他）ごとに別々のテキストボックスへ分けることにします。</p>
<p><code>head</code>要素内の次のようなコードを除いて、HTMLファイルは完全に静的です。</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;script</span><span class="ot"> type=</span><span class="st">&quot;text/javascript&quot;</span><span class="ot"> src=</span><span class="st">&quot;../dist/Main.js&quot;</span><span class="kw">&gt;&lt;/script&gt;</span>
<span class="kw">&lt;script</span><span class="ot"> type=</span><span class="st">&quot;text/javascript&quot;</span><span class="kw">&gt;</span>
  onload = <span class="ot">PS</span>.<span class="ot">Main</span>.<span class="fu">main</span>;
&lt;<span class="ot">/script&gt;  </span></code></pre>
<p>最初の行では<code>psc</code>によって生成されるJavaScriptコードを読み込み、2行目ではページがロードされたときに<code>PS.Main.main</code>関数が確実に実行されるようにしています。</p>
<p><code>Main</code>モジュールはとても単純です。<code>Data.AddressBook.UI</code>モジュールには<code>setupEventHandlers</code>関数に処理をそのまま移譲する<code>main</code>関数だけが定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> forall eff<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">trace ::</span> <span class="dt">Trace</span>,<span class="ot"> dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Unit</span>
main <span class="fu">=</span> <span class="kw">do</span>
  trace <span class="st">&quot;Attaching event handlers&quot;</span>
  setupEventHandlers </code></pre>
<p>これは混在した作用の一例になっていることに注目してください。下で見るように、<code>trace</code>関数は<code>Trace</code>作用を使い、<code>setupEventHandlers</code>関数は<code>Trace</code>作用と<code>DOM</code>作用の両方を使っています(<code>DOM</code>作用は<code>Control.Monad.Eff.DOM</code>で定義されています)。</p>
<p><code>setupEventHandlers</code>関数もとても簡単です（単一の目的を持った小​​さな関数それぞれに分割することによって、コードについて理解するのが簡単になっていることに注目してください）​​。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">setupEventHandlers ::</span> forall eff<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">trace ::</span> <span class="dt">Trace</span>,<span class="ot"> dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Unit</span>
setupEventHandlers <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- Listen for changes on form fields</span>
  body <span class="fu">&gt;&gt;=</span> addEventListener <span class="st">&quot;change&quot;</span> validateAndUpdateUI </code></pre>
<p><code>setupEventHandlers</code>はまず文書のbodyへの参照を取得するために<code>body</code>アクションを使い、<code>&gt;&gt;=</code>を使ってその結果を<code>addEventListener</code>アクションに渡しています。<code>addEventListener</code>は<code>change</code>イベントを監視して、イベントが発生するとその度に<code>validateAndUpdateUI</code>アクションを呼び出します。</p>
<p>do記法の定義により、これを次のようにも書けることに注意してください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">setupEventHandlers <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- Listen for changes on form fields</span>
  b <span class="ot">&lt;-</span> body
  addEventListener <span class="st">&quot;change&quot;</span> validateAndUpdateUI b</code></pre>
<p>どちらが読みやすいかどうかは個人の好みの問題です。前者は名前が付けられた関数の引数がなく、<strong>point-free</strong>形式の一例となっています。その一方で、後者では文書のbodyの名前として<code>b</code>が使われています。</p>
<p><code>validateAndUpdateUI</code>アクションの役目は、フォーム検証器を実行し、必要に応じて利用者にエラーのリストを表示することです。この場合も、他の関数へ処理を委譲することによってこれを行います。最初に、<code>querySelector</code>アクションを使用してページの<code>validationErrors</code>要素を選択しています。それから、その要素の内容を消去するために<code>setInnerHTML</code>アクションを使用しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">validateAndUpdateUI ::</span> forall eff<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">trace ::</span> <span class="dt">Trace</span>,<span class="ot"> dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Unit</span>
validateAndUpdateUI <span class="fu">=</span> <span class="kw">do</span>
  <span class="dt">Just</span> validationErrors <span class="ot">&lt;-</span> querySelector <span class="st">&quot;#validationErrors&quot;</span>        
  setInnerHTML <span class="st">&quot;&quot;</span> validationErrors </code></pre>
<p>次に<code>validateAndUpdateUI</code>が<code>validateControls</code>アクションを呼び出し、フォームの検証を実行しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  errorsOrResult <span class="ot">&lt;-</span> validateControls</code></pre>
<p>後ほどすぐに見るように、<code>errorsOrResult</code>はエラーのリストか<code>Person</code>レコードのどちらかを表す型<code>Either [String] Person</code>を持っています。</p>
<p>最後に、もし入​​力の検証に失敗すると、<code>validateAndUpdateUI</code>はページ上のエラーを表示するために <code>displayValidationErrors</code>アクションに処理を委譲します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">case</span> errorsOrResult <span class="kw">of</span>
    <span class="dt">Left</span> errs <span class="ot">-&gt;</span> displayValidationErrors errs
    <span class="dt">Right</span> result <span class="ot">-&gt;</span> print result

  return unit</code></pre>
<p>検証が成功した場合、コードは単にコンソールに検証結果を出力します。当然のことながら、実際のアプリケーションでは、次の手順でデータベースまたは同様のものにデータを保存することになるでしょう。</p>
<p><code>validateControls</code>関数はより興味深いものです。<code>validateControls</code>の役割は、フォームの検証を実行し、成功または失敗のいずれかを示す結果を返すことであることを思い出してください。最初に行うことは、コンソールにデバッグメッセージを出力することです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">validateControls ::</span> forall eff<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">trace ::</span> <span class="dt">Trace</span>,<span class="ot"> dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) 
                                    (<span class="dt">Either</span> [<span class="dt">String</span>] <span class="dt">Person</span>)  
validateControls <span class="fu">=</span> <span class="kw">do</span>
  trace <span class="st">&quot;Running validators&quot;</span></code></pre>
<p><code>Data.AddressBook.UI</code>モジュールでは、フォームフィールドから値を読み込む関数 <code>valueOf</code>が定義されています。ここでは型シグネチャだけを示し、実装については議論しません。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">valueOf ::</span> forall eff<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">String</span></code></pre>
<p><code>valueOf</code>はフォーム要素のIDをとり、利用者がそのテキストボックスに入力した値を返します。</p>
<p>次に、<code>validateControls</code>はページ上のフォームフィールドからいろいろな文字列を読み取って<code>Data.AddressBook.Person</code>データ構造体を構築します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  p <span class="ot">&lt;-</span> person 
    <span class="fu">&lt;$&gt;</span> valueOf <span class="st">&quot;#inputFirstName&quot;</span>
    <span class="fu">&lt;*&gt;</span> valueOf <span class="st">&quot;#inputLastName&quot;</span>
    <span class="fu">&lt;*&gt;</span> (address <span class="fu">&lt;$&gt;</span> valueOf <span class="st">&quot;#inputStreet&quot;</span>
                 <span class="fu">&lt;*&gt;</span> valueOf <span class="st">&quot;#inputCity&quot;</span>
                 <span class="fu">&lt;*&gt;</span> valueOf <span class="st">&quot;#inputState&quot;</span>)
    <span class="fu">&lt;*&gt;</span> sequence [ phoneNumber <span class="dt">HomePhone</span> <span class="fu">&lt;$&gt;</span> valueOf <span class="st">&quot;#inputHomePhone&quot;</span>
                 , phoneNumber <span class="dt">CellPhone</span> <span class="fu">&lt;$&gt;</span> valueOf <span class="st">&quot;#inputCellPhone&quot;</span>
                 ]</code></pre>
<p>この計算では <code>person</code>、<code>address</code>、<code>phoneNumber</code>関数を持ち上げるために、<code>Eff</code>をApplicative関手として使用していることに注意してください。また、<code>Person</code>データ構造体の電話番号配列をまとめるために必要な<code>Eff</code>の配列を連鎖させるために、<code>Data.Traversable</code>の<code>sequense</code>関数を使っています。</p>
<p>最後に、<code>validateControls</code>は前の章で書いた検証関数を実行し、その結果を返します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  return <span class="fu">$</span> validatePerson&#39; p</code></pre>
<p>残りのコー​​ドは<code>displayValidationErrors</code>関数です。<code>displayValidationErrors</code>はエラーの配列をとり、ページ上にそれらの文字列を出力します。</p>
<p>この関数が最初に行うことは、エラーを表示するための新しい<code>div</code>要素を作成することです。フォームのレイアウトを制御するために<a href="http://getbootstrap.com/">Bootstrap library</a>を使っているので、<code>addClass</code>アクションを使って新しい要素に適切なCSSクラスを設定しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">displayValidationErrors ::</span> forall eff<span class="fu">.</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">dom ::</span> <span class="dt">DOM</span> <span class="fu">|</span> eff) <span class="dt">Unit</span>
displayValidationErrors errs <span class="fu">=</span> <span class="kw">do</span>
  alert <span class="ot">&lt;-</span> createElement <span class="st">&quot;div&quot;</span>
    <span class="fu">&gt;&gt;=</span> addClass <span class="st">&quot;alert&quot;</span> 
    <span class="fu">&gt;&gt;=</span> addClass <span class="st">&quot;alert-danger&quot;</span></code></pre>
<p>このコードがpoint-free形式であることに改めて注意してください。興味のある読者は、これを<code>&gt;&gt;=</code>を使わないように書き換えてみることをおすすめします。</p>
<p>次のコードは<code>ul</code>要素を作成し先ほどの<code>div</code>に追加します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  ul <span class="ot">&lt;-</span> createElement <span class="st">&quot;ul&quot;</span>
  ul <span class="ot">`appendChild`</span> alert</code></pre>
<p>配列内の各エラーそれぞれについて<code>li</code>要素を作成して、リストに追加します。<code>setText</code>アクションは、エラーメッセージを<code>li</code>要素のテキストコンテンツを設定するために使用されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  foreachE errs <span class="fu">$</span> \err <span class="ot">-&gt;</span> <span class="kw">do</span>
    li <span class="ot">&lt;-</span> createElement <span class="st">&quot;li&quot;</span> <span class="fu">&gt;&gt;=</span> setText err
    li <span class="ot">`appendChild`</span> ul
    return unit</code></pre>
<p>配列の要素について繰り返しを行うために、このコードでは<code>foreachE</code>アクションを使っています。これは以前に見た<code>traverse</code>関数に似ていますが、<code>Eff</code>モナドだけで使うように特殊化されています。</p>
<p>最後に、<code>querySelector</code>アクションを使って<code>validationErrors</code>要素を検索し、それに先ほどの<code>div</code>を追加します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="dt">Just</span> validationErrors <span class="ot">&lt;-</span> querySelector <span class="st">&quot;#validationErrors&quot;</span>
  alert <span class="ot">`appendChild`</span> validationErrors
  
  return unit</code></pre>
<p>以上です！<code>grunt</code>を実行して、それからWebブラウザで <code>html/index.html</code>を開き、ユーザインターフェイスを試してみてください。</p>
<p>フォームフィールドにいろいろな値を入力すると、ページ上に出力された検証エラーを見ることができるでしょう。検証エラーをすべて修正すると、ブラウザのコンソール上に検証の結果が表示されるはずです。</p>
<p>このユーザインタフェースには明らかに改善すべき点がたくさんあります。演習ではアプリケーションがより使いやすくなるような方法を追究していきます。</p>
<blockquote>
<h2 id="演習-22" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単) このアプリケーションを変更し、職場の電話番号のテキストボックスを追加してください。</p></li>
<li><p>(やや難しい) 検証エラーを<code>ul</code>要素を使ってリストで表示するかわりに、それぞれのエラーについてひとつづつ<code>alert</code>スタイルで<code>div</code>を作成するように、コードを変更してください。</p></li>
<li>(やや難しい) <code>&gt;&gt;=</code>の明示的な呼び出しを使わないように、<code>Data.AddressBook.UI</code>モジュールのコードを書き直してください。</li>
<li><p>(難しい、拡張) このユーザーインターフェイスの問題のひとつは、検証エラーがその発生源であるフォームフィールドの隣に表示されていないことです。コードを変更してこの問題を解決してください。</p>
<p><strong>ヒント</strong>：検証器によって返されるエラーの型は、エラーの原因となっているフィールドを示すために拡張する必要があります。次のようなエラー型を使用したくなるかもしれません。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ValidationError</span> <span class="fu">=</span> <span class="dt">ValidationError</span> <span class="dt">String</span> <span class="dt">Field</span>

<span class="kw">data</span> <span class="dt">Field</span> <span class="fu">=</span> <span class="dt">FirstNameField</span>
           <span class="fu">|</span> <span class="dt">LastNameField</span> 
           <span class="fu">|</span> <span class="dt">StreetField</span>
           <span class="fu">|</span> <span class="dt">CityField</span>
           <span class="fu">|</span> <span class="dt">StateField</span>
           <span class="fu">|</span> <span class="dt">PhoneField</span> <span class="dt">PhoneType</span></code></pre>
<p>適切なフォーム要素を選択するように、<code>Field</code>を<code>querySelector</code>アクションの呼び出しに変更する関数を書くする必要があるでしょう。</p></li>
</ol>
</blockquote>
<h2 id="まとめ-6"><span class="header-section-number">8.20</span> まとめ</h2>
<p>この章ではPureScriptでの副作用の扱いについての多くの考え方を導入しました。</p>
<ul>
<li><code>Monad</code>型クラスと、それに関連するdo記法の導入しました。</li>
<li>モナド則を導入し、do記法使って書かれたコードを変換する方法を説明しました</li>
<li>異なる副作用で動作するコードを書くために、モナドを抽象的に扱う方法を説明しました。</li>
<li>モナドがApplicative関手の一例であること、両者がどのように副作用のある計算を可能にするのか、2つの手法の違いを説明しました。</li>
<li>ネイティブな作用の概念を定義し、ネイティブな副作用を処理するために使用する<code>Eff</code>モナドを導入しました。</li>
<li>どのように<code>Eff</code>モナドが拡張可能作用を提供するか、複数の種類のネイティブな作用を同じ計算に混在させる方法を説明しました。</li>
<li>作用やレコードが種システムでどのように扱われるか、拡張可能なレコードと拡張可能作用の関連を見ました。</li>
<li>乱数生成、例外、コンソール入出力、変更可能な状態、およびDOM操作といった、さまざまな作用を扱うために <code>Eff</code>モナドを使いました。</li>
</ul>
<p><code>Eff</code>モナドは現実のPureScriptコードにおける基本的なツールです。本書ではこのあとも、様々な場面で副作用を処理するために<code>Eff</code>モナドを使っていきます。</p>
<h1 id="キャンバスグラフィックス"><span class="header-section-number">9</span> キャンバスグラフィックス</h1>
<h2 id="この章の目標-6"><span class="header-section-number">9.1</span> この章の目標</h2>
<p>この章のコード例では、PureScriptでHTML5のCanvas APIを使用して2Dグラフィックスを生成する<code>purescript-canvas</code>パッケージに焦点をあててコードを拡張していきます。</p>
<h2 id="プロジェクトの準備-6"><span class="header-section-number">9.2</span> プロジェクトの準備</h2>
<p>このモジュールのプロジェクトでは、以下のBowerの依存関係が新しく追加されています。</p>
<ul>
<li><code>purescript-canvas</code> - HTML5のCanvas APIのメソッドの型が定義されています。</li>
<li><code>purescript-refs</code> - <strong>大域的な変更可能領域への参照</strong>を扱うための副作用を提供しています。</li>
</ul>
<p>この章のソースコードは、それぞれに<code>main</code>メソッドが定義されている複数のモ​​ジュールへと分割されています。この章の節の内容はそれぞれ異なるファイルで実装されており、それぞれの節で対応するファイルの<code>main</code>メソッドを実行できるように、Gruntビルドターゲットを変更することで<code>Main</code>モジュールが変更できるようになっています。</p>
<p>HTMLファイル <code>html/index.html</code>には、各例で使用される単一の<code>canvas</code>要素、およびコンパイルされたPureScriptコードを読み込む<code>script</code>要素が含まれています。各節のコードをテストするには、ブラウザでこのHTMLファイルを開いてください。</p>
<h2 id="単純な図形"><span class="header-section-number">9.3</span> 単純な図形</h2>
<p><code>Rectangle.purs</code>ファイルにはキャンバスの中心に青い四角形をひとつ描画するという簡単な例が含まれています。このモジュールは、<code>Control.Monad.Eff</code>モジュールと、Canvas APIを扱うための<code>Eff</code>モナドのアクションが定義されている<code>Graphics.Canvas</code>モジュールをインポートします。</p>
<p>他のモジュールでも同様ですが、<code>main</code>アクションは最初に<code>getCanvasElementById</code>アクションを使ってCanvasオブジェクトへの参照を取得しています。また、<code>getContext2D</code>アクションを使ってキャンバスの2Dレンダリングコンテキストを参照しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
  canvas <span class="ot">&lt;-</span> getCanvasElementById <span class="st">&quot;canvas&quot;</span>
  ctx <span class="ot">&lt;-</span> getContext2D canvas</code></pre>
<p>これらのアクションの型は <code>psci</code>を使うかドキュメントを見ると確認できます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getCanvasElementById ::</span> forall eff<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">canvas ::</span> <span class="dt">Canvas</span> <span class="fu">|</span> eff) <span class="dt">CanvasElement</span>

<span class="ot">getContext2D ::</span> forall eff<span class="fu">.</span> <span class="dt">CanvasElement</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">canvas ::</span> <span class="dt">Canvas</span> <span class="fu">|</span> eff) <span class="dt">Context2D</span></code></pre>
<p><code>CanvasElement</code>と<code>Context2D</code>は<code>Graphics.Canvas</code>モジュールで定義されている型です。このモジュールでは、モジュール内のすべてのアクションで使用されている<code>Canvas</code>作用も定義されています。</p>
<p>グラフィックスコンテキスト<code>ctx</code>は、キャンバスの状態を管理し、プリミティブな図形を描画したり、スタイルや色を設定したり、座標変換を適用するためのメソッドを提供しています。</p>
<p><code>ctx</code>の取得に続けて、<code>setFillStyle</code>アクションを使って塗りのスタイルを青一色の塗りつぶしに設定しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  setFillStyle <span class="st">&quot;#0000FF&quot;</span> ctx</code></pre>
<p><code>setFillStyle</code>アクションがグラフィックスコンテキストを引数として取っていることに注意してください。これは<code>Graphics.Canvas</code>で共通のパターンです。</p>
<p>最後に、<code>fillPath</code>アクションを使用して矩形を塗りつぶしています。<code>fillPath</code>は次のような型を持っています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fillPath ::</span> forall eff a<span class="fu">.</span> <span class="dt">Context2D</span> <span class="ot">-&gt;</span> 
                          <span class="dt">Eff</span> (<span class="ot">canvas ::</span> <span class="dt">Canvas</span> <span class="fu">|</span> eff) a <span class="ot">-&gt;</span> 
                          <span class="dt">Eff</span> (<span class="ot">canvas ::</span> <span class="dt">Canvas</span> <span class="fu">|</span> eff) a</code></pre>
<p><code>fillPath</code>はグラフィックスコンテキストとレンダリングするパスを構築する別のアクションを引数にとります。パスは<code>rect</code>アクションを使うと構築することができます。<code>rect</code>はグラフィックスコンテキストと矩形の位置及びサイズを格納するレコードを引数にとります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  fillPath ctx <span class="fu">$</span> rect ctx
    { x<span class="fu">:</span> <span class="dv">250</span>
    , y<span class="fu">:</span> <span class="dv">250</span>
    , w<span class="fu">:</span> <span class="dv">100</span>
    , h<span class="fu">:</span> <span class="dv">100</span>
    }</code></pre>
<p>この長方形のコード例をビルドしましょう。</p>
<pre class="text"><code>$ grunt rectangle</code></pre>
<p>それでは<code>html/index.html</code>ファイルを開き、このコードによってキャンバスの中央に青い四角形が描画されていることを確認してみましょう。</p>
<h2 id="行多相を利用する"><span class="header-section-number">9.4</span> 行多相を利用する</h2>
<p>パスを描画する方法は他にもあります。<code>arc</code>関数は円弧を描画します。<code>moveTo</code>関数、 <code>lineTo</code>関数、<code>closePath</code>関数は細かい線分を組み合わせることでパスを描画します。</p>
<p><code>Shapes.purs</code>ファイルでは長方形と円弧セグメント、三角形の、3つの図形を描画しています。</p>
<p><code>rect</code>関数は引数としてレコードをとることを見てきました。実際には、長方形のプロパティは型同義語で定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Rectangle</span> <span class="fu">=</span> {<span class="ot"> x ::</span> <span class="dt">Number</span>
                 ,<span class="ot"> y ::</span> <span class="dt">Number</span>
                 ,<span class="ot"> w ::</span> <span class="dt">Number</span>
                 ,<span class="ot"> h ::</span> <span class="dt">Number</span> 
                 }</code></pre>
<p><code>x</code>と<code>y</code>プロパティは左上隅の位置を表しており、<code>w</code>と<code>h</code>のプロパティはそれぞれ幅と高さを表しています。</p>
<p><code>arc</code>関数に以下のような型を持つレコードを渡して呼び出すと、円弧を描画することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Arc</span> <span class="fu">=</span> {<span class="ot"> x     ::</span> <span class="dt">Number</span>
           ,<span class="ot"> y     ::</span> <span class="dt">Number</span>
           ,<span class="ot"> r     ::</span> <span class="dt">Number</span>
           ,<span class="ot"> start ::</span> <span class="dt">Number</span>
           ,<span class="ot"> end   ::</span> <span class="dt">Number</span>
           }</code></pre>
<p>ここで、<code>x</code>と<code>y</code>プロパティは弧の中心、<code>r</code>は半径、<code>start</code>と<code>end</code>は弧の両端の角度を弧度法で表しています。</p>
<p>たとえば、次のコードは中心<code>(300、300)</code>、半径<code>50</code>の円弧を塗りつぶします。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  fillPath ctx <span class="fu">$</span> arc ctx
    { x      <span class="fu">:</span> <span class="dv">300</span>
    , y      <span class="fu">:</span> <span class="dv">300</span>
    , r      <span class="fu">:</span> <span class="dv">50</span>
    , start  <span class="fu">:</span> Math.pi <span class="fu">*</span> <span class="dv">5</span> <span class="fu">/</span> <span class="dv">8</span>
    , end    <span class="fu">:</span> Math.pi <span class="fu">*</span> <span class="dv">2</span>
    }</code></pre>
<p><code>Number</code>型の<code>x</code>と<code>y</code>というプロパティが<code>Rectangle</code>レコード型と<code>Arc</code>レコード型の両方に含まれていることに注意してください。どちらの場合でもこの組は点を表しています。これは、いずれのレコード型にも適用できる、行多相な関数を書くことができることを意味します。</p>
<p>たとえば、 <code>Shapes</code>モジュールでは<code>x</code>と<code>y</code>のプロパティを変更し図形を並行移動する<code>translate</code>関数を定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">translate ::</span> forall r<span class="fu">.</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span>
              {<span class="ot"> x ::</span> <span class="dt">Number</span>,<span class="ot"> y ::</span> <span class="dt">Number</span> <span class="fu">|</span> r } <span class="ot">-&gt;</span>
              {<span class="ot"> x ::</span> <span class="dt">Number</span>,<span class="ot"> y ::</span> <span class="dt">Number</span> <span class="fu">|</span> r }
translate dx dy shape <span class="fu">=</span> shape
  { x <span class="fu">=</span> shape<span class="fu">.</span>x <span class="fu">+</span> dx
  , y <span class="fu">=</span> shape<span class="fu">.</span>y <span class="fu">+</span> dy
  }</code></pre>
<p>この行多相型に注目してください。これは<code>triangle</code>が<code>x</code>と<code>y</code>というプロパティと、<strong>それに加えて他の任意のプロパティ</strong>を持ったどんなレコードでも受け入れるということを言っています。<code>x</code>フィールドと<code>y</code>フィールドは更新されますが、残りのフィールドは変更されません。</p>
<p>これは<strong>レコード更新構文</strong>の例です。<code>shape { ... }</code>という式は、<code>shape</code>を元にして、括弧の中で指定されたように値が更新されたフィールドを持つ新たなレコードを作ります。波括弧の中の式はレコードリテラルのようなコロンではなく、等号でラベルと式を区切って書くことに意してください。</p>
<p><code>Shapes</code>の例からわかるように、<code>translate</code>関数は<code>Rectangle</code>レコードと<code>Arc</code>レコード双方に対して使うことができます。</p>
<p><code>Shape</code>の例で描画される3つめの型は線分ごとのパスです。対応するコードは次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  setFillStyle <span class="st">&quot;#FF0000&quot;</span> ctx

  fillPath ctx <span class="fu">$</span> <span class="kw">do</span>
    moveTo ctx <span class="dv">300</span> <span class="dv">260</span>
    lineTo ctx <span class="dv">260</span> <span class="dv">340</span>
    lineTo ctx <span class="dv">340</span> <span class="dv">340</span>
    closePath ctx</code></pre>
<p>ここでは3つの関数が使われています。</p>
<ul>
<li><code>moveTo</code>はパスの現在位置を指定された座標へ移動させます。</li>
<li><code>lineTo</code>は現在の位置と指定された座標の間に線分を描画し、現在の位置を更新します。</li>
<li><code>closePath</code>は開始位置と現在位置を結ぶ線分を描画し、パスを閉じます。</li>
</ul>
<p>このコード片を実行すると、二等辺三角形を塗りつぶされます。</p>
<p><code>shapes</code>ターゲットを使ってこの例をビルドしましょう。</p>
<pre class="text"><code>$ grunt shapes</code></pre>
<p>そしてもう一度<code>html/index.html</code>を開き、結果を確認して下さい。キャンバスに３つの異なる型が描画されるはずです。</p>
<blockquote>
<h2 id="演習-23" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単) これまでの例のそれぞれについて、<code>strokePath</code>関数や<code>setStrokeStyle</code>関数を使ってみましょう。</p></li>
<li><p>(簡単) 関数の引数の内部でdo記法ブロックを使うと、<code>fillPath</code>関数と<code>strokePath</code>関数で共通のスタイルを持つ複雑なパスを描画することができます。同じ<code>fillPath</code>呼び出しで隣り合った２つの矩形を描画するように、<code>Rectangle</code>のコード例を変更してみてください。線分と円弧を組み合わせてを、円の扇形を描画してみてください。</p></li>
<li><p>(やや難しい) 次のような２次元の点を表すレコードが与えられたとします。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Point</span> <span class="fu">=</span> {<span class="ot"> x ::</span> <span class="dt">Number</span>,<span class="ot"> y ::</span> <span class="dt">Number</span> }</code></pre>
<p>多数の点からなる閉じたパスを描く関数<code>renderPath</code>書いてください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">renderPath ::</span> forall eff<span class="fu">.</span> <span class="dt">Context2D</span> <span class="ot">-&gt;</span> [<span class="dt">Point</span>] <span class="ot">-&gt;</span> 
                                       <span class="dt">Eff</span> (<span class="ot">canvas ::</span> <span class="dt">Canvas</span> <span class="fu">|</span> eff) <span class="dt">Context2D</span></code></pre>
<p>次のような関数を考えます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Point</span></code></pre>
<p>この関数は引数として<code>1</code>から<code>0</code>の間の<code>Number</code>をとり、<code>Point</code>を返します。<code>renderPath</code>関数を利用して関数<code>f</code>のグラフを描くアクションを書いてください。そのアクションは有限個の点を<code>f</code>からサンプリングすることによって近似しなければなりません。</p>
<p>関数<code>f</code>を変更し、異なるパスが描画されることを確かめてください。</p></li>
</ol>
</blockquote>
<h2 id="無作為に円を描く"><span class="header-section-number">9.5</span> 無作為に円を描く</h2>
<p><code>Random.purs</code>ファイルには2種類の異なる副作用が混在した<code>Eff</code>モナドを使う例が含まれています。この例では無作為に生成された円をキャンバスに100個描画します。</p>
<p><code>main</code>アクションはこれまでのようにグラフィックスコンテキストへの参照を取得し、ストロークと塗りつぶしスタイルを設定します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  setFillStyle <span class="st">&quot;#FF0000&quot;</span> ctx
  setStrokeStyle <span class="st">&quot;#000000&quot;</span> ctx</code></pre>
<p>次のコードでは<code>forE</code>アクションを使って<code>0</code>から<code>100</code>までの整数について繰り返しをしています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  forE <span class="dv">1</span> <span class="dv">100</span> <span class="fu">$</span> \_ <span class="ot">-&gt;</span> <span class="kw">do</span></code></pre>
<p>それぞれの繰り返しでは、do記法ブロックは3つの乱数を生成することから始まっています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    x <span class="ot">&lt;-</span> random
    y <span class="ot">&lt;-</span> random
    r <span class="ot">&lt;-</span> random</code></pre>
<p>これらの数は<code>0</code>から<code>1</code>の間に無作為に分布しています。これらはそれぞれ<code>x</code>座標、<code>y</code>座標、半径<code>r</code>を表しています。</p>
<p>次のコードでこれらの変数に基づいて<code>Arc</code>を作成します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">let</span> path <span class="fu">=</span> arc ctx
         { x     <span class="fu">:</span> x <span class="fu">*</span> <span class="dv">600</span>
         , y     <span class="fu">:</span> y <span class="fu">*</span> <span class="dv">600</span>
         , r     <span class="fu">:</span> r <span class="fu">*</span> <span class="dv">50</span>
         , start <span class="fu">:</span> <span class="dv">0</span>
         , end   <span class="fu">:</span> Math.pi <span class="fu">*</span> <span class="dv">2</span>
         }</code></pre>
<p>そして最後に、現在のスタイルに従って円弧の塗りつぶしと線描が行われます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    fillPath ctx path
    strokePath ctx path

    return unit</code></pre>
<p><code>forE</code>に渡された関数が正しい型を持つようにするため、最後の行は必要であることに注意してください。</p>
<p>Gruntfileの<code>random</code>ターゲットを使用して、この例をビルドします。</p>
<pre class="text"><code>$ grunt random</code></pre>
<p><code>html/index.html</code>を開いて、結果を確認してみましょう。</p>
<h2 id="座標変換"><span class="header-section-number">9.6</span> 座標変換</h2>
<p>キャンバスは簡単な図形を描画するだけのものではありません。キャンバスは変換行列を扱うことができ、図形は描画の前に形状を変形してから描画されます。図形は平行移動、回転、拡大縮小、および斜め変形することができます。</p>
<p><code>purescript-canvas</code>ライブラリではこれらの変換を以下の関数で提供しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">translate ::</span> forall eff<span class="fu">.</span> <span class="dt">TranslateTransform</span> <span class="ot">-&gt;</span> <span class="dt">Context2D</span>
                                            <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">canvas ::</span> <span class="dt">Canvas</span> <span class="fu">|</span> eff) <span class="dt">Context2D</span>
<span class="ot">rotate    ::</span> forall eff<span class="fu">.</span> <span class="dt">Number</span>             <span class="ot">-&gt;</span> <span class="dt">Context2D</span>
                                            <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">canvas ::</span> <span class="dt">Canvas</span> <span class="fu">|</span> eff) <span class="dt">Context2D</span>
<span class="ot">scale     ::</span> forall eff<span class="fu">.</span> <span class="dt">ScaleTransform</span>     <span class="ot">-&gt;</span> <span class="dt">Context2D</span>
                                            <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">canvas ::</span> <span class="dt">Canvas</span> <span class="fu">|</span> eff) <span class="dt">Context2D</span>
<span class="ot">transform ::</span> forall eff<span class="fu">.</span> <span class="dt">Transform</span>          <span class="ot">-&gt;</span> <span class="dt">Context2D</span>
                                            <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">canvas ::</span> <span class="dt">Canvas</span> <span class="fu">|</span> eff) <span class="dt">Context2D</span></code></pre>
<p><code>translate</code>アクションは<code>TranslateTransform</code>レコードのプロパティで指定した大きさだけ平行移動を行います。</p>
<p><code>rotate</code>アクションは最初の引数で指定されたラジアンの値に応じて原点を中心とした回転を行います。</p>
<p><code>scale</code>アクションは原点を中心として拡大縮小します。<code>ScaleTransform</code>レコードは<code>X</code>軸と<code>y</code>軸に沿った拡大率を指定するのに使います。</p>
<p>最後の<code>transform</code>はこの４つのうちで最も一般的なアクションです。このアクションは行列に従ってアフィン変換を行います。</p>
<p>これらのアクションが呼び出された後に描画される図形は、自動的に適切な座標変換が適用されます。</p>
<p>実際には、これらの関数のそれぞれの作用は、コンテキストの現在の変換行列に対して変換行列を<strong>右から乗算</strong>していきます。つまり、もしある作用の変換をしていくと、その作用は実際には逆順に適用されていきます。次のような座標変換のアクションを考えてみましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">transformations ctx <span class="fu">=</span> <span class="kw">do</span>
  translate { translateX<span class="fu">:</span> <span class="dv">10</span>, translateY } ctx
  scale { scaleX<span class="fu">:</span> <span class="dv">2</span>, scaleY<span class="fu">:</span> <span class="dv">2</span> } ctx
  rotate (Math.pi <span class="fu">/</span> <span class="dv">2</span>) ctx
  
  renderScene</code></pre>
<p>このアクションの作用では、まずシーンが回転され、それから拡大縮小され、最後に平行移動されます。　　　　　</p>
<h2 id="コンテキストの保存"><span class="header-section-number">9.7</span> コンテキストの保存</h2>
<p>一般的な使い方としては、変換を適用してシーンの一部をレンダリングし、それからその変換を元に戻します。</p>
<p>Canvas APIにはキャンバスの状態の<strong>スタック</strong>を操作する<code>save</code>と<code>restore</code>メソッドが備わっています。<code>purescript-canvas</code>ではこの機能を次のような関数でラップしています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">save    ::</span> forall eff<span class="fu">.</span> <span class="dt">Context2D</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">canvas ::</span> <span class="dt">Canvas</span> <span class="fu">|</span> eff) <span class="dt">Context2D</span>
<span class="ot">restore ::</span> forall eff<span class="fu">.</span> <span class="dt">Context2D</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">canvas ::</span> <span class="dt">Canvas</span> <span class="fu">|</span> eff) <span class="dt">Context2D</span></code></pre>
<p><code>save</code>アクションは現在のコンテキストの状態(現在の変換行列や描画スタイル)をスタックにプッシュし、<code>restore</code>アクションはスタックの一番上の状態をポップし、コンテキストの状態を復元します。</p>
<p>これらのアクションにより、現在の状態を保存し、いろいろなスタイルや変換を適用し、プリミティブを描画し、最後に元の変換と状態を復元することが可能になります。例えば、次の関数はいくつかのキャンバスアクションを実行しますが、その前に回転を適用し、そのあとに変換を復元します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">rotated ctx render <span class="fu">=</span> <span class="kw">do</span>
  save ctx
  rotate Math.pi ctx
  render
  restore ctx</code></pre>
<p>こういったよくある使いかたの高階関数を利用した抽象化として、<code>purescript-canvas</code>ライブラリでは元のコンテキスト状態を維持しながらいくつかのキャンバスアクションを実行する<code>withContext</code>関数が提供されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">withContext ::</span> forall eff a<span class="fu">.</span> <span class="dt">Context2D</span> <span class="ot">-&gt;</span> 
                             <span class="dt">Eff</span> (<span class="ot">canvas ::</span> <span class="dt">Canvas</span> <span class="fu">|</span> eff) a <span class="ot">-&gt;</span>
                             <span class="dt">Eff</span> (<span class="ot">canvas ::</span> <span class="dt">Canvas</span> <span class="fu">|</span> eff) a          </code></pre>
<p><code>withContext</code>を使うと、先ほどの<code>rotated</code>関数を次のように書き換えることができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">rotated ctx render <span class="fu">=</span> withContext ctx <span class="fu">$</span> <span class="kw">do</span>
  rotate Math.pi ctx
  render</code></pre>
<h2 id="大域的な変更可能状態"><span class="header-section-number">9.8</span> 大域的な変更可能状態</h2>
<p>この節では<code>purescript-refs</code>パッケージを使って<code>Eff</code>モナドの別の作用について実演してみます。</p>
<p><code>Control.Monad.Eff.Ref</code>モジュールでは大域的に変更可能な参照のための型構築子、および関連する作用を提供します。</p>
<pre class="text"><code>&gt; :i Control.Monad.Eff.Ref

&gt; :k RefVal
* -&gt; *

&gt; :k Ref
!</code></pre>
<p>型<code>RefVal a</code>の値は型<code>a</code>値を保持する変更可能な領域への参照で、前の章で見た<code>STRef h a</code>によく似ています。その違いは、<code>ST</code>作用は<code>runST</code>を用いて除去することができますが、<code>Ref</code>作用はハンドラを提供しないということです。<code>ST</code>は安全に局所的な状態変更を追跡するために使用されますが、<code>Ref</code>は大域的な状態変更を追跡するために使用されます。そのため、<code>Ref</code>は慎重に使用する必要があります。</p>
<p><code>Refs.purs</code>ファイルには<code>canvas</code>要素上のマウスクリックを追跡するのに <code>Ref</code>作用を使用する例が含まれています。</p>
<p>このコー​​ドでは最初に<code>newRef</code>アクションを使って値<code>0</code>で初期化された領域への新しい参照を作成しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  clickCount <span class="ot">&lt;-</span> newRef <span class="dv">0</span></code></pre>
<p>クリックイベントハンドラの内部では、<code>modifyRef</code>アクションを使用してクリック数を更新しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    modifyRef clickCount (\count <span class="ot">-&gt;</span> count <span class="fu">+</span> <span class="dv">1</span>)</code></pre>
<p><code>readRef</code>アクションは新しいクリック数を読み取るために使われています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    count <span class="ot">&lt;-</span> readRef clickCount</code></pre>
<p><code>render</code>関数では、クリック数に応じて変換を矩形に適用しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    withContext ctx <span class="fu">$</span> <span class="kw">do</span>
      <span class="kw">let</span> scaleX <span class="fu">=</span> Math.sin (count <span class="fu">*</span> Math.pi <span class="fu">/</span> <span class="dv">4</span>) <span class="fu">+</span> <span class="fl">1.5</span>
      <span class="kw">let</span> scaleY <span class="fu">=</span> Math.sin (count <span class="fu">*</span> Math.pi <span class="fu">/</span> <span class="dv">6</span>) <span class="fu">+</span> <span class="fl">1.5</span>
      
      translate { translateX<span class="fu">:</span>  <span class="dv">300</span>, translateY<span class="fu">:</span>  <span class="dv">300</span> } ctx
      rotate (count <span class="fu">*</span> Math.pi <span class="fu">/</span> <span class="dv">18</span>) ctx
      scale { scaleX<span class="fu">:</span> scaleX, scaleY<span class="fu">:</span> scaleY } ctx
      translate { translateX<span class="fu">:</span> <span class="fu">-</span><span class="dv">100</span>, translateY<span class="fu">:</span> <span class="fu">-</span><span class="dv">100</span> } ctx

      fillPath ctx <span class="fu">$</span> rect ctx
        { x<span class="fu">:</span> <span class="dv">0</span>
        , y<span class="fu">:</span> <span class="dv">0</span>
        , w<span class="fu">:</span> <span class="dv">200</span>
        , h<span class="fu">:</span> <span class="dv">200</span>
        }</code></pre>
<p>このアクションでは元の変換を維持するために<code>withContext</code>を使用しており、それから続く変換を順に適用しています(変換が下から上に適用されることを思い出してください)。</p>
<ul>
<li>中心が原点に来るように、矩形を<code>(-100, -100)</code>平行移動します。</li>
<li>矩形を原点を中心に拡大縮小します。</li>
<li>矩形を原点を中心に<code>10</code>度の倍数だけ回転します。</li>
<li>中心がキャンバスの中心に位置するように長方形を<code>(300、300)</code>だけ平行移動します。</li>
</ul>
<p>このコード例をビルドしてみましょう。</p>
<pre class="text"><code>$ grunt refs</code></pre>
<p><code>html/index.html</code>ファイルを開いてみましょう。何度かキャンバスをクリックすると、キャンバスの中心の周りを回転する緑の四角形が表示されるはずです。</p>
<blockquote>
<h2 id="演習-24" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単) パスの線描と塗りつぶしを同時に行う高階関数を書いてください。その関数を使用して <code>Random.purs</code>例を書きなおしてください。</p></li>
<li><p>(やや難しい) <code>Random</code>作用と<code>DOM</code>作用を使用して、マウスがクリックされたときにキャンバスに無作為な位置、色、半径の円を描画するアプリケーションを作成してください。</p></li>
<li><p>(やや難しい) シーンを指定された座標を中心に回転する関数を書いてください。<strong>ヒント</strong>：最初にシーンを 原点まで平行移動しましょう。</p></li>
</ol>
</blockquote>
<h2 id="l-systems"><span class="header-section-number">9.9</span> L-Systems</h2>
<p>この章の最後の例として、<code>purescript-canvas</code>パッケージを使用して<strong>L-systems</strong>(Lindenmayer systems)を描画する関数を記述します。</p>
<p>L-Systemsは<strong>アルファベット</strong>、つまり初期状態となるアルファベットの文字列と、<strong>生成規則</strong>の集合で定義されています。各生成規則は、アルファベットの文字をとり、それを置き換える文字の配列を返します。この処理は文字の初期配列から始まり、複数回繰り返されます。</p>
<p>もしアルファベットの各文字がキャンバス上で実行される命令と対応付けられていれば、その指示に順番に従うことでL-Systemsを描画することができます。</p>
<p>たとえば、アルファベットが文字 <code>L</code> (左回転)、 <code>R</code>(右回転)、<code>F</code>(前進)で構成されていたとします。また、次のような生成規則を定義します。</p>
<pre class="text"><code>L -&gt; L
R -&gt; R
F -&gt; FLFRRFLF</code></pre>
<p>配列 &quot;FRRFRRFRR&quot; から始めて処理を繰り返すと、次のような経過を辿ります。</p>
<pre class="text"><code>FRRFRRFRR
FLFRRFLFRRFLFRRFLFRRFLFRRFLFRR
FLFRRFLFLFLFRRFLFRRFLFRRFLFLFLFRRFLFRRFLFRRFLF...</code></pre>
<p>この命令群に対応する線分パスをプロットすると、<strong>コッホ曲線</strong>と呼ばれる曲線に近似します。反復回数を増やすと、曲線の解像度が増加していきます。</p>
<p>それでは型と関数の言語へとこれを翻訳してみましょう。</p>
<p>アルファベットの選択肢は型の選択肢によって表すことができます。今回の例では、以下のような型で定義することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Alphabet</span> <span class="fu">=</span> <span class="dt">L</span> <span class="fu">|</span> <span class="dt">R</span> <span class="fu">|</span> <span class="dt">F</span></code></pre>
<p>このデータ型では、アルファベットの各文字ごとに１つずつデータ構築子が定義が定義されています。</p>
<p>文字の初期配列はどのように表したらいいでしょうか。単なるアルファベットの配列でいいでしょう。これを<code>Sentence</code>と呼ぶことにします。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Sentence</span> <span class="fu">=</span> [<span class="dt">Alphabet</span>]

<span class="ot">initial ::</span> <span class="dt">Sentence</span>
initial <span class="fu">=</span> [<span class="dt">F</span>, <span class="dt">R</span>, <span class="dt">R</span>, <span class="dt">F</span>, <span class="dt">R</span>, <span class="dt">R</span>, <span class="dt">F</span>, <span class="dt">R</span>, <span class="dt">R</span>]</code></pre>
<p>生成規則は<code>Alphabet</code>から<code>Sentence</code>への関数として表すことができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">productions ::</span> <span class="dt">Alphabet</span> <span class="ot">-&gt;</span> <span class="dt">Sentence</span>
productions <span class="dt">L</span> <span class="fu">=</span> [<span class="dt">L</span>]
productions <span class="dt">R</span> <span class="fu">=</span> [<span class="dt">R</span>]
productions <span class="dt">F</span> <span class="fu">=</span> [<span class="dt">F</span>, <span class="dt">L</span>, <span class="dt">F</span>, <span class="dt">R</span>, <span class="dt">R</span>, <span class="dt">F</span>, <span class="dt">L</span>, <span class="dt">F</span>]</code></pre>
<p>これはまさに上記の仕様をそのまま書き写したものです。</p>
<p>これで、この形式の仕様を受け取りキャンバスに描画する関数<code>lsystem</code>を実装することができます。<code>lsystem</code>はどのような型を持っているべきでしょうか。この関数は初期状態<code>initial</code>と生成規則<code>productions</code>のような値だけでなく、アルファベットの文字をキャンバスに描画する関数を引数に取る必要があります。</p>
<p><code>lsystem</code>の型の最初の大まかな設計としては、次のようになるかもしれません。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">forall eff<span class="fu">.</span> <span class="dt">Sentence</span> <span class="ot">-&gt;</span>
            (<span class="dt">Alphabet</span> <span class="ot">-&gt;</span> <span class="dt">Sentence</span>) <span class="ot">-&gt;</span>
            (<span class="dt">Alphabet</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">canvas ::</span> <span class="dt">Canvas</span> <span class="fu">|</span> eff) <span class="dt">Unit</span>) <span class="ot">-&gt;</span>
            <span class="dt">Number</span> <span class="ot">-&gt;</span>
            <span class="dt">Eff</span> (<span class="ot">canvas ::</span> <span class="dt">Canvas</span> <span class="fu">|</span> eff) <span class="dt">Unit</span></code></pre>
<p>最初の2つの引数の型は、値<code>initial</code>と<code>productions</code>に対応しています。</p>
<p>3番目の引数は、アルファベットの文字を取り、キャンバス上のいくつかのアクションを実行することによって<strong>翻訳</strong>する関数を表します。この例では、文字 <code>L</code>は左回転、文字 <code>R</code>で右回転、文字<code>F</code>は前進を意味します。</p>
<p>最後の引数は、実行したい生成規則の繰り返し回数を表す数です。</p>
<p>最初に気づくことは、現在の<code>lsystem</code>関数は<code>Alphabet</code>型だけで機能しますが、どんなアルファベットについても機能すべきですから、この型はもっと一般化されるべきです。それでは、量子化された型変数<code>a</code>について、<code>Alphabet</code>と<code>Sentence</code>を<code>a</code>で置き換えましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">forall a eff<span class="fu">.</span> [a] <span class="ot">-&gt;</span>
              (a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span>
              (a <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">canvas ::</span> <span class="dt">Canvas</span> <span class="fu">|</span> eff) <span class="dt">Unit</span>) <span class="ot">-&gt;</span>
              <span class="dt">Number</span> <span class="ot">-&gt;</span>
              <span class="dt">Eff</span> (<span class="ot">canvas ::</span> <span class="dt">Canvas</span> <span class="fu">|</span> eff) <span class="dt">Unit</span></code></pre>
<p>次に気付くこととしては、「左回転」と「右回転」のような命令を実装するためには、いくつかの状態を管理する必要があります。具体的に言えば、その時点でパスが向いている方向を状態として持たなければなりません。計算を通じて状態を関数に渡すように変更する必要があります。ここでも<code>lsystem</code>関数は状態がどんな型でも動作しなければなりませんから、型変数<code>s</code>を使用してそれを表しています。</p>
<p>型<code>s</code>を追加する必要があるのは3箇所で、次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">forall a s eff<span class="fu">.</span> [a] <span class="ot">-&gt;</span>
                (a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span>
                (s <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">canvas ::</span> <span class="dt">Canvas</span> <span class="fu">|</span> eff) s) <span class="ot">-&gt;</span>
                <span class="dt">Number</span> <span class="ot">-&gt;</span>
                s <span class="ot">-&gt;</span> 
                <span class="dt">Eff</span> (<span class="ot">canvas ::</span> <span class="dt">Canvas</span> <span class="fu">|</span> eff) s</code></pre>
<p>まず追加の引数の型として<code>lsystem</code>に型<code>s</code>が追加されています。この引数はL-Systemの初期状態を表しています。</p>
<p>型<code>s</code>は引数にも現れますが、翻訳関数(<code>lsystem</code>の第3引数)の返り値の型としても現れます。翻訳関数は今のところ、引数としてL-Systemの現在の状態を受け取り、返り値として更新された新しい状態を返します。</p>
<p>この例の場合では、次のような型を使って状態を表す型を定義することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">State</span> <span class="fu">=</span>
  {<span class="ot"> x ::</span> <span class="dt">Number</span>
  ,<span class="ot"> y ::</span> <span class="dt">Number</span>
  ,<span class="ot"> theta ::</span> <span class="dt">Number</span>
  }</code></pre>
<p>プロパティ<code>x</code>と<code>y</code>はパスの現在の位置を表しており、プロパティ<code>theta</code>は現在の向きを表しており、ラジアンで表された水平線に対するパスの角度です。</p>
<p>システムの初期状態としては次のようなものが考えられます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">initialState ::</span> <span class="dt">State</span>
initialState <span class="fu">=</span> { x<span class="fu">:</span> <span class="dv">120</span>, y<span class="fu">:</span> <span class="dv">200</span>, theta<span class="fu">:</span> <span class="dv">0</span> }</code></pre>
<p>それでは、<code>lsystem</code>関数を実装してみます。定義はとても単純であることがわかるでしょう。</p>
<p><code>lsystem</code>は第４引数の値(型<code>Number</code>)に応じて再帰するのが良さそうです。再帰の各ステップでは、生成規則に従って状態が更新され、現在の文が変化していきます。このことを念頭に置きつつ、まずは関数の引数の名前を導入して、補助関数に処理を移譲することから始めましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lsystem ::</span> forall a s eff<span class="fu">.</span> [a] <span class="ot">-&gt;</span>
                           (a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span>
                           (s <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">canvas ::</span> <span class="dt">Canvas</span> <span class="fu">|</span> eff) s) <span class="ot">-&gt;</span>
                           <span class="dt">Number</span> <span class="ot">-&gt;</span>
                           s <span class="ot">-&gt;</span> 
                           <span class="dt">Eff</span> (<span class="ot">canvas ::</span> <span class="dt">Canvas</span> <span class="fu">|</span> eff) s
lsystem init prod interpret n state <span class="fu">=</span> go init n
  <span class="kw">where</span></code></pre>
<p><code>go</code>関数は第2引数に応じて再帰することで動きます。<code>n</code>がゼロであるときと<code>n</code>がゼロでないときの2つの場合で分岐します。</p>
<p><code>n</code>がゼロの場合では再帰は完了し、解釈関数に応じて現在の文を解釈します。ここでは引数として与えられている型<code>[a]</code>の文、型<code>s</code>の状態、型<code>s -&gt; a -&gt; Eff (canvas :: Canvas | eff) s</code>の関数を参照することができます。これらの引数の型を考えると、以前定義した<code>foldM</code>の呼び出しにちょうど対応していることがわかります。<code>foldM</code>は<code>purescript-control</code>パッケージでも定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  go s <span class="dv">0</span> <span class="fu">=</span> foldM interpret state s</code></pre>
<p>ゼロでない場合ではどうでしょうか。その場合は、単に生成規則を現在の文のそれぞれの文字に適用して、その結果を連結し、そしてこの処理を再帰します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  go s n <span class="fu">=</span> go (concatMap prod s) (n <span class="fu">-</span> <span class="dv">1</span>)</code></pre>
<p>これだけです！<code>foldM</code>や<code>concatMap</code>のような高階関数を使うと、このようにアイデアを簡潔に表現することができるのです。</p>
<p>しかし、まだ完全に終わったわけではありません。ここで与えた型は、実際はまだ特殊化されすぎています。この定義ではキャンバスの操作が実装のどこにも使われていないことに注目してください。それに、まったく<code>Eff</code>モナドの構造を利用していません。実際には、この関数は<strong>どんな</strong>モナド<code>m</code>についても動作するのです！</p>
<p>この章に添付されたソースコードで定義されている、<code>lsystem</code>のもっと一般的な型は次のようになっています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lsystem ::</span> forall a m s<span class="fu">.</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span>
                         [a] <span class="ot">-&gt;</span>
                         (a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span>
                         (s <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m s) <span class="ot">-&gt;</span>
                         <span class="dt">Number</span> <span class="ot">-&gt;</span>
                         s <span class="ot">-&gt;</span> 
                         m s</code></pre>
<p>この型が言っているのは、この翻訳関数はモナド<code>m</code>で追跡される任意の副作用をまったく自由に持つことができる、ということだと理解することができます。キャンバスに描画したり、またはコンソールに情報を出力するかもしれませんし、失敗や複数の戻り値に対応しているかもしれません。こういった様々な型の副作用を使ったL-Systemを記述してみることを読者にお勧めします。</p>
<p>この関数は実装からデータを分離することの威力を示す良い例となっています。この手法の利点は、複数の異なる方法でデータを解釈する自由が得られることです。<code>lsystem</code>は２つの小さな関数へと分解することができるかもしれません。ひとつめは<code>concatMap</code>の適用の繰り返しを使って文を構築するもので、ふたつめは<code>foldM</code>を使って文を翻訳するものです。これは読者の演習として残しておきます。</p>
<p>それでは翻訳関数を実装して、この章の例を完成させましょう​​。<code>lsystem</code>の型は型シグネチャが言っているのは、翻訳関数の型は、何らかの型<code>a</code>と<code>s</code>、型構築子<code>m</code>について、 <code>s -&gt; a -&gt; m s</code> でなければならないということです。今回は<code>a</code>を<code>Alphabet</code>、 <code>s</code>を<code>State</code>、モナド<code>m</code>を<code>Eff (canvas :: Canvas)</code>というように選びたいということがわかっています。これにより次のような型になります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">interpret ::</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Alphabet</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">canvas ::</span> <span class="dt">Canvas</span>) <span class="dt">State</span></code></pre>
<p>この関数を実装するには、<code>Alphabet</code>型の3つのデータ構築子それぞれについて処理する必要があります。文字<code>L</code>(左回転)と<code>R</code>(右回転)の解釈では、<code>theta</code>を適切な角度へ変更するように状態を更新するだけです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">interpret state <span class="dt">L</span> <span class="fu">=</span> return <span class="fu">$</span> state { theta <span class="fu">=</span> state<span class="fu">.</span>theta <span class="fu">-</span> Math.pi <span class="fu">/</span> <span class="dv">3</span> }
interpret state <span class="dt">R</span> <span class="fu">=</span> return <span class="fu">$</span> state { theta <span class="fu">=</span> state<span class="fu">.</span>theta <span class="fu">+</span> Math.pi <span class="fu">/</span> <span class="dv">3</span> }</code></pre>
<p>文字<code>F</code>(前進)を解釈するには、パスの新しい位置を計算し、線分を描画し、状態を次のように更新します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">interpret state <span class="dt">F</span> <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> x&#39; <span class="fu">=</span> state<span class="fu">.</span>x <span class="fu">+</span> Math.cos state<span class="fu">.</span>theta <span class="fu">*</span> <span class="fl">1.5</span>
      y&#39; <span class="fu">=</span> state<span class="fu">.</span>y <span class="fu">+</span> Math.sin state<span class="fu">.</span>theta <span class="fu">*</span> <span class="fl">1.5</span>
  moveTo ctx state<span class="fu">.</span>x state<span class="fu">.</span>y
  lineTo ctx x&#39; y&#39;
  return { x<span class="fu">:</span> x&#39;, y<span class="fu">:</span> y&#39;, theta<span class="fu">:</span> state<span class="fu">.</span>theta }</code></pre>
<p>この章のソースコードでは、名前<code>ctx</code>を参照できるようにするために、<code>interpret</code>関数は<code>main</code>関数内で<code>let</code>束縛を使用して定義されていることに注意してください。<code>State</code>型がコンテキストを持つように変更することは可能でしょうが、それはこのシステムの状態の変化部分ではないので不適切でしょう。</p>
<p>このL-Systemsを描画するには、次のような<code>strokePath</code>アクションを使用するだけです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">strokePath ctx <span class="fu">$</span> lsystem initial productions interpret <span class="dv">5</span> initialState</code></pre>
<p><code>grunt lsystem</code>を使ってL-Systemをコンパイルし、<code>html/index.html</code>を開いてみましょう。キャンバスにコッホ曲線が描画されるのがわかると思います。</p>
<blockquote>
<h2 id="演習-25" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単) <code>strokePath</code>の代わりに<code>fillPath</code>を使用するように、上のL-Systemsの例を変更してください。<strong>ヒント</strong>：<code>closePath</code>の呼び出しを含め、<code>moveTo</code> の呼び出しを<code>interpret</code>関数の外側に移動する必要があります。</p></li>
<li><p>(簡単) 描画システムへの影響を理解するために、コード中の様々な数値の定数を変更してみてください。</p></li>
<li><p>(やや難しい) <code>lsystem</code>関数を2つの小さな関数に分割してください。ひとつめは<code>concatMap</code>の適用の繰り返しを使用して最終的な結果を構築するもので、ふたつめは<code>foldM</code>を使用して結果を解釈するものでなくてはなりません。</p></li>
<li><p>(やや難しい) <code>setShadowOffsetX</code>アクション、<code>setShadowOffsetY</code>アクション、<code>setShadowBlur</code>アクション、<code>setShadowColor</code>アクションを使い、塗りつぶされた図形にドロップシャドウを追加してください。<strong>ヒント</strong>：<code>psci</code>を使って、これらの関数の型を調べてみましょう。</p></li>
<li><p>(やや難しい) 向きを変えるときの角度の大きさは今のところ一定(<code>pi/3</code>)です。その代わりに、<code>Alphabet</code>データ型の中に角度の大きさを追加して、生成規則によって角度を変更できるようにしてください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Angle</span> <span class="fu">=</span> <span class="dt">Number</span>

<span class="kw">data</span> <span class="dt">Alphabet</span> <span class="fu">=</span> <span class="dt">L</span> <span class="dt">Angle</span> <span class="fu">|</span> <span class="dt">R</span> <span class="dt">Angle</span> <span class="fu">|</span> <span class="dt">F</span> <span class="dt">Angle</span></code></pre>
生成規則でこの新しい情報を使うと、どんな面白い図形を作ることができるでしょうか。 　</li>
<li><p>(難しい) <code>L</code>(60度左回転 )、<code>R</code>(60度右回転)、<code>F</code>(前進)、<code>M</code> (これも前進)という４つの文字からなるアルファベットでL-Systemが与えられたとします。</p>
<p>このシステムの文の初期状態は、単一の文字<code>M</code>です。</p>
<p>このシステムの生成規則は次のように指定されています。</p>
<pre class="text"><code>L -&gt; L
R -&gt; R
F -&gt; FLMLFRMRFRMRFLMLF
M -&gt; MRFRMLFLMLFLMRFRM</code></pre>
<p>このL-Systemを描画してください。<strong>注意</strong>：最後の文のサイズは反復回数に従って指数関数的に増大するので、生成規則の繰り返しの回数を削減することが必要になります。</p>
<p>ここで、生成規則における <code>L</code>と<code>M</code>の間の対称性に注目してください。ふたつの「前進」命令は、次のようなアルファベット型を使用すると、 <code>Boolean</code>値を使って区別することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Alphabet</span> <span class="fu">=</span> <span class="dt">L</span> <span class="fu">|</span> <span class="dt">R</span> <span class="fu">|</span> <span class="dt">F</span> <span class="dt">Boolean</span></code></pre>
<p>このアルファベットの表現を使用して、もう一度このL-Systemを実装してください。</p></li>
<li><p>(難しい) 翻訳関数で別のモナド<code>m</code>を使ってみましょう。<code>Trace</code>作用を利用してコンソール上にL-Systemを出力したり、<code>Random</code>作用を利用して状態の型に無作為の突然変異を適用したりしてみてください。</p></li>
</ol>
</blockquote>
<h2 id="まとめ-7"><span class="header-section-number">9.10</span> まとめ</h2>
<p>この章では、 <code>purescript-canvas</code>ライブラリを使用することにより、PureScriptからHTML5 Canvas APIを使う方法について学びました。マップや畳み込み、レコードと行多型、副作用を扱うための<code>Eff</code>モナドなど、これまで学んできた手法を利用した実用的な例について多く見ました。</p>
<p>この章の例では、高階関数の威力を示すとともに、<strong>実装からデータを分離</strong>も実演しました。これは例えば、代数データ型を使用すると、これらの概念を次のように拡張し、描画関数からシーンの表現を完全に分離できるようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Scene</span> <span class="fu">=</span> <span class="dt">Rect</span> <span class="dt">Rectangle</span>
           <span class="fu">|</span> <span class="dt">Arc</span> <span class="dt">Arc</span>
           <span class="fu">|</span> <span class="dt">PiecewiseLinear</span> [<span class="dt">Point</span>]
           <span class="fu">|</span> <span class="dt">Transformed</span> <span class="dt">Transform</span> <span class="dt">Scene</span>
           <span class="fu">|</span> <span class="dt">Clipped</span> <span class="dt">Rectangle</span> <span class="dt">Scene</span>
           <span class="fu">|</span> <span class="fu">...</span></code></pre>
<p>この手法は<code>purescript-drawing</code>パッケージでも採用されており、描画前にさまざまな方法でデータとしてシーンを操作することができるという柔軟性をもたらしています。</p>
<p>次の章では、PureScriptの<strong>外部関数インタフェース</strong>(foreign function interface)を使って、既存のJavaScriptの関数をラップした<code>purescript-canvas</code>のようなライブラリを実装する方法について説明します。</p>
<h1 id="外部関数インタフェース"><span class="header-section-number">10</span> 外部関数インタフェース</h1>
<h2 id="この章の目標-7"><span class="header-section-number">10.1</span> この章の目標</h2>
<p>この章では、PureScriptコードからJavaScriptコードへの呼び出し、およびその逆を可能にする、PureScriptの<strong>外部関数インタフェース</strong>(foreign function interface, FFI)を紹介します。これから扱うのは次のようなものです。</p>
<ul>
<li>PureScriptから純粋なJavaScript関数を呼び出す方法</li>
<li>既存のJavaScriptコードに基づいて、作用型と<code>Eff</code>モナドと一緒に使用する新しいアクションを作成する方法</li>
<li>JavaScriptからPureScriptコードを呼び出す方法</li>
<li>実行時のPureScriptの値の表現を知る方法</li>
<li><code>purescript-foreign</code>パッケージを使用して型付けされていないデータを操作する方法</li>
</ul>
<p>この章の終わりにかけて、再び住所録のコード例について検討します。この章の目的は、FFIを使ってアプリケーションに次のような新しい機能を追加することです。</p>
<ul>
<li>ポップアップ通知でユーザーに警告する</li>
<li>フォームのデータを直列化してブラウザのローカルストレージに保存し、アプリケーションが再起動したときにそれを再読み込みする</li>
</ul>
<h2 id="プロジェクトの準備-7"><span class="header-section-number">10.2</span> プロジェクトの準備</h2>
<p>このモジュールのソースコードは、第7章及び第8章の続きになります。今回もそれぞれのディレクトリから適切なソースファイルがGruntfileに含められています。</p>
<p>この章では<strong>型付けされていないデータ</strong>を操作するためのデータ型と関数を提供する<code>purescript-foreign</code>ライブラリというBower依存関係がひとつ新しく追加されます。</p>
<p>新しいNPM依存関係もあります。この章のGruntfileは、<code>grunt-contrib-connect</code>パッケージを使用してコンパイル後に静的ファイルサーバを実行するようになっています。これは、ウェブページがローカルファイルから配信されているときに起こる、ローカルストレージとブラウザ固有の問題を避けるためです。この章の例を実行するには、まず<code>grunt</code>を実行して、それからブラウザで <a href="http://localhost:8000/"><code>http://localhost:8000/</code></a> を開いてください。</p>
<h2 id="免責事項"><span class="header-section-number">10.3</span> 免責事項</h2>
<p>JavaScriptとの共同作業をできる限り簡単にするため、PureScriptは単純な多言語関数インタフェースを提供します。しかしながら、FFIはPureScriptの<strong>高度な</strong>機能であることには留意していただきたいと思います。FFIを安全かつ効率的に使用するには、扱うつもりであるデータの実行時の表現についてよく理解していなければなりません。この章では、PureScriptの標準ライブラリのコードに関連する、そのような理解を与えることを目指しています。</p>
<p>PureScriptのFFIはとても柔軟に設計されています。実際には、外部関数に最低限の型だけを与えるか、それとも型システムを利用して外部のコードの誤った使い方を防ぐようにするか、開発者が選ぶことができるということを意味しています。標準ライブラリのコードは、後者の手法を好む傾向にあります。簡単な例としては、JavaScriptの関数で戻り値が <code>null</code>をされないことを保証することはできません。実のところ、既存のJavaScriptコードはかなり頻繁に<code>null</code>を返します！しかし、PureScriptの型は通常null値を持っていません。そのため、FFIを使ってJavaScriptコードのインターフェイスを設計するときは、これらの特殊な場合を適切に処理するのは開発者の責任です。</p>
<h2 id="javascriptからpurescriptを呼び出す"><span class="header-section-number">10.4</span> JavaScriptからPureScriptを呼び出す</h2>
<p>少なくとも単純な型を持った関数については、JavaScriptからPureScript関数を呼び出すのはとても簡単です。</p>
<p>例として以下のような簡単なモジュールを見てみましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Test</span> <span class="kw">where</span>

gcd<span class="ot"> ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span>
gcd <span class="dv">0</span> m <span class="fu">=</span> m
gcd n <span class="dv">0</span> <span class="fu">=</span> n
gcd n m <span class="fu">|</span> n <span class="fu">&gt;</span> m <span class="fu">=</span> gcd (n <span class="fu">-</span> m) m
gcd n m <span class="fu">=</span> gcd (m <span class="fu">-</span> n) n</code></pre>
<p>この関数は、減算を繰り返すことによって2つの数の最大公約数を見つけます。関数を定義するのにPureScriptを使いたくなるかもしれない良い例となっていますが、JavaScriptからそれを呼び出すためには条件があります。 PureScriptでパターン照合と再帰を使用してこの関数を定義するのは簡単で、実装する開発者は型検証器の恩恵を受けることができます。</p>
<p>このモジュールを<code>psc</code>で次のようにコンパイルし、結果のJavaScriptをを<code>Node</code>にロードしてみましょう。</p>
<pre class="text"><code>$ psc Test.purs &gt; Test.js

$ node Test.js</code></pre>
<p>この関数をJavaScriptから呼び出す方法を理解するには、PureScriptの関数は常に引数がひとつのJavaScript関数へと変換され、引数へは次のようにひとつづつ適用していかなければならないことを理解するのが重要です。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">&gt; <span class="kw">var</span> test = <span class="ot">PS</span>.<span class="ot">Test</span>.<span class="fu">gcd</span>(<span class="dv">15</span>)(<span class="dv">20</span>);</code></pre>
<p><code>Test</code>モジュールはグローバルな<code>PS</code>オブジェクトのメンバ<code>Test</code>へとコンパイルされることに注意してください。これは<code>psc</code>コンパイラのデフォルトの動作ですが、グローバル名前空間は次のようにコマンドラインオプションを使用して変更することができます。</p>
<pre class="text"><code>$ psc Test.purs --browser-namespace=MyNamespace &gt; Test.js</code></pre>
<p><code>psc-make</code>を使用してCommonJSのモジュールにコードをコンパイルすると、コンパイルされたモジュールは、デフォルトでは<code>output</code>フォルダに配置されます。生成されたこれらのモジュールを<code>node_modules</code>ディレクトリにコピーすると、NodeJS(もしくはその他のCommonJS互換環境)の<code>require</code>関数を使用して、モジュールを参照することができるようになります。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> Test = <span class="fu">require</span>(<span class="st">&#39;Test&#39;</span>);</code></pre>
<p>このモジュールで定義された関数は、先ほどと同様に使うことができます。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="ot">Test</span>.<span class="fu">gcd</span>(<span class="dv">15</span>)(<span class="dv">20</span>);</code></pre>
<h2 id="名前の生成を理解する"><span class="header-section-number">10.5</span> 名前の生成を理解する</h2>
<p>PureScriptはコード生成時にできるだけ名前を保存することを目的としています。具体的には、トップレベルでの宣言では、JavaScriptのキーワードでなければ任意の識別子が保存されます。</p>
<p>識別子としてJavaScriptの予約語を使う場合は、名前はダブルダラー記号でエスケープされます。たとえば、次のPureScriptコードを考えてみます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">null <span class="fu">=</span> []</code></pre>
<p>これは以下のようなJavaScriptへコンパイルされます。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> $$null = [];</code></pre>
<p>また、識別子に特殊文字を使用したい場合は、単一のドル記号を使用してエスケープされます。たとえば、このPureScriptコードを考えます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">example&#39; <span class="fu">=</span> <span class="dv">100</span></code></pre>
<p>これは以下のJavaScriptにコンパイルされます。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> example$prime = <span class="dv">100</span>;</code></pre>
<p>この方式は、ユーザー定義の中置演算子の名前を生成するためにも使用されます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="fu">%</span>) a b <span class="fu">=</span> <span class="fu">...</span></code></pre>
<p>これは次のようにコンパイルされます。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> $percent = ...</code></pre>
<p>コンパイルされたPureScriptコードがJavaScriptから呼び出されることを意図している場合、識別子は英数字のみを使用し、JavaScriptの予約語を避けることをお勧めします。ユーザ定義演算子がPureScriptコードでの使用のために提供される場合でも、JavaScriptから使うための英数字の名前を持った代替関数を提供しておくことをお勧めします。</p>
<h2 id="実行時のデータ表現"><span class="header-section-number">10.6</span> 実行時のデータ表現</h2>
<p>型はプログラムはある意味で「正しい」ことをコンパイル時に判断できるようにします。つまり、実行時には中断されません。しかし、これは何を意味するのでしょうか？PureScriptでは式の型は実行時の表現と互換性がなければならないことを意味します。</p>
<p>そのため、PureScriptとJavaScriptコードを一緒に効率的に使用できるように、実行時のデータ表現について理解することが重要です。これは、与えられた任意のPureScriptの式について、その値が実行時にどのように評価されるかという挙動を理解できるべきであることを意味しています。</p>
<p>PureScriptの式は、実行時に特に単純な表現を持っているということは朗報です。実際に標準ライブラリのコードについて、その型を考慮すれば式の実行時のデータ表現を把握することが可能です。</p>
<p>単純な型については、対応関係はほとんど自明です。たとえば、式が型<code>Boolean</code>を持っていれば、実行時のその値<code>v</code>は<code>typeof v === 'boolean'</code>を満たします。つまり、型<code>Boolean</code>の式は<code>true</code>もしくは<code>false</code>のどちらか一方の(JavaScriptの)値へと評価されます。実のところ、<code>null</code>や<code>undefined</code>に評価される、型<code>Boolean</code>のPureScriptの式はありません。</p>
<p><code>Number</code>と<code>String</code>の型の式についても同様のことが成り立ちます。<code>Number</code>型の式は<code>null</code>でないJavaScriptの数へと評価されますし、<code>String</code>型の式は<code>null</code>でないJavaScriptの文字列へと評価されます。</p>
<p>もっと複雑な型についてはどうでしょうか？</p>
<p>すでに見てきたように、PureScriptの関数は引数がひとつのJavaScriptの関数に対応しています。厳密に言えば、任意の型<code>a</code>、<code>b</code>について、式<code>f</code>の型が<code>a -&gt; b</code>で、式<code>x</code>が型<code>a</code>についての適切な実行時表現の値へと評価されるなら、<code>f</code>はJavaScriptの関数へと評価され、<code>x</code>を評価した結果に<code>f</code>を適用すると、それは型<code>b</code>の適切な実行時表現を持ちます。簡単な例としては、<code>String -&gt; String</code>型の式は、<code>null</code>でないJavaScript文字列から<code>null</code>でないJavaScript文字列への関数へと評価されます。</p>
<p>ご想像のとおり、PureScriptの配列はJavaScriptの配列に対応しています。しかし、PureScriptの配列は均質であり、つまりすべての要素が同じ型を持っていることは覚えておいてください。具体的には、もしPureScriptの式<code>e</code>が任意の型<code>a</code>について型<code>[a]</code>を持っているなら、<code>e</code>はすべての要素が型<code>a</code>の適切な実行時表現を持った(<code>null</code>でない)JavaScript配列へと評価されます。</p>
<p>PureScriptのレコードがJavaScriptのオブジェクトへと評価されることはすでに見てきました。ちょうど関数と配列の場合のように、そのラベルに関連付けられている型を考慮すれば、レコードのフィールドのデータの実行時の表現についても推論することができます。もちろん、レコードのそれぞれのフィールドは、同じ型である必要はありません。</p>
<h2 id="代数的データ型の実行時表現"><span class="header-section-number">10.7</span> 代数的データ型の実行時表現</h2>
<p>PureScriptコンパイラは、代数的データ型のすべての構築子についてそれぞれ関数を定義し、新たなJavaScriptオブジェクト型を作成します。これらの構築子はこれらのプロトタイプに基づいて新しいJavaScriptオブジェクトを作成する関数に対応しています。</p>
<p>たとえば、次のような単純な代数的データ型を考えてみましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ZeroOrOne</span> a <span class="fu">=</span> <span class="dt">Zero</span> <span class="fu">|</span> <span class="dt">One</span> a</code></pre>
<p>PureScriptコンパイラは、次のようなコードを生成します。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">One</span>(value0) {
    <span class="kw">this</span>.<span class="fu">value0</span> = value0;
};

<span class="ot">One</span>.<span class="fu">create</span> = <span class="kw">function</span> (value0) {
    <span class="kw">return</span> <span class="kw">new</span> <span class="fu">One</span>(value0);
};

<span class="kw">function</span> <span class="fu">Zero</span>() {
};

<span class="ot">Zero</span>.<span class="fu">value</span> = <span class="kw">new</span> <span class="fu">Zero</span>();</code></pre>
<p>ここで2つのJavaScriptオブジェクト型<code>Zero</code>と<code>One</code>を見てください。JavaScriptの予約語<code>new</code>を使用すると、それぞれの型の値を作成することができます。引数を持つ構築子については、コンパイラは<code>value0</code>、<code>value1</code>などと呼ばれるフィールドに対応するデータを格納します。</p>
<p>PureScriptコンパイラは補助関数も生成します。引数のない構築子については、コンパイラは構築子が使われるたびに<code>new</code>演算子を使うのではなく、データを再利用できるように<code>value</code>プロパティを生成します。ひとつ以上の引数を持つ構築子では、適切な表現を持つ引数を取り適切な構築子を適用する<code>create</code>関数をコンパイラは生成します。</p>
<p>２引数以上の構築子についてはどうでしょうか？その場合でも、PureScriptコンパイラは新しいオブジェクト型と補助関数を作成します。しかし今回は、補助関数は2引数のカリー化された関数です。たとえば、次のような代数的データ型を考えます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Two</span> a b <span class="fu">=</span> <span class="dt">Two</span> a b</code></pre>
<p>このコードからは、次のようなJavaScriptコードを生成されます。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">Two</span>(value0, value1) {
    <span class="kw">this</span>.<span class="fu">value0</span> = value0;
    <span class="kw">this</span>.<span class="fu">value1</span> = value1;
};

<span class="ot">Two</span>.<span class="fu">create</span> = <span class="kw">function</span> (value0) {
    <span class="kw">return</span> <span class="kw">function</span> (value1) {
        <span class="kw">return</span> <span class="kw">new</span> <span class="fu">Two</span>(value0, value1);
    };
};</code></pre>
<p>ここで、オブジェクト型<code>Two</code>の値は予約語<code>new</code>または<code>Two.create</code>関数を使用すると作成することができます。</p>
<p>newtypeの場合はまた少し異なります。newtypeは単一の引数を取る単一の構築子を持つよう制限された代数的データ型であることを思い出してください。この場合には、実際はnewtypeの実行時表現は、その引数の型と同じになります。</p>
<p>例えば、電話番号を表す次のようなnewtypeを考えます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">PhoneNumber</span> <span class="fu">=</span> <span class="dt">PhoneNumber</span> <span class="dt">String</span></code></pre>
<p>これは実行時にはJavaScriptの文字列として表されます。newtypeは型安全性の追加の層を提供しますが、実行時の関数呼び出しのオーバーヘッドがないので、ライブラリを設計するのに役に立ちます。</p>
<h2 id="量化された型の実行時表現"><span class="header-section-number">10.8</span> 量化された型の実行時表現</h2>
<p>量化された型(多相型)の式は、制限された表現を実行時に持っています。実際には、量化された型の式が比較的少数与えられたとき、とても効率的に解決できることを意味しています。</p>
<p>例えば、次の多相型を考えてみます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> a</code></pre>
<p>この型を持っている関数にはどんなものがあるでしょうか。少なくともひとつはこの型を持つ関数が存在しています。すなわち、<code>Prelude</code>で定義されている恒等関数<code>id</code>です。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">id<span class="ot"> ::</span> forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> a
id a <span class="fu">=</span> a</code></pre>
<p>実のところ、<code>id</code>の関数はこの型の<strong>唯一の</strong>(全)関数です！これは間違いなさそうに見えます(この型を持った<code>id</code>とは明らかに異なる式を書こうとしてみてください)が、しかし、これを確かめるにはどうしたらいいでしょうか。これは型の実行時表現を考えることによって確認することができます。</p>
<p>量化された型<code>forall a. t</code>の実行時表現はどうなっているのでしょうか。さて、この型の実行時表現を持つ任意の式は、型<code>a</code>をどのように選んでも型<code>t</code>の適切な実行時表現を持っていなければなりません。上の例では、型<code>forall a. a -&gt; a</code>の関数は、<code>String -&gt; String</code>、 <code>Number -&gt; Number</code>、, <code>[Boolean] -&gt; [Boolean]</code>などといった型について、適切な実行時表現を持っていなければなりません。 これらは、数から数、文字列から文字列の関数でなくてはなりません。</p>
<p>しかし、それだけでは十分ではありません。量化された型の実行時表現は、これよりも更に厳しくなります。任意の式がパラメトリック多相的でなければなりません。つまり、その実装において、引数の型についてのどんな情報も使うことができないのです。この追加の条件は、考えられる多相型のうち、次のようなJavaScriptの関数として問題のある実装を禁止します。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">invalid</span>(a) {
    <span class="kw">if</span> (<span class="kw">typeof</span> a === <span class="st">&#39;string&#39;</span>) {
        <span class="kw">return</span> <span class="st">&quot;Argument was a string.&quot;</span>;
    } <span class="kw">else</span> {
        <span class="kw">return</span> a;
    }
}</code></pre>
<p>確かにこの関数は文字列から文字列、数から数へというような関数ではありますが、追加の条件を満たしていません。引数の実行時の型を調べているからです。したがって、この関数は型<code>forall a. a -&gt; a</code>の正しい実装だとはいえないのです。</p>
<p>関数の引数の実行時の型を検査することができなければ、唯一の選択肢は引数をそのまま返すことだけであり、したがって <code>id</code>は、<code>forall a. a -&gt; a</code>のまったく唯一の実装なのです。</p>
<p><strong>パラメトリック多相</strong>(parametric polymorphism)と<strong>パラメトリック性</strong>(parametricity)についての詳しい議論は本書の範囲を超えています。しかしながら、PureScriptの型は、実行時に<strong>消去</strong>されているので、PureScriptの多相関数は(FFIを使わない限り)引数の実行時表現を検査することが<strong>できない</strong>し、この多相的なデータの表現は適切であることに注意してください。</p>
<h2 id="制約された型の実行時表現"><span class="header-section-number">10.9</span> 制約された型の実行時表現</h2>
<p>型クラス制約を持つ関数は、実行時に面白い表現を持っています。関数の振る舞いはコンパイラによって選ばれた型クラスのインスタンスに依存する可能性があるため、関数には選択したインスタンスから提供された型クラスの関数の実装が含まれてた<strong>型クラス辞書</strong>(type class dictionary)と呼ばれる追加の引数が与えられています。</p>
<p>例えば、<code>Show</code>型クラスを使用している制約された型を持つ、次のような単純なPureScript関数について考えます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">shout ::</span> forall a<span class="fu">.</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>
shout a <span class="fu">=</span> show a <span class="fu">++</span> <span class="st">&quot;!!!&quot;</span> </code></pre>
<p>このコードから生成されるJavaScriptは次のようになります。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> shout = <span class="kw">function</span> (dict) {
    <span class="kw">return</span> <span class="kw">function</span> (a) {
        <span class="kw">return</span> <span class="fu">show</span>(dict)(a) + <span class="st">&quot;!!!&quot;</span>;
    };
};</code></pre>
<p><code>shout</code>は１引数ではなく、２引数の(カリー化された)関数にコンパイルされていることに注意してください。最初の引数<code>dict</code>は<code>Show</code>制約の型クラス辞書です。<code>dict</code>には型<code>a</code>の<code>show</code>関数の実装が含まれています。</p>
<p>最初の引数として明示的にPreludeの型クラス辞書を渡すと、JavaScriptからこの関数を呼び出すことができます。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="fu">shout</span>(<span class="ot">Prelude</span>.<span class="fu">showNumber</span>())(<span class="dv">42</span>);</code></pre>
<blockquote>
<h2 id="演習-26" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単) これらの型の実行時の表現は何でしょうか。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">forall a<span class="fu">.</span> a
forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
forall a<span class="fu">.</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Boolean</span></code></pre>
<p>これらの型を持つ式についてわかることはなんでしょうか。</p></li>
<li><p>(やや難しい) <code>psc-make</code>を使ってコンパイルし、NodeJSの<code>require</code>関数を使ってモジュールをインポートすることで、JavaScriptから<code>purescript-arrays</code>ライブラリの関数を使ってみてください。</p></li>
</ol>
</blockquote>
<h2 id="purescriptからのjavascriptコードを使う"><span class="header-section-number">10.10</span> PureScriptからのJavaScriptコードを使う</h2>
<p>PureScriptからJavaScriptコードを使用する最も簡単な方法は、<strong>foreign import</strong>宣言を使用し、既存のJavaScriptの値に型を与えることです。</p>
<p>たとえば、特殊文字をエスケープすることによりURIのコンポーネントを符号化するJavaScriptの<code>encodeURIComponent</code>関数について考えてみます。</p>
<pre class="text"><code>$ node

node&gt; encodeURIComponent(&#39;Hello World&#39;)
&#39;Hello%20World&#39;</code></pre>
<p><code>null</code>でない文字列から<code>null</code>でない文字列への関数であり、副作用を持っていないので、この関数はその型<code>String -&gt; String</code>について適切な実行時表現を持っています。</p>
<p>次のような外部インポート宣言を使うと、この関数に型を割り当てることができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>encodeURIComponent :: <span class="dt">String</span> -&gt; <span class="dt">String</span></code></pre>
<p>また、PureScriptで記述された関数のように、この関数をPureScriptから使ってみます。たとえば、この宣言をモジュールとして保存して<code>psci</code>にロードすると、先ほどの計算を再現することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> encodeURIComponent <span class="st">&quot;Hello World&quot;</span>
<span class="st">&quot;Hello%20World&quot;</span></code></pre>
<p>このアプローチは、簡単なJav​​aScriptの値には適していますが、もっと複雑な値に使うには限界があります。ほとんどの既存のJavaScriptコードは、基本的なPureScriptの型の実行時表現によって課せられた厳しい条件を満たしていないからです。このような場合のためには、適切な実行時表現に従うことを強制するようにJavaScriptコードを<strong>ラップする</strong>という別の方法があります。</p>
<h2 id="javascriptの値のラッピング"><span class="header-section-number">10.11</span> JavaScriptの値のラッピング</h2>
<p>外部インポート宣言は、型注釈の直前に文字列リテラルを含めることで、JavaScriptコードのブロックと対にすることができます。そのJavaScriptコードは、コンパイル時に生成されたコードに直接挿入されます。</p>
<p>これはPureScriptの型を与えるためにJavaScriptコードの既存の部分をラップする場合に特に便利です。このようにしたくなる理由はいくつかあります。</p>
<ul>
<li>任意のJavaScriptの副作用を追跡するために、<code>Eff</code>モナドを使うことができます。。</li>
<li>関数の適切な実行時表現を与えるために、<code>null</code>や<code>undefined</code>のような特殊な場合を処理するために必要な場合があります。</li>
</ul>
<p>外部インポート宣言を使用して、配列についての<code>head</code>関数を作成したいとしましょう。JavaScriptでは次のような関数になるでしょう。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">head</span>(arr) {
    <span class="kw">return</span> arr[<span class="dv">0</span>];
}</code></pre>
<p>しかし、この関数には問題があります。型<code>forall a. [a] -&gt; a</code>を与えようとしても、空の配列に対してこの関数は<code>undefined</code>を返します。したがって、この特殊な場合を処理するために、ラッパー関数を使用する必要があります。</p>
<p>簡単な方法としては、空の配列の場合に例外を投げる方法があります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>head
  <span class="st">&quot;function head(arr) {\</span>
<span class="st">  \  if (arr.length) {\</span>
<span class="st">  \    return arr[0];\</span>
<span class="st">  \  } else {\</span>
<span class="st">  \    throw new Error(&#39;Empty array!&#39;);\</span>
<span class="st">  \  }\</span>
<span class="st">  \}&quot;</span><span class="ot"> ::</span> forall a<span class="fu">.</span> [a] <span class="ot">-&gt;</span> a</code></pre>
<p>バックスラッシュを使用するとその行から次の1行まで継続することができ、JavaScriptの実装を複数行に分離できることに注意してください。</p>
<h2 id="外部型の定義"><span class="header-section-number">10.12</span> 外部型の定義</h2>
<p>失敗した場合に例外を投げるという方法は、あまり理想的とはいえません。PureScriptのコードでは、欠けた値のような副作用は型システムを使って扱うのが普通です。この手法としては<code>Maybe</code>型構築子を使う方法もありますが、この節ではFFIを使用した別の解決策を扱います。</p>
<p>実行時には型<code>a</code>のように表現されますが<code>undefined</code>の値も許容するような新しい型<code>Undefined a</code>を定義したいとしましょう。</p>
<p><strong>外部インポート宣言</strong>とFFIを使うと、<strong>外部型</strong>(foreign type)を定義することができます。構文は外部関数を定義するのと似ています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>data <span class="dt">Undefined</span> :: * -&gt; *</code></pre>
<p>この予約語<code>data</code>は値ではなく定義している型を表していることに注意してください。型シグネチャの代わりに、新しい型の<strong>種</strong>を与えます。このとき、種<code>Undefined</code>が<code>* -&gt; *</code>であると宣言しています。つまり<code>Undefined</code>は型構築子です。</p>
<p>これで<code>head</code>の定義を簡素化することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>head
  <span class="st">&quot;function head(arr) {\</span>
<span class="st">  \  return arr[0];\</span>
<span class="st">  \}&quot;</span><span class="ot"> ::</span> forall a<span class="fu">.</span> [a] <span class="ot">-&gt;</span> <span class="dt">Undefined</span> a</code></pre>
<p>2点変更がある注意してください。<code>head</code>関数の本体ははるかに簡単で、もしその値が未定義であったとしても<code>arr[0]</code>を返し、型シグネチャはこの関数が未定義の値を返すことがあるという事実を反映するよう変更されています。</p>
<p>この関数はその型の適切な実行時表現を持っていますが、型<code>Undefined a</code>の値を使用する方法がありませんので、まったく役に立ちません。しかし、FFIを使用して新しい関数を幾つか書くことによって、それを修正することができます！</p>
<p>次の関数は、値が定義されているかどうかを教えてくれる最も基本的な関数です。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>isUndefined
  <span class="st">&quot;function isUndefined(value) {\</span>
<span class="st">  \  return value === undefined;\</span>
<span class="st">  \}&quot;</span><span class="ot"> ::</span> forall a<span class="fu">.</span> <span class="dt">Undefined</span> a <span class="ot">-&gt;</span> <span class="dt">Boolean</span></code></pre>
<p>PureScriptから<code>isUndefined</code>と<code>head</code>を一緒に使用すると、便利な関数を定義することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isEmpty ::</span> forall a<span class="fu">.</span> [a] <span class="ot">-&gt;</span> <span class="dt">Boolean</span>
isEmpty <span class="fu">=</span> isUndefined <span class="fu">&lt;&lt;&lt;</span> head</code></pre>
<p>ここで、定義されたこの外部関数はとても簡単であり、PureScriptの型検査器を使うことによる利益をなるべく多く得るということを意味します。一般に外部関数は可能な限り小さく保ち、アプリケーションの処理はPureScriptコードへ移動しておくことをおすすめします。</p>
<h2 id="多変数関数"><span class="header-section-number">10.13</span> 多変数​関数</h2>
<p>PureScriptのPreludeには、興味深い外部型がいくつかも含まれています。すでに扱ってきたように、PureScriptの関数型は単一の引数だけを取りますが、<strong>カリー化</strong>を使うと複数の引数の関数をシミュレートすることができます。これには明らかな利点があります。関数を部分適用することができ、関数型の型クラスインスタンスを与えることができます。ただし、効率上のペナルティが生じます。パフォーマンス重視するコードでは、複数の引数を受け入れる本物のJavaScript関数を定義することが必要な場合があります。Preludeではそのような関数を安全に扱うことができるようにする外部型が定義されています。</p>
<p>たとえば、Preludeの<code>Data.Function</code>モジュールには次の外部型宣言があります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>data <span class="dt">Fn2</span> :: * -&gt; * -&gt; * -&gt; *</code></pre>
<p>これは3つの型引数を取る型構築子<code>Fn2</code>を定義します。<code>Fn2 a b c</code>は、型<code>a</code>と<code>b</code>の２つの引数、返り値の型<code>c</code>をもつJavaScript関数の型を表現しています。</p>
<p>Preludeでは0引数から10引数までの関数について同様の型構築子が定義されています。</p>
<p>次のように<code>mkFn2</code>関数を使うと、2引数の関数を作成することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Function</span>

<span class="ot">divides ::</span> <span class="dt">Fn2</span> <span class="dt">Number</span> <span class="dt">Number</span> <span class="dt">Boolean</span>
divides <span class="fu">=</span> mkFn2 <span class="fu">$</span> \n m <span class="ot">-&gt;</span> m <span class="fu">%</span> n <span class="fu">==</span> <span class="dv">0</span></code></pre>
<p>そして、 <code>runFn2</code>関数を使うと、2引数の関数を適用することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> runFn2 divides <span class="dv">2</span> <span class="dv">10</span>
true

<span class="fu">&gt;</span> runFn2 divides <span class="dv">3</span> <span class="dv">10</span>
false</code></pre>
<p>ここで重要なのは、引数がすべて適用されるなら、コンパイラは<code>mkFn2</code>関数や<code>runFn2</code>関数を<strong>インライン化</strong>するということです。そのため、生成されるコードはとてもコンパクトになります。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> divides = <span class="kw">function</span> (n, m) {
    <span class="kw">return</span> m % n === <span class="dv">0</span>;
};</code></pre>
<h2 id="均質なレコード"><span class="header-section-number">10.14</span> 均質なレコード</h2>
<p>外部型のさらなる例として、<strong>均質なレコード</strong>(homogeneous records)の型を定義してみましょう。これは、どんなラベルでも持つことができますが、どのプロパティも同じ型をもっているレコードです。</p>
<p>PureScriptではレコードの各プロパティは異なる型を持つことができます。これは多くの場合に便利ですが、JavaScriptコードにおけるいくつかの典型的なパターンに意味のある型を与えるのがうまくいかないときがあります。</p>
<p>均質なレコードの型はそのプロパティの(統一された)型によってパラメータ化されることになるので、これは次のような<code>* -&gt; *</code>という種を持つことになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>data <span class="dt">HRec</span> :: * -&gt; *</code></pre>
<p>外部値(foreign value)を使用すると、簡単に空の均質なレコードを定義することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>empty 
  <span class="st">&quot;var empty = {}&quot;</span><span class="ot"> ::</span> forall a<span class="fu">.</span> <span class="dt">HRec</span> a</code></pre>
<p><code>forall a. HRec a</code> という型は、この空の均質なレコードは任意の型<code>a</code>について型<code>a</code>のプロパティを持っているのを表していることに注意してください。<code>empty</code>はどのプロパティも持っていないので、これが正しいのはまったくの自明です！</p>
<p>また、均質なレコードに新しいフィールドを挿入する関数を定義することができます。PureScriptの値は不変なので、JavaScriptコードで既存のレコードをコピーする必要があります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>insert
  <span class="st">&quot;function insert(key, value, rec) {\</span>
<span class="st">  \  var copy = {};\</span>
<span class="st">  \  for (var k in rec) {\</span>
<span class="st">  \    if (rec.hasOwnProperty(k)) {\</span>
<span class="st">  \      copy[k] = rec[k];\</span>
<span class="st">  \    }\</span>
<span class="st">  \  }\</span>
<span class="st">  \  copy[key] = value;\</span>
<span class="st">  \  return copy;\</span>
<span class="st">  \}&quot;</span><span class="ot"> ::</span> forall a<span class="fu">.</span> <span class="dt">Fn3</span> <span class="dt">String</span> a (<span class="dt">HRec</span> a) (<span class="dt">HRec</span> a)</code></pre>
<p><code>insert</code>関数は3引数の関数を表現するために型コンストラクタ<code>Fn3</code>を使っています。JavaScriptで手作業でカリー化関数を書くことはとても面倒なので、<code>Fn3</code>を使うと便利です。この関数はレコードを複製し、複製へ新しいキーを追加します。</p>
<p>均質なレコードを使うと、通常のPureScriptレコードではできないような、いろいろな面白い操作を行うことができます。例えば、均質なレコードの値に対して関数をマッピングすることができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>mapHRec
  <span class="st">&quot;function mapHRec(f, rec) {\</span>
<span class="st">  \  var mapped = {};\</span>
<span class="st">  \  for (var k in rec) {\</span>
<span class="st">  \    if (rec.hasOwnProperty(k)) {\</span>
<span class="st">  \      mapped[k] = f(rec[k]);\</span>
<span class="st">  \    }\</span>
<span class="st">  \  }\</span>
<span class="st">  \  return mapped;\</span>
<span class="st">  \}&quot;</span><span class="ot"> ::</span> forall a b<span class="fu">.</span> <span class="dt">Fn2</span> (a <span class="ot">-&gt;</span> b) (<span class="dt">HRec</span> a) (<span class="dt">HRec</span> b)</code></pre>
<p>つまり、<code>HRec</code>は<code>Functor</code>なのです！</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> functorHRec ::</span> <span class="dt">Functor</span> <span class="dt">HRec</span> <span class="kw">where</span>
  (<span class="fu">&lt;$&gt;</span>) f rec <span class="fu">=</span> runFn2 mapHRec f rec</code></pre>
<p>また、<code>HRec</code>を<code>Foldable</code>型クラスのインスタンスにすることもでき、レコードの値に対して畳み込みをすることもできます。さらに興味深いことに、レコードのプロパティの値だけでなく<strong>ラベル</strong>も受け取る累積関数について畳み込みを実行することができます！</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>foldHRec
  <span class="st">&quot;function foldHRec(f, r, rec) {\</span>
<span class="st">  \  var acc = r;\</span>
<span class="st">  \  for (var k in rec) {\</span>
<span class="st">  \    if (rec.hasOwnProperty(k)) {\</span>
<span class="st">  \      acc = f(acc, k, rec[k]);\</span>
<span class="st">  \    }\</span>
<span class="st">  \  }\</span>
<span class="st">  \  return acc;\</span>
<span class="st">  \}&quot;</span><span class="ot"> ::</span> forall a r<span class="fu">.</span> <span class="dt">Fn3</span> (<span class="dt">Fn3</span> r <span class="dt">String</span> a r) r (<span class="dt">HRec</span> a) r</code></pre>
<p>この章のソースコードには、次の演習に対する解決策の基礎として使用することができる <code>HRec</code>モジュールの関数が含まれています。</p>
<blockquote>
<h2 id="演習-27" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単) <code>psci</code> でいくつかの簡単なレコードを構築し、 <code>runFn3</code>関数を使用して<code>insert</code>関数を試してみてください。</p></li>
<li><p>(やや難しい) 2つの均質なレコードの和集合を計算する関数 <code>union</code>を書いてください。2つのレコードがラベルを共有している場合、２つめのレコードが優先させなければいけません。</p></li>
<li><p>(やや難しい) 通常の(カリー化された)関数を使用する<code>foldHRec</code>ためのラッパー関数を書いてください。その関数は次のような型を持っていなければなりません。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">forall a r<span class="fu">.</span> (r <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> <span class="dt">HRec</span> a <span class="ot">-&gt;</span> r</code></pre>
<p>この関数を定義するのにFFIは使用しないでください。</p></li>
<li><p>(難しい) 均質なレコードのキーを検索する関数<code>lookup</code>を書いてください。その関数は次のような型を持っていなければなりません。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">forall a<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">HRec</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</code></pre>
<p>この関数の次の2種類の実装を書いてください。最初のバージョンは<code>foldHRec</code>関数を使用する必要があります。２つめのバージョンは、外部関数として定義しなければなりません。<strong>ヒント</strong>：次のような関数の定義を探してみると参考になるかもしれません。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lookupHelper ::</span> forall a r<span class="fu">.</span> <span class="dt">Fn4</span> r (a <span class="ot">-&gt;</span> r) <span class="dt">String</span> (<span class="dt">HRec</span> a) r</code></pre>
<p>第１引数及び第2引数は、それぞれ <code>Nothing</code>と<code>Just</code>関数に対応しています。</p></li>
<li><p>(難しい) マッピング関数が追加の引数としてプロパティのラベルを受け取る<code>mapHRec</code>関数書いてください。その関数を使用して<code>HRec</code>の<code>Show</code>インスタンスを簡素化してください。</p></li>
</ol>
</blockquote>
<h2 id="副作用の表現"><span class="header-section-number">10.15</span> 副作用の表現</h2>
<p><code>Eff</code>モナドもPreludeの外部型として定義されています。その実行時表現はとても簡単です。型<code>Eff eff a</code>の式は、任意の副作用を実行し型<code>a</code>の適切な実行時表現で値を返す、引数なしのJavaScript関数へと評価されます。</p>
<p><code>Eff</code>型の構築子の定義は、<code>Control.Monad.Eff</code>モジュールで次のように与えられています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>data <span class="dt">Eff</span> :: # ! -&gt; * -&gt; *</code></pre>
<p><code>Eff</code>型の構築子は作用の行と返り値の型によってパラメータ化されおり、それが種に反映されることを思い出してください。</p>
<p>簡単な例として、<code>purescript-random</code>パッケージで定義される<code>random</code>関数を考えてみてください。その型は次のようなものでした。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">random ::</span> forall eff<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">random ::</span> <span class="dt">Random</span>) <span class="dt">Number</span></code></pre>
<p><code>random</code>関数の定義は次のように与えられます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>random
  <span class="st">&quot;function random() {\</span>
<span class="st">  \  return Math.random();\</span>
<span class="st">  \}&quot;</span><span class="ot"> ::</span> forall eff<span class="fu">.</span> <span class="dt">Eff</span> (<span class="ot">random ::</span> <span class="dt">Random</span> <span class="fu">|</span> eff) <span class="dt">Number</span></code></pre>
<p><code>random</code>関数は実行時には引数なしの関数として表現されていることに注目してください。これは乱数生成という副作用を実行しそれを返しますが、返り値は<code>Number</code>型の実行時表現と一致します。それは<code>null</code>でないJavaScriptの数です。</p>
<p>もう少し興味深い例として、 Preludeの<code>Debug.Trace</code>モジュールで定義された<code>trace</code>関数を考えてみましょう。<code>trace</code>関数は次の型を持っています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">forall eff<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">trace ::</span> <span class="dt">Trace</span> <span class="fu">|</span> eff) <span class="dt">Unit</span></code></pre>
<p>この定義は次のようになっています。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">foreign <span class="kw">import</span> trace
  <span class="st">&quot;function trace(s) {\</span>
<span class="st">  \  return function() {\</span>
<span class="st">  \    console.log(s);\</span>
<span class="st">  \    return {};\</span>
<span class="st">  \  };\</span>
<span class="st">  \}&quot;</span> :: forall <span class="ot">eff</span>. <span class="fu">String</span> -&gt; <span class="fu">Eff</span> (trace :: Trace | eff) Unit</code></pre>
<p>実行時の<code>trace</code>の表現は、引数なしの関数を返す、単一の引数のJavaScript関数です。内側の関数はコンソールにメッセージを書き込むという副作用を実行し、空のレコードを返します。<code>Unit</code>は空のレコード型のnewtypeとしてPreludeで定義されているので、内側の関数の戻り値の型は<code>Unit</code>型の実行時表現と一致していることに注意してください。</p>
<p>作用<code>Random</code>と<code>Trace</code>も外部型として定義されています。その種は<code>!</code>、つまり作用であると定義されています。例えば次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>data <span class="dt">Random</span> :: !</code></pre>
<p>詳しくはあとで見ていきますが、このように新たな作用を定義することが可能なのです。</p>
<p><code>Eff eff a</code>型の式は、通常のJavaScriptのメソッドのようにJavaScriptから呼び出すことができます。例えば、この<code>main</code>関数は作用の集合<code>eff</code>と何らかの型<code>a</code>について<code>Eff eff a</code>という型でなければならないので、次のように実行することができます。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="ot">PS</span>.<span class="ot">Main</span>.<span class="fu">main</span>();</code></pre>
<p>または、CommonJSの環境では次のようにします。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="fu">require</span>(<span class="st">&#39;Main&#39;</span>).<span class="fu">main</span>();</code></pre>
<p><code>psc</code>コンパイラを使用するときは、コマンドライン上で <code>--main</code>コンパイラオプションを使用すると、この<code>main</code>の呼び出しを自動的に生成することができます。</p>
<h2 id="新しい作用の定義"><span class="header-section-number">10.16</span> 新しい作用の定義</h2>
<p>この章のソースコードでは、2つの新しい作用が定義されています。最も簡単なのは<code>Control.Monad.Eff.Alert</code>モジュールで定義された<code>Alert</code>作用です。これはその計算がポップアップウィンドウを使用してユーザに警告しうることを示すために使われます。</p>
<p>この作用は最初に外部型宣言を使用して定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>data <span class="dt">Alert</span> :: !</code></pre>
<p><code>Alert</code>は種<code>!</code>が与えられており、<code>Alert</code>が型ではなく作用であることを示しています。</p>
<p>次に、<code>alert</code>アクションが定義されています。<code>alert</code>アクションはポップアップを表示し、作用の行に<code>Alert</code>作用を追加します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>alert
  <span class="st">&quot;function alert(msg) {\</span>
<span class="st">  \  return function() {\</span>
<span class="st">  \    window.alert(msg);\</span>
<span class="st">  \    return {};\</span>
<span class="st">  \  };\</span>
<span class="st">  \}&quot;</span><span class="ot"> ::</span> forall eff<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">alert ::</span> <span class="dt">Alert</span> <span class="fu">|</span> eff) <span class="dt">Unit</span></code></pre>
<p>このアクションは<code>Debug.Trace</code>モジュールの<code>trace</code>アクションととてもよく似ています。唯一の違いは、<code>trace</code>アクションが<code>console.log</code>メソッドを使用しているのに対し、<code>alert</code>アクションは<code>window.alert</code>メソッドを使用していることです。このように、<code>alert</code>は<code>window.alert</code>が定義されているウェブブラウザのような環境で使用することができます。</p>
<p><code>trace</code>の場合のように、<code>alert</code>関数は型<code>Eff (alert :: Alert | eff) Unit</code>の計算を表現するために引数なしの関数を使っていることに注意してください。</p>
<p>この章で定義される２つめの作用は、<code>Control.Monad.Eff.Storage</code>モジュールで定義されている<code>Storage</code>作用です。これは計算がWeb Storage APIを使用して値を読み書きする可能性があることを示すために使われます。</p>
<p>この作用も同じように定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>data <span class="dt">Storage</span> :: !</code></pre>
<p><code>Control.Monad.Eff.Storage</code>モジュールには、ローカルストレージから値を取得する<code>getItem</code>と、ローカルストレージに値を挿入したり値を更新する<code>setItem</code>という、２つのアクションが定義されています。この二つの関数は、次のような型を持っています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getItem ::</span> forall eff<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">storage ::</span> <span class="dt">Storage</span> <span class="fu">|</span> eff) <span class="dt">Foreign</span>
<span class="ot">setItem ::</span> forall eff<span class="fu">.</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">storage ::</span> <span class="dt">Storage</span> <span class="fu">|</span> eff) <span class="dt">Unit</span></code></pre>
<p>興味のある読者は、このモジュールのソースコードでこれらのアクションがどのように定義されているか調べてみてください。</p>
<p><code>setItem</code>はキーと値(両方とも文字列)を受け取り、指定されたキーでローカルストレージに値を格納する計算を返します。</p>
<p><code>getItem</code>の型はもっと興味深いものです。<code>getItem</code>はキーを引数に取り、キーに関連付けられた値をローカルストレージから取得しようとします。<code>window.localStorage</code>の<code>getItem</code>メソッドは<code>null</code>を返すことがあるので、返り値は<code>String</code>ではなく、<code>purescript-foreign</code>パッケージの<code>Data.Foreign</code>モジュールで定義されている<code>Foreign</code>になっています。</p>
<p><code>Data.Foreign</code>は、<strong>型付けされていないデータ</strong>、もっと一般的にいえば実行時表現が不明なデータを扱う方法を提供しています。</p>
<blockquote>
<h2 id="演習-28" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(やや難しい) JavaScriptの<code>Window</code>オブジェクトの<code>confirm</code>メソッドのラッパを書き、<code>Control.Monad.Eff.Alert</code>モジュールにその関数を追加してください。</p></li>
<li><p>(やや難しい) <code>localStorage</code>オブジェクトの<code>removeItem</code>メソッドのラッパを書き、<code>Control.Monad.Eff.Storage</code>モジュールに追加してください</p></li>
</ol>
</blockquote>
<h2 id="型付けされていないデータの操作"><span class="header-section-number">10.17</span> 型付けされていないデータの操作</h2>
<p>この節では、型付けされていないデータを、その型の適切な実行時表現を持った型付けされたデータに変換する、<code>Data.Foreign</code>ライブラリの使い方について見て行きます。</p>
<p>この章のコードは、第8章の住所録の上にフォームの一番下に保存ボタンを追加することで作っていきます。保存ボタンがクリックされると、フォームの状態をJSONに直列化し、ローカルストレージに格納します。ページが再読み込みされると、JSON文書がローカルストレージから取得され、構文解析されます。</p>
<p><code>Main</code>モジュールではフォームデータの型を定義します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">FormData</span> <span class="fu">=</span> <span class="dt">FormData</span>
  {<span class="ot"> firstName  ::</span> <span class="dt">String</span>
  ,<span class="ot"> lastName   ::</span> <span class="dt">String</span>
  ,<span class="ot"> street     ::</span> <span class="dt">String</span>
  ,<span class="ot"> city       ::</span> <span class="dt">String</span>
  ,<span class="ot"> state      ::</span> <span class="dt">String</span>
  ,<span class="ot"> homePhone  ::</span> <span class="dt">String</span>
  ,<span class="ot"> cellPhone  ::</span> <span class="dt">String</span>
  }</code></pre>
<p>問題は、このJSONが正しい形式を持っているという保証がないことです。別の言い方をすれば、JSONが実行時にデータの正しい型を表しているかはわかりません。この問題は<code>purescript-foreign</code>ライブラリによって解決することができます。他にも次のような使いかたがあります。</p>
<ul>
<li>WebサービスからJSONレスポンス</li>
<li>JavaScriptコードから関数に渡された値</li>
</ul>
<p>それでは、<code>psci</code>で<code>purescript-foreign</code>ライブラリを試してみましょう。二つのモジュールをインポートして起動します。</p>
<pre class="text"><code>&gt; :i Data.Foreign
&gt; :i Data.Foreign.Class</code></pre>
<p><code>Foreign</code>な値を取得するためには、JSON文書を解析するのがいいでしょう。<code>purescript-foreign</code>はで次の2つの関数が定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseJSON ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">F</span> <span class="dt">Foreign</span>
<span class="ot">readJSON ::</span> forall a<span class="fu">.</span> (<span class="dt">IsForeign</span> a) <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">F</span> a</code></pre>
<p>型構築子<code>F</code>は、実際は<code>Data.Foreign</code>で定義されている型同義語です。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">F</span> <span class="fu">=</span> <span class="dt">Either</span> <span class="dt">ForeignError</span></code></pre>
<p><code>purescript-foreign</code>ライブラリの関数のほとんどは、<code>F</code>モナドの値を返します。これは、型付けされた値を構築するのに、do記法やApplicative関手コンビネータを使うことができることを意味しています。</p>
<p>この<code>IsForeign</code>型クラスは、それらの型が型付けされていないデータから得られることを表しています。プリミティブ型や配列について定義された型クラスインスタンスは存在しますが、独自のインスタンスを定義することもできます。</p>
<p>それでは<code>psci</code> で<code>readJSON</code>を使用していくつかの簡単なJSON文書を解析してみましょう。</p>
<pre class="text"><code>&gt; readJSON &quot;\&quot;Testing\&quot;&quot; :: F String
Right &quot;Testing&quot;

&gt; readJSON &quot;true&quot; :: F Boolean 
Right true

&gt; readJSON &quot;[1, 2, 3]&quot; :: F [Number]
Right [1, 2, 3]</code></pre>
<p><code>Either</code>モナドでは<code>Right</code>データ構築子は成功を示していることを思い出してください。しかし、その不正なJSONや誤った型はエラーを引き起こすことに注意してください。</p>
<pre class="text"><code>&gt; readJSON &quot;[1, 2, true]&quot; :: F [Number]

Left (Error at array index 2: Type mismatch: expected Number, found Boolean)</code></pre>
<p><code>purescript-foreign</code>ライブラリはJSON文書で型エラーが発生した位置を教えてくれます。</p>
<h2 id="nullとundefined値の取り扱い"><span class="header-section-number">10.18</span> nullとundefined値の取り扱い</h2>
<p>実世界のJSON文書にはnullやundefined値が含まれているので、それらも扱えるようにしなければなりません。</p>
<p><code>purescript-foreign</code>では、この問題を解決する3種類の構築子、<code>Null</code>、<code>Undefined</code>、<code>NullOrUndefined</code>が定義されています。先に定義した<code>Undefined</code>型の構築子と似た目的を持っていますが、省略可能な値を表すために<code>Maybe</code>型の構築子を内部的に使っています。</p>
<p>それぞれの型の構築子について、ラップされた値から内側の値を取り出す関数、<code>runNull</code>、<code>runUndefined</code> <code>runNullOrUndefined</code>が提供されています。<code>null</code>値を許容するJSON文書を解析するには、<code>readJSON</code>アクションまで対応する適切な関数を持ち上げます。</p>
<pre class="text"><code>&gt; runNull &lt;$&gt; readJSON &quot;42&quot; :: F (Null Number)
Right (Just 42)

&gt; runNull &lt;$&gt; readJSON &quot;null&quot; :: F (Null Number)
Right Nothing</code></pre>
<p>それぞれの場合で、型注釈が<code>&lt;$&gt;</code>演算子の右辺に適用されています。たとえば、<code>readJSON &quot;42&quot;</code>は型<code>F (Null Number)</code>を持っています。<code>runNull</code>関数は最終的な型<code>F (Maybe Number)</code>与えるために<code>F</code>まで持ち上げられます。</p>
<p>型<code>NULL Number</code>は数またはnullいずれかの値を表しています。各要素が<code>null</code>をかもしれない数値の配列のように、より興味深いの値を解析したい場合はどうでしょうか。その場合には、次のように<code>readJSON</code>アクションまで関数<code>map runNull</code>を持ち上げます。</p>
<pre class="text"><code>&gt; :i Data.Array

&gt; map runNull &lt;$&gt; readJSON &quot;[1, 2, null]&quot; :: F [Null Number]
Right [Just 1, Just 2, Nothing]</code></pre>
<p>一般的には、同じ型に異なる直列化戦略を提供するには、newtypesを使って既存の型をラップするのがいいでしょう。<code>null</code>、<code>Undefined</code>、<code>NullOrUndefined</code>それぞれの型は、<code>Maybe</code>型構築子に包まれたnewtypeとして定義されています。</p>
<h2 id="住所録の項目の直列化"><span class="header-section-number">10.19</span> 住所録の項目の直列化</h2>
<p>フォームデータは<code>JSON.strongify</code>メソッドを使用して直列化されますが、これは<code>Data.JSON</code>モジュールで定義されている次の関数でラップされています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>stringify
  <span class="st">&quot;function stringify(x) {\</span>
<span class="st">  \  return JSON.stringify(x);\</span>
<span class="st">  \}&quot;</span><span class="ot"> ::</span> <span class="dt">Foreign</span> <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre>
<p>保存ボタンをクリックすると、型<code>FormData</code>の値が(<code>Foreign</code>の値に変換されたあとで)<code>stringify</code>関数に渡され、JSON文書として直列化されます。<code>FormData</code>型はレコードのnewtypeで、<code>JSON.stringify</code>が渡された型<code>FormData</code>の値はJSON<strong>オブジェクト</strong>として扱われて直列化されます。newtypeはその基礎となるデータと同じ実行時表現を持っているためです。</p>
<p>生成されたJSONドキュメントを解析できるようにするためには、オブジェクトのプロパティを読み取れるようにしなければなりません。<code>purescript-foreign</code>ライブラリはその機能を<code>(!)</code>演算子と<code>readProp</code>アクションによって提供しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(!) ::</span> (<span class="dt">Index</span> i) <span class="ot">=&gt;</span> <span class="dt">Foreign</span> <span class="ot">-&gt;</span> i <span class="ot">-&gt;</span> <span class="dt">F</span> <span class="dt">Foreign</span>
<span class="ot">readProp ::</span> forall a i<span class="fu">.</span> (<span class="dt">IsForeign</span> a, <span class="dt">Index</span> i) <span class="ot">=&gt;</span> i <span class="ot">-&gt;</span> <span class="dt">Foreign</span> <span class="ot">-&gt;</span> <span class="dt">F</span> a</code></pre>
<p>型クラス<code>Index</code>は外部値のプロパティをインデックスするために使われる型を表しています。<code>Index</code>のインスタンスは<code>String</code>(オブジェクトプロパティにアクセスするため)と<code>Number</code>(配列要素にアクセスするため)に対して提供されています。</p>
<p><code>readProp</code>アクションを使うと、<code>FormData</code>型の<code>IsForeign</code>のインスタンスを定義することができます。次のように<code>IsForeign</code>型クラスで定義されている<code>read</code>関数を実装する必要があります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">IsForeign</span> a <span class="kw">where</span>
<span class="ot">  read ::</span> <span class="dt">Foreign</span> <span class="ot">-&gt;</span> <span class="dt">F</span> a</code></pre>
<p><code>read</code>関数を実装するには、<code>F</code>の<code>Monad</code>構造を使って小さな部分から<code>FormData</code>構造体を次のように作っていきます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> formDataIsForeign ::</span> <span class="dt">IsForeign</span> <span class="dt">FormData</span> <span class="kw">where</span>
  read value <span class="fu">=</span> <span class="kw">do</span>
    firstName   <span class="ot">&lt;-</span> readProp <span class="st">&quot;firstName&quot;</span> value
    lastName    <span class="ot">&lt;-</span> readProp <span class="st">&quot;lastName&quot;</span>  value
    street      <span class="ot">&lt;-</span> readProp <span class="st">&quot;street&quot;</span>    value
    city        <span class="ot">&lt;-</span> readProp <span class="st">&quot;city&quot;</span>      value
    state       <span class="ot">&lt;-</span> readProp <span class="st">&quot;state&quot;</span>     value
    homePhone   <span class="ot">&lt;-</span> readProp <span class="st">&quot;homePhone&quot;</span> value
    cellPhone   <span class="ot">&lt;-</span> readProp <span class="st">&quot;cellPhone&quot;</span> value
    return <span class="fu">$</span> <span class="dt">FormData</span>
      { firstName  <span class="fu">:</span> firstName
      , lastName   <span class="fu">:</span> lastName
      , street     <span class="fu">:</span> street
      , city       <span class="fu">:</span> city
      , state      <span class="fu">:</span> state
      , homePhone  <span class="fu">:</span> homePhone
      , cellPhone  <span class="fu">:</span> cellPhone
      }</code></pre>
<p><code>FormData</code>の構築子関数を<code>F</code>型構築子まで持ち上げると、このコードを<code>F</code>の<code>Applicative</code>構造を使って書くこともできます。これは演習として残しておきます。</p>
<p>この型クラスのインスタンスは、ローカル·ストレージから取得したJSON文書を解析するために<code>readJSON</code> で次のように使われています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">loadSavedData <span class="fu">=</span> <span class="kw">do</span>
  item <span class="ot">&lt;-</span> getItem <span class="st">&quot;person&quot;</span>
  
  <span class="kw">let</span>
<span class="ot">    savedData ::</span> <span class="dt">F</span> (<span class="dt">Maybe</span> <span class="dt">FormData</span>)
    savedData <span class="fu">=</span> <span class="kw">do</span>
      jsonOrNull <span class="ot">&lt;-</span> read item
      traverse readJSON (runNull jsonOrNull)</code></pre>
<p><code>savedData</code>アクションは２つのステップにわけて<code>FormData</code>構造を読み取ります。まず、<code>getItem</code>から得た<code>Foreign</code>値を解析します。<code>jsonOrNull</code>の型はコンパイラによって<code>Null String</code>だと推論されます(読者への演習：　この型はどのように推論されているのでしょうか？)。<code>traverse</code>関数は<code>readJSON</code>を<code>Maybe.String</code>型の結果の(不足しているかもしれない)要素へと適用するのに使われます。<code>readJSON</code>について推論される型クラスのインスタンスはちょうどさっき書いたもので、型<code>F (Maybe FormData)</code>の値で結果を返します。</p>
<p><code>traverse</code>の引数には<code>read</code>が最初の行で得た結果<code>jsonOrNull</code>を使っているので、<code>F</code>のモナド構造を使う必要があります。</p>
<p>結果の<code>FormData</code>には3つの可能性があります。</p>
<ul>
<li>もし外側の構築子が <code>Left</code>なら、JSON文字列の解析中にエラーがあったか、それが間違った型の値を表しています。この場合、アプリケーションは先ほど書いた <code>alert</code>アクションを使用してエラーを表示します。</li>
<li>もし外側の構築子が <code>Right</code>で内側の構築子が<code>Nothing</code>なら、<code>getItem</code>が<code>Nothing</code>を返しており、キーがローカルストレージに存在していなかったことを意味しています。この場合、アプリケーションは静かに実行を継続します。</li>
<li>最後に、<code>Right (Just _)</code>に適合した値はJSON文書としてただしく構文解析されたことを示しています。この場合、アプリケーションは適切な値でフォームフィールドを更新します。</li>
</ul>
<p><code>grunt</code>を実行し、それからブラウザで<a href="http://localhost:8000/"><code>http://localhost:8000</code></a>を開いて、これらのコードを試してみてください。保存ボタンをクリックするとフォームフィールドの内容をローカルストレージへ保存することができ、ページを再読込するとフィールドが再現されるはずです。</p>
<blockquote>
<h2 id="演習-29" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単) <code>readJSON</code>を使って、<code>[[1, 2, 3], [4, 5], [6]]</code>のようなJavaScriptの数の２次元配列を表現するJSON文書を解析してください。 要素をnullにすることが許容されている場合はどうでしょうか。配列自体がnullにすることが許容されている場合はどうなりますか。</p></li>
<li><p>(やや難しい) Applicativeコンビネータ<code>&lt;$&gt;</code>と<code>&lt;*&gt;</code>を使って<code>formDataIsForeign</code>型クラスを書きなおしてください。</p></li>
<li><p>(やや難しい) <code>savedData</code>の実装の型を検証し、計算のそれぞれの部分式の推論された型を書き出してみましょう。</p></li>
<li><p>(難しい) 次のnewtype型は、<strong>タグ付き</strong>共用体として直列化されなければならない<code>Either a b</code>の型の値を表しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Tagged</span> a b <span class="fu">=</span> <span class="dt">Tagged</span> (<span class="dt">Either</span> a b)</code></pre>
<p>つまり、直列化されたJSON文書には<code>Left</code>構築子と<code>Right</code>構築子のどちらが値を構築するのに使われたかということを表すプロパティ<code>tag</code>を含まなければいけません。実際の値は、JSON文書の<code>value</code>のプロパティに格納される必要があります。</p>
<p>例えば、JSONデータ<code>{ tag: &quot;Left&quot;, value: 0 }</code>は<code>Left 0</code>へと復元されなければいけません。</p>
<p>この<code>Tagged</code>型構築子の<code>IsForeign</code>についての妥当なインスタンスを書いてください。</p></li>
<li><p>(難しい、拡張)次のデータ型は、葉で値を持つ二分木を表しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Branch</span> (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</code></pre>
<p>JSONドキュメントとしてこの型の適切な表現を選択してください。<code>JSON.stringify</code>と中間のレコードのnewtypeを使って二分木をJSONへ直列化する関数を書き、関連する<code>IsForeign</code>のインスタンスを書いてください。</p></li>
</ol>
</blockquote>
<h2 id="まとめ-8"><span class="header-section-number">10.20</span> まとめ</h2>
<p>この章では、PureScriptから外部のJavaScriptコードを扱う方法、およびその逆の方法を学びました。また、FFIを使用して信頼できるコードを書く時に生じる問題について見てきました。</p>
<ul>
<li>データの<strong>実行時表現</strong>の重要性を見て、外部関数が正しい表現を持っていることを確かめました。</li>
<li>外部型、つまり<code>Foreign</code>データ型を使用することによって、null値のような特殊な場合やJavaScriptの他の型のデータに対処する方法を学びました。</li>
<li>Preludeで定義されたいくつかの共通の外部型、既存のJavaScriptコードとどのように相互運用に使用するかを見てきました。特に、<code>Eff</code>モナドにおける副作用の表現を導入し、新たな副作用を追跡するために<code>Eff</code>モナドを使用する方法を説明しました。</li>
<li><code>IsForeign</code>型クラスを使用して安全にJSONデータを復元する方法を説明しました。</li>
</ul>
<p>その他の例については、Githubの<code>purescript</code>組織および<code>purescript-contrib</code>組織が、FFIを使用するライブラリの例を多数提供しています。残りの章では、型安全な方法で現実世界の問題を解決するために使うライブラリを幾つか見ていきます。</p>
<h1 id="モナドの探求"><span class="header-section-number">11</span> モナドの探求</h1>
<h2 id="この章の目標-8"><span class="header-section-number">11.1</span> この章の目標</h2>
<p>この章の目標は、異なるモナドから提供された副作用を合成する方法を提供する<strong>モナド変換子</strong>(monad transformers)について学ぶことです。NodeJSのコンソール上で遊ぶことができる、テキストアドベンチャーゲームを題材として扱います。ゲームの様々な副作用(ロギング、状態、および設定)がすべてモナド変換子スタックによって提供されます。</p>
<h2 id="プロジェクトの準備-8"><span class="header-section-number">11.2</span> プロジェクトの準備</h2>
<p>このモジュールのプロジェクトでは以下のBower依存関係が新たに導入されます。</p>
<ul>
<li><code>purescript-maps</code>　- 不変のマップと集合のためのデータ型を提供します。</li>
<li><code>purescript-transformers</code> - 標準のモナド変換子の実装を提供します。</li>
<li><code>purescript-node-readline</code> - NodeJSが提供する<a href="http://nodejs.org/api/readline.html"><code>readline</code></a>インターフェイスへのFFIバインディングを提供します。</li>
<li><code>purescript-yargs</code> - <a href="https://www.npmjs.org/package/yargs"><code>yargs</code></a>コマンドライン引数処理ライブラリにApplicativeなインターフェイスを提供します。</li>
</ul>
<h2 id="ゲームの遊びかた"><span class="header-section-number">11.3</span> ゲームの遊びかた</h2>
<p>プロジェクトを実行するには、<code>grunt</code>でソースコードをビルドしてから、NodeJSにコンパイルされたJavaScriptを渡します。</p>
<pre class="text"><code>$ node dist/Main.js</code></pre>
<p>デフォルトでは使い方が表示されます。</p>
<pre class="text"><code>node ./dist/Main.js -p &lt;player name&gt;

Options:
  -p, --player  Player name  [required]
  -d, --debug   Use debug mode

Missing required arguments: p
The player name is required</code></pre>
<p><code>-p</code>オプションを使ってプレイヤー名を提供してください。</p>
<pre class="text"><code>node dist/Main.js -p Phil
&gt; </code></pre>
<p>プロンプトからは、 <code>look</code>、<code>inventory</code>、 <code>take</code>、<code>use</code>、 <code>north</code>、<code>south</code>、 <code>east</code>、<code>west</code>などのコマンドを入力することができます。<code>--debug</code>コマンドラインオプションが与えられたときには、ゲームの状態を出力するための<code>debug</code>コマンドも使えます。</p>
<p>ゲームは2次元の碁盤の目の上でプレイし、コマンド <code>north</code>、<code>south</code>、 <code>east</code>、<code>west</code>を発行することによってプレイヤーが移動します。ゲームにはアイテムのコレクションがあり、プレイヤーの所持アイテム一覧を表したり、ゲーム盤上のその位置にあるアイテムの一覧を表すのに使われます。<code>take</code>コマンドを使うと、プレイヤーの位置にあるアイテムを拾い上げることができます。</p>
<p>参考までに、このゲームのひと通りの流れは次のようになります。</p>
<pre class="text"><code>$ node dist/Main.js -p Phil

&gt; look
You are at (0, 0)
You are in a dark forest. You see a path to the north.
You can see the Matches.

&gt; take Matches
You now have the Matches

&gt; north
&gt; look
You are at (0, 1)
You are in a clearing.
You can see the Candle.

&gt; take Candle
You now have the Candle

&gt; inventory
You have the Candle.
You have the Matches.

&gt; use Matches
You light the candle.
Congratulations, Phil!
You win!</code></pre>
<p>このゲームはとても単純ですが、この章の目的は<code>purescript-transformers</code>パッケージを使用してこのようなのゲームを素早く開発できるようにするライブラリを構築することです。</p>
<h2 id="stateモナド"><span class="header-section-number">11.4</span> Stateモナド</h2>
<p><code>purescript-transformers</code>パッケージで提供されるモナドをいくつか見てみましょう。</p>
<p>最初の例は、<strong>純粋な変更可能状態</strong>を提供する<code>State</code>モナドです。すでに <code>Eff</code>モナド、すなわち<code>Ref</code>作用と<code>ST</code>作用によって提供された変更可能な状態という2つのアプローチについては見てきました。<code>State</code>は第3の選択肢を提供しますが、これは<code>Eff</code>モナドを使用して実装されているわけではありません。</p>
<p><code>State</code>型構築子は、状態の型<code>s</code>、および返り値の型<code>a</code>という2種類の引数を取ります。「<code>State</code>モナド」というように説明はしていますが、実際には<code>Monad</code>型クラスのインスタンスが用意されているのは<code>State</code>に対してではなく、任意の型<code>s</code>についての<code>State s</code>型構築子に対してです。</p>
<p><code>Control.Monad.State</code>モジュールは以下のAPIを提供しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">get    ::</span> forall s<span class="fu">.</span>             <span class="dt">State</span> s s
<span class="ot">put    ::</span> forall s<span class="fu">.</span> s        <span class="ot">-&gt;</span> <span class="dt">State</span> s <span class="dt">Unit</span>
<span class="ot">modify ::</span> forall s<span class="fu">.</span> (s <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">State</span> s <span class="dt">Unit</span></code></pre>
<p>これは<code>Ref</code>作用や<code>ST</code>作用が提供するAPIととてもよく似ています。しかし、これらのアクションに<code>RefVal</code>や<code>STRef</code>に渡しているような、可変領域への参照を引数に渡さないことに注意してください。<code>State</code>と<code>Eff</code>モナドが提供する解決策の違いは、<code>State</code>モナドは暗黙的な単一の状態だけを提供していることです。この状態は<code>State</code>モナドの型構築子によって隠された関数の引数として実装されており、参照は明示的には渡されないのです。</p>
<p>例を見てみましょう。<code>State</code>モナドの使いかたのひとつとしては、状態を数として、現在の状態に配列の値を加算していくようなものかもしれません。状態の型 <code>s</code>として<code>Number</code>を選択し、配列の走査に<code>traverse_</code>を使って、配列の要素それぞれについて<code>modify</code>を呼び出すと、これを実現することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Foldable</span> (traverse_)
<span class="kw">import </span><span class="dt">Control.Monad.State</span>
<span class="kw">import </span><span class="dt">Control.Monad.State.Class</span>

<span class="ot">sumArray ::</span> [<span class="dt">Number</span>] <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">Number</span> <span class="dt">Unit</span>
sumArray <span class="fu">=</span> traverse_ <span class="fu">$</span> \n <span class="ot">-&gt;</span> modify (\sum <span class="ot">-&gt;</span> sum <span class="fu">+</span> n)</code></pre>
<p><code>Control.Monad.State</code>モジュールは<code>State</code>モナドでの計算を実行するための次の3つの関数を提供します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">evalState ::</span> forall s a<span class="fu">.</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a
<span class="ot">execState ::</span> forall s a<span class="fu">.</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
<span class="ot">runState  ::</span> forall s a<span class="fu">.</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Tuple</span> a s</code></pre>
<p>３つの関数はそれぞれ初期値の型<code>s</code>と計算の型<code>State s a</code>を引数にとります。<code>evalState</code>は返り値だけを返し、<code>execState</code>は最終的な状態だけを返し、<code>runState</code>は<code>Tuple a s</code>型の値として表現された返り値と状態の両方を返します。</p>
<p>先ほどの<code>sumArray</code>関数が与えられたとすると、<code>psci</code>で次のように<code>execState</code>を使うと複数の配列内の数字を合計することができます。</p>
<pre class="text"><code>&gt; execState (do
    sumArray [1, 2, 3]
    sumArray [4, 5]
    sumArray [6]
  ) 0
  
21</code></pre>
<blockquote>
<h2 id="演習-30" class="unnumbered">演習</h2>
<ol type="1">
<li>(簡単) 上の例で、<code>execState</code>を<code>runState</code>や<code>evalState</code>で 置き換えると結果はどうなるでしょうか。</li>
<li><p>(やや難しい) <code>State</code>モナドと<code>traverse_</code>関数を使用して、次のような関数を書いてください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">testParens ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Boolean</span></code></pre>
<p>これは<code>String</code>が括弧の対応が正しく付けられているかどうかを調べる関数です。この関数は次のように動作しなくてはなりません。</p>
<pre class="text"><code>&gt; testParens &quot;&quot;
true

&gt; testParens &quot;(()(())())&quot;
true

&gt; testParens &quot;)&quot;
false

&gt; testParens &quot;(()()&quot;
false</code></pre>
<p><strong>ヒント</strong>： 入力の文字列を文字の配列に変換するのに、<code>Data.String</code>モジュールの<code>split</code>関数を使うといいかもしれません。</p></li>
</ol>
</blockquote>
<h2 id="readerモナド"><span class="header-section-number">11.5</span> Readerモナド</h2>
<p><code>purescript-transformers</code>パッケージでは<code>Reader</code>というモナドも提供されています。このモナドは大域的な設定を読み取る機能を提供します。<code>State</code>モナドがひとつの可変状態を読み書きする機能を提供するのに対し、<code>Reader</code>モナドはデータの読み取りの機能だけを提供します。</p>
<p><code>Reader</code>型構築子は、構成の型を表す型<code>r</code>、および戻り値の型<code>a</code>の2つの型引数を取ります。</p>
<p><code>Contro.Monad.Reader</code>モジュールは以下のAPIを提供します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ask   ::</span> forall r<span class="fu">.</span> <span class="dt">Reader</span> r r
<span class="ot">local ::</span> forall r a<span class="fu">.</span> (r <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> <span class="dt">Reader</span> r a</code></pre>
<p><code>ask</code>アクションは現在の設定を読み取るために使い、<code>local</code>アクションは局所的に設定を変更して計算を実行するために使います。</p>
<p>たとえば、権限で制御されたアプリケーションを開発しており、現在の利用者の権限オブジェクトを保持するのに<code>Reader</code>モナドを使いたいとしましょう。型<code>r</code>を次のようなAPIを備えた型<code>Permission</code>として選択します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">hasPermission ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Permissions</span> <span class="ot">-&gt;</span> <span class="dt">Boolean</span>
<span class="ot">addPermission ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Permissions</span> <span class="ot">-&gt;</span> <span class="dt">Permissions</span></code></pre>
<p>利用者が特定の権限を持っているかどうかを確認したいときは、<code>ask</code>を使って現在の権限オブジェクトを取得すればいつでも調べることができます。たとえば、管理者だけが新しい利用者の作成を許可されているとしましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">createUser ::</span> <span class="dt">Reader</span> <span class="dt">Permissions</span> (<span class="dt">Maybe</span> <span class="dt">User</span>)
createUser <span class="fu">=</span> <span class="kw">do</span>
  permissions <span class="ot">&lt;-</span> ask
  <span class="kw">if</span> hasPermission <span class="st">&quot;admin&quot;</span> permissions
    <span class="kw">then</span> <span class="dt">Just</span> <span class="fu">&lt;$&gt;</span> newUser
    <span class="kw">else</span> return <span class="dt">Nothing</span></code></pre>
<p><code>local</code>アクションを使うと、計算の実行中に`Permissionsオブジェクトを局所的に変更し、ユーザーの権限を昇格させることもできます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runAsAdmin ::</span> forall a<span class="fu">.</span> <span class="dt">Reader</span> <span class="dt">Permissions</span> a <span class="ot">-&gt;</span> <span class="dt">Reader</span> <span class="dt">Permissions</span> a
runAsAdmin <span class="fu">=</span> local (addPermission <span class="st">&quot;admin&quot;</span>)</code></pre>
<p>こうすると、利用者が<code>admin</code>権限を持っていなかった場合であっても、新しい利用者を作成する関数を書くことができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">createUserAsAdmin ::</span> <span class="dt">Reader</span> <span class="dt">Permissions</span> (<span class="dt">Maybe</span> <span class="dt">User</span>)
createUserAsAdmin <span class="fu">=</span> runAsAdmin createUser</code></pre>
<p><code>Reader</code>モナドの計算を実行するには、大域的な設定を与える<code>runReader</code>関数を使います。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runReader ::</span> forall r a<span class="fu">.</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> a</code></pre>
<blockquote>
<h2 id="演習-31" class="unnumbered">演習</h2>
<p>以下の演習では、<code>Reader</code>モナドを使って、字下げのついた文書を出力するための小さなライブラリを作っていきます。「大域的な設定」は、現在の字下げの深さを示す数になります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Level</span> <span class="fu">=</span> <span class="dt">Number</span>
    
<span class="kw">type</span> <span class="dt">Doc</span> <span class="fu">=</span> <span class="dt">Reader</span> <span class="dt">Level</span> <span class="dt">String</span></code></pre>
<ol type="1">
<li><p>(簡単)　現在の字下げの深さで文字列を出力する関数 <code>line</code>を書いてください。その関数は、以下の型を持っている必要があります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">line ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Doc</span></code></pre>
<p><strong>ヒント</strong>：現在の字下げの深さを読み取るためには<code>ask</code>関数を使用します。</p></li>
<li><p>(やや難しい) <code>local</code>関数を使用して、コードブロックの字下げの深さを大きくする次のような関数を書いてください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">indent ::</span> <span class="dt">Doc</span> <span class="ot">-&gt;</span> <span class="dt">Doc</span></code></pre></li>
<li><p>(やや難しい) <code>Data.Traversable</code>で定義された<code>sequence</code>関数を使用して、文書のリストを改行で区切って連結する次のような関数を書いてください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">cat ::</span> [<span class="dt">Doc</span>] <span class="ot">-&gt;</span> <span class="dt">Doc</span></code></pre></li>
<li><p>(やや難しい) <code>runReader</code>関数を使用して、文書を文字列として出力する次のような関数を書いてください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">render ::</span> <span class="dt">Doc</span> <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre>
<p>これで、このライブラリを次のように使うと、簡単な文書を書くことができるはずです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">render <span class="fu">$</span> cat 
  [ line <span class="st">&quot;Here is some indented text:&quot;</span>
  , indent <span class="fu">$</span> cat 
      [ line <span class="st">&quot;I am indented&quot;</span>
      , line <span class="st">&quot;So am I&quot;</span>
      , indent <span class="fu">$</span> line <span class="st">&quot;I am even more indented&quot;</span>
      ]
  ]</code></pre></li>
</ol>
</blockquote>
<h2 id="writerモナド"><span class="header-section-number">11.6</span> Writerモナド</h2>
<p><code>Writer</code>モナドは、計算の返り値に加えて、もうひとつの値を累積していく機能を提供します。</p>
<p>よくある使い方としては型<code>String</code>もしくは<code>[String]</code>でログを累積していくというものなどがありますが、<code>Writer</code>モナドはこれよりもっと一般的なものです。これは累積するのに任意のモノイドの値を使うことができ、<code>Sum</code>モノイドを使って、合計を追跡し続けるのに使ったり、<code>Any</code>モノイドを使って途中の<code>Boolean</code>値がすべて真であるかどうかを追跡するのに使うことができます。</p>
<p><code>Writer</code>型の構築子は、<code>Monoid</code>型クラスのインスタンスである型<code>w</code>、および返り値の型<code>a</code>という2つの型引数を取ります。</p>
<p><code>Writer</code>のAPIで重要なのは<code>tell</code>関数です。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">tell ::</span> forall w a<span class="fu">.</span> (<span class="dt">Monoid</span> w) <span class="ot">=&gt;</span> w <span class="ot">-&gt;</span> <span class="dt">Writer</span> w <span class="dt">Unit</span></code></pre>
<p><code>tell</code>アクションは、与えられた値を現在の累積結果に加算します。</p>
<p>例として、<code>[String]</code>モノイドを使用して、既存の関数にログ機能を追加してみましょう。<strong>最大公約数</strong>関数の以前の実装を考えてみます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">gcd<span class="ot"> ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span>
gcd n <span class="dv">0</span> <span class="fu">=</span> n
gcd <span class="dv">0</span> m <span class="fu">=</span> m
gcd n m <span class="fu">=</span> <span class="kw">if</span> n <span class="fu">&gt;</span> m 
            <span class="kw">then</span> gcd (n <span class="fu">-</span> m) m 
            <span class="kw">else</span> gcd n (m <span class="fu">-</span> n)</code></pre>
<p><code>Writer [String] Number</code>に返り値の型を変更することで、この関数にログ機能を追加することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Writer</span>
<span class="kw">import </span><span class="dt">Control.Monad.Writer.Class</span>

<span class="ot">gcdLog ::</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> [<span class="dt">String</span>] <span class="dt">Number</span></code></pre>
<p>各手順で二つの入力を記録するために、少し関数を変更する必要があります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">gcd n <span class="dv">0</span> <span class="fu">=</span> return n
gcd <span class="dv">0</span> m <span class="fu">=</span> return m
gcd n m <span class="fu">=</span> <span class="kw">do</span>
  tell [<span class="st">&quot;gcd &quot;</span> <span class="fu">++</span> show n <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> show m]
  <span class="kw">if</span> n <span class="fu">&gt;</span> m 
    <span class="kw">then</span> gcd (n <span class="fu">-</span> m) m 
    <span class="kw">else</span> gcd n (m <span class="fu">-</span> n)</code></pre>
<p><code>Writer</code>モナドの計算を実行するには、<code>execWriter</code>関数と<code>runWriter</code>関数のいずれかを使います。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">execWriter ::</span> forall w a<span class="fu">.</span> <span class="dt">Writer</span> w a <span class="ot">-&gt;</span> w
<span class="ot">runWriter  ::</span> forall w a<span class="fu">.</span> <span class="dt">Writer</span> w a <span class="ot">-&gt;</span> <span class="dt">Tuple</span> a w</code></pre>
<p>ちょうど<code>State</code>モナドの場合と同じように、<code>execWriter</code>が累積されたログだけを返すのに対して、<code>runWriter</code>は累積されたログと結果の両方を返します。</p>
<p><code>psci</code>で修正された関数を試してみましょう。</p>
<pre class="text"><code>&gt; :i Data.Tuple
&gt; :i Data.Monoid
&gt; :i Control.Monad.Writer
&gt; :i Control.Monad.Writer.Class

&gt; runWriter (gcd 21 15)

Tuple 3 [&quot;gcd 21 15&quot;,&quot;gcd 6 15&quot;,&quot;gcd 6 9&quot;,&quot;gcd 6 3&quot;,&quot;gcd 3 3&quot;]</code></pre>
<blockquote>
<h2 id="演習-32" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(やや難しい) <code>Writer</code>モナドと<code>purescript-monoids</code>パッケージの<code>Sum</code>のモノイドを使うように、上の<code>sumArray</code>関数を書き換えてください。</p></li>
<li><p>(やや難しい)<strong>コラッツ関数</strong>は、自然数<code>n</code>が偶数なら<code>n / 2</code>、<code>n</code>が奇数なら<code>3 * n + 1</code>であると定義されています。たとえば、<code>10</code>で始まるコラッツ数列は次のようになります。</p>
<pre class="text"><code>10, 5, 16, 8, 4, 2, 1, ...</code></pre>
<p>コラッツ関数の有限回の適用を繰り返すと、コラッツ数列は必ず最終的に<code>1</code>になるということとが予想できます。</p>
<p>数列が<code>1</code>に到達するまでに何回のコラッツ関数の適用が必要かを計算する再帰的な関数を書いてください。</p>
<p>コラッツ関数のそれぞれの適用のログを記録するために<code>Writer</code>モナドを使用するように関数を変更してください。</p></li>
</ol>
</blockquote>
<h2 id="モナド変換子"><span class="header-section-number">11.7</span> モナド変換子</h2>
<p>上の3つのモナド、<code>State</code>、<code>Reader</code>、 <code>Writer</code>は、いずれもいわゆる<strong>モナド変換子</strong>(monad transformers)の例となっています。対応するモナド変換子はそれぞれ <code>StateT</code>、<code>ReaderT</code>、<code>WriterT</code>と呼ばれています。</p>
<p>モナド変換子とは何でしょうか。さて、これまで見てきたように、モナドはPureScriptで適切なハンドラ(<code>runState</code>、<code>runReader</code>、 <code>runWriter</code>など)を使って解釈される、いろいろな種類の副作用でPureScriptコードを拡張します。使用する必要がある副作用が<strong>ひとつだけ</strong>なら、これで問題ありません。しかし、同時に複数の副作用を使用できると便利なことがよくあります。例えば、<code>Maybe</code>と<code>Reader</code>を一緒に使用すると、ある大域的な設定の文脈で<strong>省略可能な結果</strong>を表現することができます。もしくは、<code>Either</code>モナドの純粋なエラー追跡機能と、<code>State</code>モナドが提供する変更可能な状態が同時に欲しくなるかもしれません。この問題を解決するのが<strong>モナド変換子</strong>です。</p>
<p><strong>拡張可能作用</strong>の手法を使うとネイティブな作用を混在させることができるので、<code>Eff</code>モナドはこの問題に対する部分的な解決策を提供していることをすでに見てきたことに注意してください。モナド変換子はまた異なった解決策を提供しますが、これらの手法にはそれぞれ利点と限界があります。</p>
<p>モナド変換子は型だけでなく別の型構築子によってもパラメータ化される型構築子です。モナド変換子はモナドをひとつ取り、独自のいろいろな副作用を追加した別のモナドへと変換します。</p>
<p>例を見てみましょう。<code>Control.Monad.State.Trans</code>で定義された<code>StateT</code>は<code>State</code>のモナド変換子版です。<code>psci</code>を使って<code>StateT</code>の種を見てみましょう。</p>
<pre class="text"><code>&gt; :i Control.Monad.State.Trans
&gt; :k StateT
* -&gt; (* -&gt; *) -&gt; * -&gt; *</code></pre>
<p>とても読みにくそうに思うかもしれませんが、使い方を理解するために、<code>StateT</code>にひとつ引数を与えてみましょう。</p>
<p><code>State</code>の場合、最初の型引数は使いたい状態の型です。それでは型<code>String</code>を与えてみましょう。</p>
<pre class="text"><code>&gt; :k StateT String
(* -&gt; *) -&gt; * -&gt; *</code></pre>
<p>次の引数は種<code>* -&gt; *</code>の型構築子です。これは<code>StateT</code>の機能を追加したい元のモナドを表します。例として、<code>Either String</code>モナドを選んでみます。</p>
<pre class="text"><code>&gt; :k StateT String (Either String)
* -&gt; *</code></pre>
<p>型構築子が残りました。最後の引数は戻り値の型を表しており、たとえばそれを<code>Number</code>にすることができます。</p>
<pre class="text"><code>&gt; :k StateT String (Either String) Number
*</code></pre>
<p>最後に、種<code>*</code>の何かが残りましたが、この型の値を探してみましょう。</p>
<p>構築したモナド<code>StateT String (Either String)</code>は、エラーで失敗する可能性があり、変更可能な状態を使える計算を表しています。</p>
<p>外側の<code>StateT String</code>モナドのアクション(<code>get</code>、<code>put</code>、<code>modify</code>)は直接使うことができますが、ラップされている内側のモナド(<code>Either String</code>)の作用を使うためには、これらの関数をモナド変換子まで「持ち上げ」なくてはいけません。<code>Control.MonadTrans</code>モジュールでは、モナド変換子であるような型構築子を捕捉する<code>MonadTrans</code>型クラスを次のように定義しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">MonadTrans</span> t <span class="kw">where</span>
<span class="ot">  lift ::</span> forall m a<span class="fu">.</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> t m a</code></pre>
<p>このクラスは、基礎となる任意のモナド<code>m</code>の計算をとり、それをラップされたモナド<code>t m</code>へと持ち上げる、<code>lift</code>というひとつの関数だけを持っています。今回の場合、型構築子<code>t</code>は<code>StateT String</code>で、<code>m</code>は<code>Either String</code>モナドとなり、<code>lift</code>は型<code>Either String a</code>の計算を、型<code>State String (Either String) a</code>の計算へと持ち上げる方法を提供することになります。これは、型<code>Either String a</code>の計算を使うときは、<code>lfft</code>を使えばいつでも作用<code>StateT String</code>と<code>Either String</code>を隣り合わせに使うことができることを意味します。</p>
<p>たとえば、次の計算は<code>StateT</code>モナド変換子で導入されている状態を読み込み、状態が空の文字列である場合はエラーを投げます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.String</span> (drop, take)

<span class="ot">split ::</span> <span class="dt">StateT</span> <span class="dt">String</span> (<span class="dt">Either</span> <span class="dt">String</span>) <span class="dt">String</span>
split <span class="fu">=</span> <span class="kw">do</span>
  s <span class="ot">&lt;-</span> get
  <span class="kw">case</span> s <span class="kw">of</span>
    <span class="st">&quot;&quot;</span> <span class="ot">-&gt;</span> lift <span class="fu">$</span> <span class="dt">Left</span> <span class="st">&quot;Empty string&quot;</span>
    _ <span class="ot">-&gt;</span> <span class="kw">do</span>
      put (drop <span class="dv">1</span> s)
      return (take <span class="dv">1</span> s)</code></pre>
<p>状態が空でなければ、この計算は<code>put</code>を使って状態を<code>drop 1 s</code>(最初の文字を取り除いた<code>s</code>)へと更新し、<code>take 1 s</code>(<code>s</code>の最初の文字)を返します。</p>
<p>それでは<code>psci</code>でこれを試してみましょう。</p>
<pre class="text"><code>&gt; runStateT split &quot;test&quot;
Right (Tuple &quot;t&quot; &quot;est&quot;)

&gt; runStateT split &quot;&quot;
Left &quot;Empty string&quot;</code></pre>
<p>これは<code>StateT</code>を使わなくても実装できるので、さほど驚くようなことではありません。しかし、モナドとして扱っているので、do記法やApplicativeコンビネータを使って、小さな計算から大きな計算を構築していくことができます。例えば、2回<code>split</code>を適用すると、文字列から最初の2文字を読むことができます。</p>
<pre class="text"><code>&gt; runStateT ((++) &lt;$&gt; split &lt;*&gt; split) &quot;test&quot;
Right (Tuple (&quot;te&quot;) (&quot;st&quot;))</code></pre>
<p>他にもアクションを幾つか用意すれば、<code>split</code>関数を使って、基本的な構文解析ライブラリを構築することができます。これは実際に<code>purescript-parsing</code>ライブラリで採用されている手法です。これがモナド変換子の力なのです。必要な副作用を選択して、do記法とApplicativeコンビネータで表現力を維持しながら、様々な問題のための特注のモナドを作成することができるのです。</p>
<h2 id="errortモナド変換子"><span class="header-section-number">11.8</span> ErrorTモナド変換子</h2>
<p><code>purescript-transformers</code>パッケージでは、<code>Either e</code>モナドに対応する変換子である<code>ErrorT e</code>モナド変換子も定義されています。これは次のAPIを提供します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Error</span> a <span class="kw">where</span>
<span class="ot">  noMsg ::</span> a
<span class="ot">  strMsg ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a

<span class="ot">throwError ::</span> forall m a<span class="fu">.</span> (<span class="dt">Error</span> e) <span class="ot">=&gt;</span> 
                            e <span class="ot">-&gt;</span> <span class="dt">ErrorT</span> e m a
<span class="ot">catchError ::</span> forall m a<span class="fu">.</span> (<span class="dt">Error</span> e) <span class="ot">=&gt;</span> 
                            <span class="dt">ErrorT</span> e m a <span class="ot">-&gt;</span> 
                            (e <span class="ot">-&gt;</span> <span class="dt">ErrorT</span> e m a) <span class="ot">-&gt;</span> 
                            <span class="dt">ErrorT</span> e m a
                            
<span class="ot">runErrorT ::</span> forall e m a<span class="fu">.</span> <span class="dt">ErrorT</span> e m a <span class="ot">-&gt;</span> m (<span class="dt">Either</span> e a)</code></pre>
<p>ちょうど<code>Either e</code>モナドと同じように、<code>throwError</code>アクションは失敗を示すために使われます。</p>
<p><code>catchError</code>アクションを使うと、<code>throwError</code>でエラーが投げられたあとでも処理を継続することができるようになります。</p>
<p><code>runErrorT</code>ハンドラを使うと、型<code>ErrorT e m a</code>の計算を実行することができます。</p>
<p>このAPIは<code>purescript-exceptions</code>パッケージの<code>Exception</code>作用によって提供されているものと似ています。しかし、いくつかの重要な違いがあります。</p>
<ul>
<li><code>ErrorT</code>モデルが代数的データ型を使っているのに対して、<code>Exception</code>は実際のJavaScriptの例外を使っています。</li>
<li><code>ErrorT</code>が<code>Error</code>型クラスのどんな型のエラーでも扱うのに対して、<code>Exception</code>作用はJavaScriptの<code>Error</code>型というひとつ例外の型だけを扱います。つまり、<code>ErrorT</code>では新たなエラー型を自由に定義できます。</li>
</ul>
<p>試しに<code>ErrorT</code>を使って<code>Writer</code>モナドを包んでみましょう。ここでもモナド変換子<code>ErrorT e</code>のアクションは自由に使えますが、<code>Writer</code>モナドの計算は<code>lift</code>を使って持ちあげなければなりません。　　</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Trans</span>
<span class="kw">import </span><span class="dt">Control.Monad.Writer</span>
<span class="kw">import </span><span class="dt">Control.Monad.Writer.Class</span>
<span class="kw">import </span><span class="dt">Control.Monad.Error</span>
<span class="kw">import </span><span class="dt">Control.Monad.Error.Class</span>

<span class="ot">writerAndErrorT ::</span> <span class="dt">ErrorT</span> <span class="dt">String</span> (<span class="dt">Writer</span> [<span class="dt">String</span>]) <span class="dt">String</span>
writerAndErrorT <span class="fu">=</span> <span class="kw">do</span>
  tell [<span class="st">&quot;Before the error&quot;</span>]
  throwError <span class="st">&quot;Error!&quot;</span>
  tell [<span class="st">&quot;After the error&quot;</span>]
  return <span class="st">&quot;Return value&quot;</span></code></pre>
<p><code>psci</code>でこの関数を試すと、ログの蓄積とエラーの送出という２つの作用がどのように相互作用しているのかを見ることができます。まず、<code>runErrorT</code>を使って外側の<code>ErrorT</code>計算を実行し、型<code>Write String (Either String String)</code>の結果を残します。それから、<code>runWriter</code>で内側の<code>Writer</code>計算を実行します。</p>
<pre class="text"><code>&gt; runWriter $ runErrorT writerAndErrorT
Tuple (Left &quot;Error!&quot;) [&quot;Before the error&quot;]</code></pre>
<p>実際に追加されるログは、エラーが投げられる前に書かれたログメッセージだけであることにも注目してください。</p>
<h2 id="モナド変換子スタック"><span class="header-section-number">11.9</span> モナド変換子スタック</h2>
<p>これまで見てきたように、モナド変換子を使うと既存のモナドの上に新しいモナドを構築することができます。任意のモナド変換子<code>t1</code>と任意のモナド<code>m</code>について、その適用<code>t1 m</code>もまたモナドになります。これは<strong>ふたつめの</strong>モナド変換子<code>t2</code>を先ほどの結果<code>t1 m</code>に適用すると、第３のモナド <code>t2 (t1 m)</code>を作れることを意味しています。このように、構成するモナドによって提供された副作用を組み合わせる、モナド変換子の<strong>スタック</strong>を構築することができます。</p>
<p>実際には、基本となるモナド<code>m</code>は、ネイティブの副作用が必要なら<code>Eff</code>モナド、さもなくば<code>Control.Monad.Identity</code>モジュールで定義されている<code>Identity</code>モナドになります。<code>Identity</code>モナドは何の新しい副作用も追加しませんから、<code>Identity</code>モナドの変換は、モナド変換子の作用だけを提供します。実際に、<code>State</code>モナド、<code>Reader</code>モナド、<code>Writer</code>モナドは、<code>Identity</code>モナドをそれぞれ<code>StateT</code>、 <code>ReaderT</code>、<code>WriterT</code>で変換することによって実装されています。</p>
<p>それでは3つの副作用が組み合わされている例を見てみましょう。<code>Identity</code>モナドをスタックの底にして、<code>StateT</code>作用、 <code>WriterT</code>作用、<code>ErrorT</code>作用を使います。このモナド変換子スタックは、ログの蓄積し、純粋なエラー、可変状態の副作用を提供します。</p>
<p>このモナド変圧器スタックを使うと、ロギングの機能が追加された<code>split</code>アクションを作ることができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Parser</span> <span class="fu">=</span> <span class="dt">StateT</span> <span class="dt">String</span> (<span class="dt">WriterT</span> [<span class="dt">String</span>] (<span class="dt">ErrorT</span> <span class="dt">String</span> <span class="dt">Identity</span>))

<span class="ot">split ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
split <span class="fu">=</span> <span class="kw">do</span>
  s <span class="ot">&lt;-</span> get
  lift <span class="fu">$</span> tell [<span class="st">&quot;The state is &quot;</span> <span class="fu">++</span> show s]
  <span class="kw">case</span> s <span class="kw">of</span>
    <span class="st">&quot;&quot;</span> <span class="ot">-&gt;</span> lift <span class="fu">$</span> lift <span class="fu">$</span> throwError <span class="st">&quot;Empty string&quot;</span>
    _ <span class="ot">-&gt;</span> <span class="kw">do</span>
      put (drop <span class="dv">1</span> s)
      return (take <span class="dv">1</span> s)</code></pre>
<p>この計算を<code>psci</code>で試してみると、<code>split</code>が実行されるたびに状態がログに追加されることがわかります。</p>
<p>モナド変換子スタックに現れる順序に従って、副作用を取り除いていかなければならないことに注意してください。最初に<code>StateT</code>型構築子を取り除くために<code>runStateT</code>を使い、それから<code>runtWriteT</code>を使い、その後<code>runErrorT</code>を使います。最後に<code>runIdentity</code>を使用して<code>Identity</code>モナドの演算を実行します。</p>
<pre class="text"><code>&gt; let runParser p s = runIdentity $ runErrorT $ runWriterT $ runStateT p s

&gt; runParser split &quot;test&quot;
  
Right (Tuple (Tuple &quot;t&quot; &quot;est&quot;) [&quot;The state is test&quot;])

&gt; runParser ((++) &lt;$&gt; split &lt;*&gt; split) &quot;test&quot;
  
Right (Tuple (Tuple &quot;te&quot; &quot;st&quot;) [&quot;The state is test&quot;, &quot;The state is est&quot;])</code></pre>
<p>しかしながら解析が失敗した場合は、状態が空であるためログはまったく出力されません。</p>
<pre class="text"><code>runParser split &quot;&quot;
&gt; Left &quot;Empty string&quot;</code></pre>
<p>これは、<code>ErrorT</code>モナド変換子が提供する副作用が、<code>WriterT</code>モナド変換子が提供する副作用に影響を受けるためです。これはモナド変換子スタックが構成されている順序を変更することで解決することができます。スタックの最上部に<code>ErrorT</code>変換子を移動すると、先ほど<code>Writer</code>を<code>ErrorT</code>に変換したときと同じように、最初のエラーまでに書かれたすべてのメッセージが含まれるようになります。</p>
<p>このコードの問題のひとつは、複数のモナド変換子の上まで計算を持ち上げるために、<code>lift</code>関数を複数回使わなければならないということです。たとえば、<code>throwError</code>の呼び出しは、1回めは<code>WriteT</code>へ、2回めは<code>StateT</code>へと、2回持ちあげなければなりません。小さなモナド変換子スタックならなんとかなりますが、そのうち不便だと感じるようになるでしょう。</p>
<p>幸いなことに、これから見るような型クラス推論によって提供されるコードの自動生成を使うと、ほとんどの「多段持ち上げ」を行うことができます。</p>
<blockquote>
<h2 id="演習-33" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単)　<code>Identity</code>関手の上の<code>ErrorT</code>モナド変換子を使って、分母がゼロの場合はエラーを投​​げる、2つの数の商を求める関数 <code>safeDivide</code>を書いてください。</p></li>
<li><p>(やや難しい) 現在の状態が接頭辞に適合するか、エラーメッセージとともに失敗する、次のような構文解析関数を書いてください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">string ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">String</span></code></pre>
<p>この構文解析器は次のように動作しなくてはなりません。</p>
<pre class="text"><code>&gt; runParser (string &quot;abc&quot;) &quot;abcdef&quot;

Right (Tuple (Tuple &quot;abc&quot; &quot;def&quot;) [&quot;The state is abcdef&quot;])</code></pre>
<p><strong>ヒント</strong>：出発点として<code>split</code>の実装を使うといいでしょう。</p></li>
<li><p>(難しい) 以前<code>Reader</code>モナドを使用して書いた文書出力ライブラリを、<code>ReaderT</code>と<code>WriterT</code>モナド変圧器を使用して再実装してください。</p>
<p>文字列を出力する<code>line</code>や文字列を連結する<code>cat</code>を使うのではなく、<code>WriteT</code>モナド変換子と一緒に<code>[String]</code>モノイドを使い、結果へ行を追加するのに<code>tell</code>を使ってください。</p></li>
</ol>
</blockquote>
<h2 id="救済のための型クラス"><span class="header-section-number">11.10</span> 救済のための型クラス</h2>
<p>章の最初で扱った<code>State</code>モナドを見てみると、<code>State</code>モナドのアクションには次のような型が与えられていました。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">get    ::</span> forall s<span class="fu">.</span>             <span class="dt">State</span> s s
<span class="ot">put    ::</span> forall s<span class="fu">.</span> s        <span class="ot">-&gt;</span> <span class="dt">State</span> s <span class="dt">Unit</span>
<span class="ot">modify ::</span> forall s<span class="fu">.</span> (s <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">State</span> s <span class="dt">Unit</span></code></pre>
<p><code>Control.Monad.State.Class</code>モジュールで与えられている型は、実際には次のようにもっと一般的です。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">get    ::</span> forall m s<span class="fu">.</span> (<span class="dt">MonadState</span> s m) <span class="ot">=&gt;</span>             m s
<span class="ot">put    ::</span> forall m s<span class="fu">.</span> (<span class="dt">MonadState</span> s m) <span class="ot">=&gt;</span> s        <span class="ot">-&gt;</span> m <span class="dt">Unit</span>
<span class="ot">modify ::</span> forall m s<span class="fu">.</span> (<span class="dt">MonadState</span> s m) <span class="ot">=&gt;</span> (s <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> m <span class="dt">Unit</span></code></pre>
<p><code>Control.Monad.State.Class</code>モジュールには「純粋な変更可能な状態を提供するモナド」への抽象化を可能にする<code>MonadState</code>(多変数)型クラスが定義されています。予想できると思いますが、<code>State s</code>型構築子は<code>MonadState s</code>型クラスのインスタンスになっており、このクラスには他にも興味深いインスタンスが数多くあります。</p>
<p>特に、<code>purescript-transformers</code>パッケージではモナド変換子<code>WriterT</code>、<code>ReaderT</code>、<code>ErrorT</code>についての<code>MonadState</code>のインスタンスが提供されています。実際に、<code>StateT</code>がモナド変換子スタックのどこかに現れ、<code>StateT</code>より上のすべてが<code>MonadState</code>のインスタンスであれば、<code>get</code>、<code>put</code>、<code>modify</code>を直接自由に使用することができます。</p>
<p>実は、これまで扱ってきた<code>ReaderT</code>、<code>WriterT</code>、<code>ErrorT</code>変換子についても、同じことが成り立っています。<code>purescript-transformers</code>では、それらの操作をサポートするモナドの上に抽象化することを可能にする、主な変換子それぞれについての型クラスが定義されています。</p>
<p>上の<code>split</code>関数の場合、構築されたこのモナドスタックは型クラス<code>MonadState</code>、<code>MonadWriter</code>、<code>MonadError</code>それぞれのインスタンスです。これはつまり、<code>lift</code>をまったく呼び出す必要がないことを意味します！まるでモナドスタック自体に定義されていたかのように、アクション <code>get</code>、<code>put</code>、 <code>tell</code>、<code>throwError</code>をそのまま使用することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">split ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
split <span class="fu">=</span> <span class="kw">do</span>
  s <span class="ot">&lt;-</span> get
  tell [<span class="st">&quot;The state is &quot;</span> <span class="fu">++</span> show s]
  <span class="kw">case</span> s <span class="kw">of</span>
    <span class="st">&quot;&quot;</span> <span class="ot">-&gt;</span> throwError <span class="st">&quot;Empty string&quot;</span>
    _ <span class="ot">-&gt;</span> <span class="kw">do</span>
      put (drop <span class="dv">1</span> s)
      return (take <span class="dv">1</span> s)</code></pre>
<p>この計算はまるで、可変状態、ロギング、エラー処理という３つの副作用に対応した、独自のプログラミング言語を拡張したかのようにみえます。しかしながら、内部的にはすべてはあくまで純粋な関数と普通のデータを使って実装されているのです。</p>
<h2 id="alternative型クラス"><span class="header-section-number">11.11</span> Alternative型クラス</h2>
<p><code>purescript-control</code>パッケージでは失敗しうる計算を操作するための抽象化がいくつか定義されています。そのひとつは <code>Alternative</code>型クラスです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Functor</span> f) <span class="fu">&lt;=</span> <span class="dt">Alt</span> f <span class="kw">where</span>
<span class="ot">  (&lt;|&gt;) ::</span> forall a<span class="fu">.</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a

<span class="kw">class</span> (<span class="dt">Alt</span> f) <span class="fu">&lt;=</span> <span class="dt">Plus</span> f <span class="kw">where</span>
<span class="ot">  empty ::</span> forall a<span class="fu">.</span> f a
  
<span class="kw">class</span> (<span class="dt">Applicative</span> f, <span class="dt">Plus</span> f) <span class="fu">&lt;=</span> <span class="dt">Alternative</span> f <span class="kw">where</span></code></pre>
<p><code>Alternative</code> は、失敗しうる計算のプロトタイプを提供する <code>empty</code>値、 エラーが起きたときに<strong>代替</strong>(Alternative)計算へ戻ってやり直す機能を提供する<code>&lt;|&gt;</code>演算子 という、2つの新しいコンビネータを提供しています。</p>
<p><code>Control.Alternative</code>モジュールでは<code>Alternative</code>型クラスで型構築子を操作する2つの便利な関数を提供します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">many ::</span> forall f a<span class="fu">.</span> (<span class="dt">Alternative</span> f, <span class="dt">Lazy1</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f [a]
<span class="ot">some ::</span> forall f a<span class="fu">.</span> (<span class="dt">Alternative</span> f, <span class="dt">Lazy1</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f [a]</code></pre>
<p><code>many</code>コンビネータは計算を<strong>ゼロ回以上</strong>繰り返し実行するために<code>Alternative</code>型クラスを使用しています。<code>some</code>コンビネータも似ていますが、成功するために少なくとも１回の計算を必要とします。</p>
<p>今回の<code>Parser</code>モナド変換子スタックの場合は、<code>ErrorT</code>コンポーネントから導かれた、明らかな方法で失敗をサポートする、<code>Alternative</code>のインスタンスが存在します。これは、構文解析器を複数回実行するために <code>many</code>関数と<code>some</code>関数を使うことができることを意味します。</p>
<pre class="text"><code>&gt; :i Split
&gt; :i Control.Alternative

&gt; runParser (many split) &quot;test&quot;
  
Right (Tuple (Tuple [&quot;t&quot;, &quot;e&quot;, &quot;s&quot;, &quot;t&quot;] &quot;&quot;) 
             [ &quot;The state is \&quot;test\&quot;&quot;
             , &quot;The state is \&quot;est\&quot;&quot;
             , &quot;The state is \&quot;st\&quot;&quot;
             , &quot;The state is \&quot;t\&quot;&quot;
             ])</code></pre>
<p>ここで、入力文字列<code>&quot;test&quot;</code>は、１文字の文字列４つの配列を返すように、繰り返し分割されています。残った状態は空文字列で、ログは<code>split</code>コンビネータが４回適用されたことを示しています。</p>
<p><code>Alternative</code>型構築子の他の例としては、<code>Maybe</code>や、<code>[]</code>つまり配列の型構築子があります。</p>
<h2 id="モナド内包表記"><span class="header-section-number">11.12</span> モナド内包表記</h2>
<p><code>Control.MonadPlus</code>モジュールには<code>MonadPlus</code>と呼ばれる<code>Alternative</code>型クラスの若干の変形が定義されています。<code>MonadPlus</code>はモナドと<code>Alternative</code>のインスタンスの両方である型構築子を補足します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Monad</span> m, <span class="dt">Alternative</span> m) <span class="fu">&lt;=</span> <span class="dt">MonadPlus</span> m</code></pre>
<p>実際、<code>Parser</code>モナドは<code>MonadPlus</code>のインスタンスです。</p>
<p>以前に本書中で配列の内包表記を扱ったとき、不要な結果をフィルタリングするため使われる<code>guard</code>関数を導入しました。実際は<code>guard</code>関数はもっと一般的で、<code>MonadPlus</code>のインスタンスであるすべてのモナドに対して使うことができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">guard ::</span> forall m<span class="fu">.</span> (<span class="dt">MonadPlus</span> m) <span class="ot">=&gt;</span> <span class="dt">Boolean</span> <span class="ot">-&gt;</span> m <span class="dt">Unit</span></code></pre>
<p><code>&lt;|&gt;</code>演算子は失敗時のバックトラッキングをできるようにします。これがどのように役立つかを見るために、大文字だけに適合する<code>split</code>コンビネータの亜種を定義してみましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">upper ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
upper <span class="fu">=</span> <span class="kw">do</span>
  s <span class="ot">&lt;-</span> split
  guard <span class="fu">$</span> toUpper s <span class="fu">==</span> s
  return s</code></pre>
<p>ここで、文字列が大文字でない場合に失敗するよう <code>guard</code>を使用しています。このコードは前に見た配列内包表記とよく似ていることに注目してください。このように<code>MonadPlus</code>が使われており<strong>モナド内包表記</strong>(monad comprehensions)を構築するために参照することがあります。</p>
<h2 id="バックトラッキング"><span class="header-section-number">11.13</span> バックトラッキング</h2>
<p><code>&lt;|&gt;</code>演算子を使うと、失敗したときに別の代替計算へとバックトラックすることができます。これを確かめるために、小文字に一致するもう一つの構文解析器を定義してみましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lower ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
lower <span class="fu">=</span> <span class="kw">do</span>
  s <span class="ot">&lt;-</span> split
  guard <span class="fu">$</span> toLower s <span class="fu">==</span> s
  return s</code></pre>
<p>これにより、まずもし最初の文字が大文字なら複数の大文字に適合し、さもなくばもし最初の文字が小文字なら複数の小文字に適合する、という構文解析器を定義することができます。</p>
<pre class="text"><code>&gt; let upperOrLower = some upper &lt;|&gt; some lower</code></pre>
<p>この構文解析器は、大文字と小文字が切り替わるまで、文字に適合し続けます。</p>
<pre class="text"><code>&gt; runParser upperOrLower &quot;abcDEF&quot;

Right (Tuple (Tuple [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] (&quot;DEF&quot;)) 
             [ &quot;The state is \&quot;abcDEF\&quot;&quot;,
             , &quot;The state is \&quot;bcDEF\&quot;&quot;
             , &quot;The state is \&quot;cDEF\&quot;&quot;
             ])</code></pre>
<p><code>many</code>を使うと、文字列を小文字と大文字の要素に完全に分割することもできます。</p>
<pre class="text"><code>&gt; let components = many upperOrLower

&gt; runParser components &quot;abCDeFgh&quot;
  
Right (Tuple (Tuple [[&quot;a&quot;,&quot;b&quot;],[&quot;C&quot;,&quot;D&quot;],[&quot;e&quot;],[&quot;F&quot;],[&quot;g&quot;,&quot;h&quot;]] &quot;&quot;) 
             [ &quot;The state is \&quot;abCDeFgh\&quot;&quot;
             , &quot;The state is \&quot;bCDeFgh\&quot;&quot;
             , &quot;The state is \&quot;CDeFgh\&quot;&quot;
             , &quot;The state is \&quot;DeFgh\&quot;&quot;
             , &quot;The state is \&quot;eFgh\&quot;&quot;
             , &quot;The state is \&quot;Fgh\&quot;&quot;
             , &quot;The state is \&quot;gh\&quot;&quot;
             , &quot;The state is \&quot;h\&quot;&quot;
             ])</code></pre>
<p>繰り返しになりますが、これはモナド変換子がもたらす再利用性の威力を示しています。標準的な抽象化を再利用することで、バックトラック構文解析器を宣言型のスタイルでわずか数行のコードで書くことができました！</p>
<blockquote>
<h2 id="演習-34" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単) <code>string</code>構文解析器の実装から<code>lift</code>関数の呼び出しを取り除いてください。新しい実装の型が整合していることを確認し、そうでなることをよく納得しておきましょう。</p></li>
<li><p>(やや難しい) <code>string</code>構文解析器と<code>many</code>コンビネータを使って、文字列<code>&quot;a&quot;</code>の連続と、それに続く文字列<code>&quot;b&quot;</code>の連続からなる文字列を認識する構文解析器を書いてください。</p></li>
<li><p>(やや難しい) <code>&lt;|&gt;</code>演算子を使って、文字<code>a</code>と文字<code>b</code>が任意の順序で現れるような文字列を認識する構文解析器を書いてください。</p></li>
<li><p>(難しい) <code>Parser</code>モナドは次のように定義されるかもしれません。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Parser</span> <span class="fu">=</span> <span class="dt">ErrorT</span> <span class="dt">String</span> (<span class="dt">StateT</span> <span class="dt">String</span> (<span class="dt">WriterT</span> [<span class="dt">String</span>] <span class="dt">Identity</span>))</code></pre>
<p>このように変更すると、構文解析関数にどのような影響を与えるでしょうか。</p></li>
</ol>
</blockquote>
<h2 id="rwsモナド"><span class="header-section-number">11.14</span> RWSモナド</h2>
<p>モナド変換子のある特定の組み合わせは、<code>purescript-transformers</code>パッケージ内の単一のモナド変換子として提供されるのが一般的です。<code>Reader</code>、<code>Writer</code>、<code>State</code>のモナドは、<strong>Reader-Writer-State</strong>モナド(<code>RWS</code>モナド)へと結合されます。このモナドは <code>RWST</code>モナド変換子と呼ばれる、対応するモナド変換子を持っています。</p>
<p>ここでは<code>RWS</code>モナドを使ってテキストアドベンチャーゲームの処理を設計していきます。</p>
<p><code>RWS</code>モナドは(戻り値の型に加えて)3つの型変数で定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">RWS</span> r w s <span class="fu">=</span> <span class="dt">RWST</span> r w s <span class="dt">Identity</span></code></pre>
<p>副作用を提供しない<code>Identity</code>にベースモナドを設定することで、<code>RWS</code>モナドが独自のモナド変換子の観点から定義されていることに注意してください。</p>
<p>第1型引数<code>r</code>は大域的な設定の型を表します。第2型引数<code>w</code>はログを蓄積するために使用するモノイド、第3型引数<code>s</code>は可変状態の型を表しています。</p>
<p>このゲームの場合には、大域的な設定は<code>Data.GameEnvironment</code>モジュールの<code>GameEnvironment</code>と呼ばれる型で定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">PlayerName</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="kw">newtype</span> <span class="dt">GameEnvironment</span> <span class="fu">=</span> <span class="dt">GameEnvironment</span>
  {<span class="ot"> playerName    ::</span> <span class="dt">PlayerName</span>
  ,<span class="ot"> debugMode     ::</span> <span class="dt">Boolean</span>
  }</code></pre>
<p><code>GameEnvironment</code>では、プレイヤー名と、ゲームがデバッグモードで動作しているか否かを示すフラグが定義されています。これらのオプションは、モナド変換子を実行するときにコマンドラインから設定されます。</p>
<p>可変状態は<code>Data.GameState</code>モジュールの<code>GameState</code>と呼ばれる型で定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span>
<span class="kw">import qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">S</span>

<span class="kw">newtype</span> <span class="dt">GameState</span> <span class="fu">=</span> <span class="dt">GameState</span>
  {<span class="ot"> items       ::</span> <span class="dt">M.Map</span> <span class="dt">Coords</span> (<span class="dt">S.Set</span> <span class="dt">GameItem</span>)
  ,<span class="ot"> player      ::</span> <span class="dt">Coords</span>
  ,<span class="ot"> inventory   ::</span> <span class="dt">S.Set</span> <span class="dt">GameItem</span>
  }</code></pre>
<p><code>Coords</code>データ型は2次元平面の点を表し、<code>GameItem</code>データ型はゲーム内のアイテムです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">GameItem</span> <span class="fu">=</span> <span class="dt">Candle</span> <span class="fu">|</span> <span class="dt">Matches</span></code></pre>
<p><code>GameState</code>型はソートされたマップを表す<code>Map</code>とソートされた集合を表す<code>Set</code>という2つの新しいデータ構造を使っています。<code>items</code>プロパティは、そのゲーム平面上の座標と、ゲームアイテムの集合へのマッピングになっています。<code>player</code>プロパティはプレイヤーの現在の座標を格納しており、<code>inventory</code>プロパティは現在プレイヤーが保有するゲームアイテムの集合です。</p>
<p><code>Map</code>と<code>Set</code>のデータ構造は平衡2-3木を使って実装されており、<code>Ord</code>型クラス内の任意の型をキーとして使用することができます。これは今回のデータ構造のキーが完全に順序付けできることを意味します。</p>
<p>ゲームのアクションを書くために、<code>Map</code>と<code>Set</code>構造がどのように使っていくのかを見ていきましょう。</p>
<p>ログとしては<code>[String]</code>モノイドを使います。<code>RWS</code>を使って<code>Game</code>モナドのための型同義語を定義しておきます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Log</span> <span class="fu">=</span> [<span class="dt">String</span>]

<span class="kw">type</span> <span class="dt">Game</span> <span class="fu">=</span> <span class="dt">RWS</span> <span class="dt">GameEnvironment</span> <span class="dt">Log</span> <span class="dt">GameState</span></code></pre>
<h2 id="ゲームロジックの実装"><span class="header-section-number">11.15</span> ゲームロジックの実装</h2>
<p>今回は、<code>Reader</code>モナド、<code>Writer</code>モナド、<code>State</code>モナドのアクションを再利用し、<code>Game</code>モナドで定義されている単純なアクションを組み合わせてゲームを構築していきます。このアプリケーションの最上位では、<code>Game</code>モナドで純粋な計算を実行しており、<code>Eff</code>モナドはコンソールにテキストを出力するような追跡可能な副作用へと結果を変換するために使っています。</p>
<p>このゲームで最も簡単なアクションのひとつは<code>has</code>アクションです。このアクションはプレイヤーの持ち物に特定のゲームアイテムが含まれているかどうかを調べます。これは次のように定義されます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">has ::</span> <span class="dt">GameItem</span> <span class="ot">-&gt;</span> <span class="dt">Game</span> <span class="dt">Boolean</span>
has item <span class="fu">=</span> <span class="kw">do</span>
  <span class="dt">GameState</span> state <span class="ot">&lt;-</span> get
  return <span class="fu">$</span> item <span class="ot">`S.member`</span> state<span class="fu">.</span>inventory</code></pre>
<p>この関数は、現在のゲームの状態を読み取るために<code>Monad.State</code>型クラスで定義されている<code>get</code>アクションを使っており、指定した<code>GameItem</code>が持ち物の<code>Set</code>のなかに出現するかどうかを調べるために<code>Data.Set</code>で定義されている<code>member</code>関数を使っています。</p>
<p>他にも<code>pickUp</code>アクションがあります。現在の位置にゲームアイテムがある場合、プレイヤーの持ち物にそのアイテムを追加します。これには<code>MonadWriter</code>と<code>MonadState</code>型クラスのアクションを使っています。まず、現在のゲームの状態を読み取ります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pickUp ::</span> <span class="dt">GameItem</span> <span class="ot">-&gt;</span> <span class="dt">Game</span> <span class="dt">Unit</span>
pickUp item <span class="fu">=</span> <span class="kw">do</span>
  <span class="dt">GameState</span> state <span class="ot">&lt;-</span> get</code></pre>
<p>次に<code>pickUp</code>は現在の位置にあるアイテムの集合を検索します。これは<code>Data.Map</code>で定義された <code>lookup</code>関数を使って行います。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">case</span> state<span class="fu">.</span>player <span class="ot">`M.lookup`</span> state<span class="fu">.</span>items <span class="kw">of</span></code></pre>
<p><code>lookup</code>関数は<code>Maybe</code>型構築子で示されたオプショナルな結果を返します。<code>lookup</code>関数は、キーがマップにない場合は<code>Nothing</code>を返し、それ以外の場合は<code>Just</code>構築子で対応する値を返します。</p>
<p>関心があるのは、指定されたゲームアイテムが対応するアイテムの集合に含まれている場合です。<code>member</code>関数を使うとこれを調べることができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="dt">Just</span> items <span class="fu">|</span> item <span class="ot">`S.member`</span> items <span class="ot">-&gt;</span> <span class="kw">do</span></code></pre>
<p>この場合、<code>put</code>を使ってゲームの状態を更新し、<code>tell</code>を使ってログにメッセージを追加します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">      <span class="kw">let</span> newItems <span class="fu">=</span> M.update (<span class="dt">Just</span> <span class="fu">&lt;&lt;&lt;</span> S.delete item) state<span class="fu">.</span>player state<span class="fu">.</span>items
          newInventory <span class="fu">=</span> S.insert item state<span class="fu">.</span>inventory
      put <span class="fu">$</span> <span class="dt">GameState</span> state { items     <span class="fu">=</span> newItems
                            , inventory <span class="fu">=</span> newInventory
                            }
      tell [<span class="st">&quot;You now have the &quot;</span> <span class="fu">++</span> show item]</code></pre>
<p>ここで、<code>MonadState</code>と<code>MonadWriter</code>の両方について<code>Game</code>モナド変換子スタックについての適切なインスタンスが存在するので、２つの計算はどちらも<code>lift</code>は必要ないことに注意してください。</p>
<p><code>put</code>の引数では、レコード更新を使ってゲームの状態の<code>items</code>と<code>inventory</code>フィールドを変更しています。特定のキーの値を変更するには<code>Data.Map</code>の<code>update</code>関数を使います。このとき、<code>delete</code>関数を使い指定したアイテムを集合から取り除くことで、 プレイヤーの現在の位置にあるアイテムの集合を変更します。</p>
<p>最後に、<code>pickUp</code>関数は<code>tell</code>を使ってユーザに次のように通知することにより、残りの場合を処理します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    _ <span class="ot">-&gt;</span> tell [<span class="st">&quot;I don&#39;t see that item here.&quot;</span>]</code></pre>
<p><code>Reader</code>モナドを使う例として、<code>debug</code>コマンドのコードを見てみましょう。ゲームがデバッグモードで実行されている場合、このコマンドを使うとユーザは実行時にゲームの状態を調べることができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="dt">GameEnvironment</span> env <span class="ot">&lt;-</span> ask
  <span class="kw">if</span> env<span class="fu">.</span>debugMode
    <span class="kw">then</span> <span class="kw">do</span>
      state <span class="ot">&lt;-</span> get
      tell [show state]
    <span class="kw">else</span> tell [<span class="st">&quot;Not running in debug mode.&quot;</span>] </code></pre>
<p>ここでは、ゲームの設定を読み込むために<code>ask</code>アクションを使用しています。繰り返しますが、どんな計算の<code>lift</code>も必要なく、同じdo記法ブロック内で<code>MonadState</code>、<code>MonadReader</code>、<code>MonadWriter</code>型クラスで定義されているアクションを使うことができることに注意してください。</p>
<p><code>debugMode</code>フラグが設定されている場合、<code>tell</code>アクションを使ってログに状態が追加されます。そうでなければ、エラーメッセージが追加されます。</p>
<p><code>Game.purs</code>モジュールでは、<code>MonadState</code>型クラス、<code>MonadReader</code>型クラス、<code>MonadWriter</code>型クラスでそれぞれ定義されたアクションだけを使って、同様のアクションが定義されています。</p>
<h2 id="計算の実行"><span class="header-section-number">11.16</span> 計算の実行</h2>
<p>このゲームロジックは<code>RWS</code>モナドで動くため、ユーザのコマンドに応答するためには計算を実行する必要があります。</p>
<p>このゲームのフロントエンドは、<code>yargs</code>コマンドライン構文解析ライブラリへのApplicativeなインターフェイスを提供する<code>purescript-yargs</code>パッケージと、対話的なコンソールベースのアプリケーションを書くことを可能にするNodeJSの<code>readline</code>モジュールをラップする<code>purescript-node-readline</code>パッケージという２つのパッケージで構成されています。</p>
<p>このゲームロジックへのインタフェースは<code>Game</code>モジュール内の関数<code>game</code>によって提供されます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">game ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Game</span> <span class="dt">Unit</span></code></pre>
<p>この計算を実行するには、ユーザが入力した単語のリストを文字列の配列として渡してから、<code>runRWS</code>を使って<code>RWS</code>の計算を実行します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">See</span> s a w <span class="fu">=</span> {<span class="ot"> log ::</span> w,<span class="ot"> result ::</span> a,<span class="ot"> state ::</span> s }

<span class="ot">runRWS ::</span> forall r w s a<span class="fu">.</span> <span class="dt">RWS</span> r w s a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">See</span> s a w</code></pre>
<p><code>runRWS</code>は<code>runReader</code>、<code>runWriter</code>、<code>runState</code>を組み合わせたように見えます。これは、引数として大域的な設定および初期状態をとり、ログ、結果、最的な終状態を含むレコードを返します。</p>
<p>このアプリケーションのフロントエンドは、次の型シグネチャを持つ関数 <code>runGame</code>によって定義されます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runGame ::</span> <span class="dt">GameEnvironment</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">console ::</span> <span class="dt">Console</span>,<span class="ot"> trace ::</span> <span class="dt">Trace</span>) <span class="dt">Unit</span></code></pre>
<p><code>Console</code>作用は、この関数が<code>purescript-node-readline</code>パッケージを使ってコンソールを介してユーザと対話することを示しています。<code>runGame</code>は関数の引数としてのゲームの設定とります。</p>
<p><code>purescript-node-readline</code>パッケージでは、端末からのユーザ入力を扱う<code>Eff</code>モナドのアクションを表す<code>LineHandler</code>型が提供されています。対応するAPIは次のとおりです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">LineHandler</span> eff <span class="fu">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> eff <span class="dt">Unit</span>

<span class="ot">setLineHandler ::</span> forall eff<span class="fu">.</span> <span class="dt">LineHandler</span> eff <span class="ot">-&gt;</span> 
                              <span class="dt">Interface</span> <span class="ot">-&gt;</span> 
                              <span class="dt">Eff</span> (<span class="ot">console ::</span> <span class="dt">Console</span> <span class="fu">|</span> eff) <span class="dt">Interface</span></code></pre>
<p><code>Interface</code>型はコンソールのハンドルを表しており、コンソールと対話する関数への引数として渡されます。<code>createInterface</code>関数を使用すると<code>Interface</code>を作成することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">runGame env <span class="fu">=</span> <span class="kw">do</span>
  interface <span class="ot">&lt;-</span> createInterface process<span class="fu">.</span>stdin process<span class="fu">.</span>stdout noCompletion</code></pre>
<p>最初の手順はコンソールにプロンプトを設定することです。<code>interface</code>ハンドルを渡し、プロンプト文字列とインデントレベルを提供します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">setPrompt <span class="st">&quot;&gt; &quot;</span> <span class="dv">2</span> interface</code></pre>
<p>今回の場合、ラインハンドラ関数を実装することに関心があります。ラインハンドラは<code>let</code>宣言内の補助関数を使って次のように定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lineHandler ::</span> <span class="dt">GameState</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">console ::</span> <span class="dt">Console</span>,<span class="ot"> trace ::</span> <span class="dt">Trace</span>) <span class="dt">Unit</span>
lineHandler currentState input <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> result <span class="fu">=</span> runRWS (game (split <span class="st">&quot; &quot;</span> input)) env currentState
  foreachE result<span class="fu">.</span>log trace
  setLineHandler (lineHandler result<span class="fu">.</span>state) interface
  prompt interface
  return unit</code></pre>
<p><code>lineHandler</code>では<code>env</code>という名前のゲーム構成や、<code>interface</code>という名前のコンソールハンドルを参照しています。</p>
<p>このハンドラは追加の最初の引数としてゲームの状態を取ります。ゲームのロジックを実行するために<code>runRWS</code>にゲームの状態を渡さなければならないので、これは必要となっています。</p>
<p>このアクションが最初に行うことは、<code>Data.String</code>モジュールの<code>split</code>関数を使用して、ユーザーの入力を単語に分割することです。それから、ゲーム環境と現在のゲームの状態を渡し、<code>runRWS</code>を使用して(<code>RWS</code>モナドで)<code>game</code>アクションを実行しています。</p>
<p>純粋な計算であるゲームロジックを実行し、画面にすべてのログメッセージを出力して、ユーザに次のコマンドのプロンプトを表示する必要があります。<code>foreachE</code>アクションは(<code>[String]</code>型の)ログを走査し、コンソールにその内容を出力するために使われています。そして<code>setLineHandler</code>を使ってラインハンドラ関数を更新することで、ゲームの状態を更新します。最後に<code>prompt</code>アクションを使ってプロンプトが再び表示しています。</p>
<p><code>runGame</code>関数ではコンソールインターフェイスに最初のラインハンドラを設定して、最初のプロンプトを表示します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  setLineHandler (lineHandler initialGameState) interface
  prompt interface</code></pre>
<blockquote>
<h2 id="演習-35" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(やや難しい) ゲームフィールド上にあるすべてのゲームアイテムをユーザの持ちものに移動する新しいコマンド<code>cheat</code>を実装してください。</p></li>
<li><p>(難しい) 今のところ<code>WriteT</code>モナド変換子は、エラーメッセージと情報メッセージの２つの種類のメッセージのために使われています。このため、コードのいくつかの箇所では、エラーの場合を扱うためにcase式を使用しています。</p>
<p>エラーメッセージを扱うのに<code>ErrorT</code>モナド変換子を使い、情報メッセージを扱うのに<code>WriteT</code>を使うように、コードをリファクタリングしてください。</p></li>
</ol>
</blockquote>
<h2 id="コマンドラインオプションの扱い"><span class="header-section-number">11.17</span> コマンドラインオプションの扱い</h2>
<p>このアプリケーションの最後の部品は、コマンドラインオプションの解析と<code>GameEnvironment</code>レコードを作成する役目にあります。このためには<code>purescript-yargs</code>パッケージを使用します。</p>
<p><code>purescript-yargs</code>は<strong>Applicativeなコマンドラインオプション構文解析器</strong>の例です。Applicative関手を使うと、いろいろな副作用の型を表す型構築子まで任意個数の引数の関数をを持ち上げられることを思い出してください。<code>purescript-yargs</code>パッケージの場合には、コマンドラインオプションからの読み取りの副作用を追加する<code>Y</code>関手が興味深い関手になっています。これは次のようなハンドラを提供しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runY ::</span> forall a eff<span class="fu">.</span> <span class="dt">YargsSetup</span> <span class="ot">-&gt;</span> 
                      <span class="dt">Y</span> (<span class="dt">Eff</span> eff a) <span class="ot">-&gt;</span> 
                      <span class="dt">Eff</span> (<span class="ot">console ::</span> <span class="dt">Console</span>,<span class="ot"> err ::</span> <span class="dt">Exception</span> <span class="fu">|</span> eff) a</code></pre>
<p>この関数の使いかたは、例で示すのが最も適しているでしょう。このアプリケーションの<code>main</code>関数は<code>runY</code>を使って次のように定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> runY (usage <span class="st">&quot;$0 -p &lt;player name&gt;&quot;</span>) <span class="fu">$</span> runGame <span class="fu">&lt;$&gt;</span> env</code></pre>
<p>最初の引数は<code>yargs</code>ライブラリを設定するために使用されます。今回の場合、使用方法のメッセージだけを提供していますが、<code>Node.Yargs.Setup</code>モジュールには他にもいくつかのオプションを提供しています。</p>
<p>2番目の引数では、<code>Y</code>型構築子まで<code>runGame</code>関数を持ち上げるために<code>&lt;$&gt;</code>コンビネータを使用しています。引数<code>env</code>は<code>where</code>節でApplicative演算子<code>&lt;$&gt;</code>、<code>&lt;*&gt;</code>を使って構築されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">where</span>
<span class="ot">  env ::</span> <span class="dt">Y</span> <span class="dt">GameEnvironment</span>
  env <span class="fu">=</span> gameEnvironment
          <span class="fu">&lt;$&gt;</span> yarg <span class="st">&quot;p&quot;</span> [<span class="st">&quot;player&quot;</span>] 
                   (<span class="dt">Just</span> <span class="st">&quot;Player name&quot;</span>) 
                   (<span class="dt">Right</span> <span class="st">&quot;The player name is required&quot;</span>) 
                   false
          <span class="fu">&lt;*&gt;</span> flag <span class="st">&quot;d&quot;</span> [<span class="st">&quot;debug&quot;</span>]
                   (<span class="dt">Just</span> <span class="st">&quot;Use debug mode&quot;</span>)</code></pre>
<p><code>PlayerName -&gt; Boolean -&gt; GameEnvironment</code>という型を持つこの<code>gameEnvironment</code>関数は、<code>Y</code>まで持ち上げられています。このふたつの引数は、コマンドラインオプションからプレイヤー名とデバッグフラグを読み取る方法を指定しています。最初の引数は<code>-p</code>もしくは<code>--player</code>オプションで指定されるプレイヤー名オプションについて記述しており、２つ目の引数は<code>-d</code>もしくは<code>--debug</code>オプションで指定されるデバッグモードフラグについて記述しています。</p>
<p>これは <code>Node.Yargs.Applicative</code>モジュールで定義されているふたつの基本的な関数について示しています。<code>yarg</code>は(型<code>String</code>、<code>Number</code>、<code>Boolean</code>の)オプショナルな引数を取りコマンドラインオプションを定義し、<code>flag</code>は型<code>Boolean</code>のコマンドラインフラグを定義しています。</p>
<p>Applicative演算子によるこの記法を使うことで、コマンドラインインターフェイスに対してコンパクトで宣言的な仕様を与えることが可能になったことに注意してください。また、<code>env</code>の定義で<code>runGame</code>関数に新しい引数を追加し、<code>&lt;*&gt;</code>を使って追加の引数まで<code>runGame</code>を持ち上げるだけで、簡単に新しいコマンドライン引数を追加することができます。</p>
<blockquote>
<h2 id="演習-36" class="unnumbered">演習</h2>
<ol type="1">
<li>(やや難しい) <code>GameEnvironment</code>レコードに新しい真偽値のプロパティ<code>cheatMode</code>を追加してください。 また、<code>yargs</code>設定に、チートモードを有効にする新しいコマンドラインフラグ<code>-c</code>を追加してください。チートモードが有効になっていない場合、<code>cheat</code>コマンドは禁止されなければなりません。</li>
</ol>
</blockquote>
<h2 id="まとめ-9"><span class="header-section-number">11.18</span> まとめ</h2>
<p>モナド変換子を使用したゲームの純粋な定義、コンソールを使用したフロントエンドを構築するための<code>Eff</code>モナドなと、この章ではこれまで学んできた手法を実用的に使いました。</p>
<p>ユーザインターフェースからの実装を分離したので、ゲームの別のフロントエンドを作成することも可能でしょう。例えば、<code>Eff</code>モナドでCanvas APIやDOMを使用して、ブラウザでゲームを描画するようなことができるでしょう。</p>
<p>モナド変換子によって、型システムによって作用が追跡される命令型のスタイルで、安全なコードを書くことができることを見てきました。また、型クラスは、コードの再利用を可能にするモナドによって提供される、アクション上の抽象化の強力な方法を提供します。標準的なモナド変換子を組み合わせることにより、<code>Alternative</code>や<code>MonadPlus</code>のような標準的な抽象化を使用して、役に立つモナドを構築することができました。</p>
<p>モナド変換子は、高階多相や多変数型クラスなどの高度な型システムの機能を利用することによって記述することができ、表現力の高いコードの優れた実演となっています。</p>
<p>次の章では、非同期なJavaScriptのコードにありがちな不満、<strong>コールバック地獄</strong>の問題に対して、モナド変換子がどのような洗練された解決策を与えるのかを見ていきます。</p>
<h1 id="コールバック地獄"><span class="header-section-number">12</span> コールバック地獄</h1>
<h2 id="この章の目標-9"><span class="header-section-number">12.1</span> この章の目標</h2>
<p>この章では、これまでに見てきたモナド変換子やApplicative関手といった道具が、現実世界の問題解決にどのように役立つかを見ていきましょう。ここでは特に、<strong>コールバック地獄</strong>(callback hell)の問題を解決について見ていきます。</p>
<h2 id="プロジェクトの準備-9"><span class="header-section-number">12.2</span> プロジェクトの準備</h2>
<p>この章のソースコードは、<code>grunt</code>でコンパイルし、NodeJSを使って実行することができます。</p>
<h2 id="問題"><span class="header-section-number">12.3</span> 問題</h2>
<p>通常、JavaScriptの非同期処理コードでは、プログラムの流れを構造化するために<strong>コールバック</strong>(callbacks)を使用します。たとえば、ファイルからテキストを読み取るのに好ましいアプローチとしては、<code>readFile</code>関数を使用し、コールバック、つまりテキストが利用可能になったときに呼び出される関数を渡すことです。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">readText</span>(onSuccess, onFailure) {
  <span class="kw">var</span> fs = <span class="fu">require</span>(<span class="st">&#39;fs&#39;</span>);
  <span class="ot">fs</span>.<span class="fu">readFile</span>(<span class="st">&#39;file1.txt&#39;</span>, { <span class="dt">encoding</span>: <span class="st">&#39;utf-8&#39;</span> }, <span class="kw">function</span> (error, data) {
    <span class="kw">if</span> (error) {
      <span class="fu">onFailure</span>(<span class="ot">error</span>.<span class="fu">code</span>);
    } <span class="kw">else</span> {
      <span class="fu">onSuccess</span>(data);
    }   
  });
}</code></pre>
<p>しかしながら、複数の非同期操作が関与している場合には入れ子になったコールバックを生じることになり、すぐに読めないコードになってしまいます。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">copyFile</span>(onSuccess, onFailure) {
  <span class="kw">var</span> fs = <span class="fu">require</span>(<span class="st">&#39;fs&#39;</span>);
  <span class="ot">fs</span>.<span class="fu">readFile</span>(<span class="st">&#39;file1.txt&#39;</span>, { <span class="dt">encoding</span>: <span class="st">&#39;utf-8&#39;</span> }, <span class="kw">function</span> (error, data1) {
    <span class="kw">if</span> (error) {
      <span class="fu">onFailure</span>(<span class="ot">error</span>.<span class="fu">code</span>);
    } <span class="kw">else</span> {
      <span class="ot">fs</span>.<span class="fu">writeFile</span>(<span class="st">&#39;file2.txt&#39;</span>, data, { <span class="dt">encoding</span>: <span class="st">&#39;utf-8&#39;</span> }, <span class="kw">function</span> (error) {
        <span class="kw">if</span> (error) {
          <span class="fu">onFailure</span>(<span class="ot">error</span>.<span class="fu">code</span>);
        } <span class="kw">else</span> {
          <span class="fu">onSuccess</span>();
        }
      });
    }   
  });
} </code></pre>
<p>この問題に対する解決策のひとつとしては、独自の関数に個々の非同期呼び出しを分割することです。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">writeCopy</span>(data, onSuccess, onFailure) {
  <span class="kw">var</span> fs = <span class="fu">require</span>(<span class="st">&#39;fs&#39;</span>);
  <span class="ot">fs</span>.<span class="fu">writeFile</span>(<span class="st">&#39;file2.txt&#39;</span>, data, { <span class="dt">encoding</span>: <span class="st">&#39;utf-8&#39;</span> }, <span class="kw">function</span> (error) {
    <span class="kw">if</span> (error) {
      <span class="fu">onFailure</span>(<span class="ot">error</span>.<span class="fu">code</span>);
    } <span class="kw">else</span> {
      <span class="fu">onSuccess</span>();
    }
  });
}

<span class="kw">function</span> <span class="fu">copyFile</span>(onSuccess, onFailure) {
  <span class="kw">var</span> fs = <span class="fu">require</span>(<span class="st">&#39;fs&#39;</span>);
  <span class="ot">fs</span>.<span class="fu">readFile</span>(<span class="st">&#39;file1.txt&#39;</span>, { <span class="dt">encoding</span>: <span class="st">&#39;utf-8&#39;</span> }, <span class="kw">function</span> (error, data) {
    <span class="kw">if</span> (error) {
      <span class="fu">onFailure</span>(<span class="ot">error</span>.<span class="fu">code</span>);
    } <span class="kw">else</span> {
      <span class="fu">writeCopy</span>(data, onSuccess, onFailure);
    }   
  });
} </code></pre>
<p>この解決策は一応は機能しますが、いくつか問題があります。</p>
<ul>
<li>上で<code>writeCopy</code>へ<code>data</code>を渡したのと同じ方法で、非同期関数に関数の引数として途中の結果を渡さなければなりません。これは小さな関数についてはうまくいきますが、多くのコールバック関係する場合はデータの依存関係は複雑になることがあり、関数の引数が大量に追加される結果になります。</li>
<li>どんな非同期関数でもコールバック<code>onSuccess</code>と<code>onFailure</code>が引数として定義されるという共通のパターンがありますが、このパターンはソースコードに付随したモジュールのドキュメントに記述することで実施しなければなりません。このパターンを管理するには型システムのほうがよいですし、型システムで使い方を強制しておくほうがいいでしょう。</li>
</ul>
<p>次に、これらの問題を解決するために、これまでに学んだ手法を使用する方法について説明していきます。</p>
<h2 id="継続モナド"><span class="header-section-number">12.4</span> 継続モナド</h2>
<p><code>copyFile</code>の例をFFIを使ってPureScriptへと翻訳していきましょう。PureScriptで書いていくにつれ、計算の構造はわかりやすくなり、<code>purescript-transformers</code>パッケージで定義されている継続モナド変換子<code>ContT</code>が自然に導入されることになるでしょう。</p>
<p>まず、FFIを使って<code>readFile</code>と<code>writeFile</code>に型を与えなくてはなりません。型同義語をいくつかと、ファイル入出力のための作用を定義することから始めましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>data <span class="dt">FS</span> :: !

<span class="kw">type</span> <span class="dt">ErrorCode</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> FilePath <span class="fu">=</span> <span class="dt">String</span></code></pre>
<p><code>readFile</code>はファイル名と2引数のコールバックを引数に取ります。ファイルが正常に読み込まれた場合は、2番目の引数にはファイルの内容が含まれますが、そうでない場合は、最初の引数がエラーを示すために使われます。</p>
<p>今回は<code>readFile</code>を2つのコールバックを引数としてとる関数としてラップすることにします。先ほどの<code>copyFile</code>や<code>writeCopy</code>とまったく同じように、エラーコールバック(<code>onFailure</code>)と結果コールバック(<code>onSuccess</code>)の2つです。簡単のために<code>Data.Function</code>の多引数関数の機能を使うと、このラップされた関数<code>readFileImpl</code>は次のようになるでしょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>readFileImpl
  <span class="st">&quot;function readFileImpl(path, onSuccess, onFailure) {\</span>
<span class="st">  \  return function() {\</span>
<span class="st">  \    require(&#39;fs&#39;).readFile(path, \</span>
<span class="st">  \      { encoding: &#39;utf-8&#39; }, \</span>
<span class="st">  \      function(error, data) {\</span>
<span class="st">  \        if (error) {\</span>
<span class="st">  \          onFailure(error.code)();\</span>
<span class="st">  \        } else {\</span>
<span class="st">  \          onSuccess(data)();\</span>
<span class="st">  \        }\</span>
<span class="st">  \      }\</span>
<span class="st">  \    );\</span>
<span class="st">  \  };\</span>
<span class="st">  \}&quot;</span><span class="ot"> ::</span> forall eff<span class="fu">.</span> <span class="dt">Fn3</span> FilePath
                         (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">fs ::</span> <span class="dt">FS</span> <span class="fu">|</span> eff) <span class="dt">Unit</span>)
                         (<span class="dt">ErrorCode</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">fs ::</span> <span class="dt">FS</span> <span class="fu">|</span> eff) <span class="dt">Unit</span>)
                         (<span class="dt">Eff</span> (<span class="ot">fs ::</span> <span class="dt">FS</span> <span class="fu">|</span> eff) <span class="dt">Unit</span>)</code></pre>
<p><code>readFileImpl</code>はファイルパス、成功時のコールバック、失敗時のコールバックという３つの引数を取り、空(<code>Unit</code>)の結果を返す副作用のある計算を返す、ということをこの型は言っています。コー​​ルバック自身にも、その作用を追跡するために<code>Eff</code>モナドを使うような型が与えられていることに注意してください。</p>
<p>この<code>readFileImpl</code>の実装がその型の正しい実行時表現を持っている理由を、よく理解しておくようにしてください。</p>
<p><code>writeFileImpl</code>もよく似ています。違いはファイルがコールバックではなく関数自身に渡されるということだけです。実装は次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>writeFileImpl
  <span class="st">&quot;function writeFileImpl(path, data, onSuccess, onFailure) {\</span>
<span class="st">  \  return function() {\</span>
<span class="st">  \    require(&#39;fs&#39;).writeFile(path, data, \</span>
<span class="st">  \      { encoding: &#39;utf-8&#39; }, \</span>
<span class="st">  \      function(error) {\</span>
<span class="st">  \        if (error) {\</span>
<span class="st">  \          onFailure(error.code)();\</span>
<span class="st">  \        } else {\</span>
<span class="st">  \          onSuccess();\</span>
<span class="st">  \        }\</span>
<span class="st">  \      }\</span>
<span class="st">  \    );\</span>
<span class="st">  \  };\</span>
<span class="st">  \}&quot;</span><span class="ot"> ::</span> forall eff<span class="fu">.</span> <span class="dt">Fn4</span> FilePath
                         <span class="dt">String</span>
                         (<span class="dt">Eff</span> (<span class="ot">fs ::</span> <span class="dt">FS</span> <span class="fu">|</span> eff) <span class="dt">Unit</span>)
                         (<span class="dt">ErrorCode</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">fs ::</span> <span class="dt">FS</span> <span class="fu">|</span> eff) <span class="dt">Unit</span>)
                         (<span class="dt">Eff</span> (<span class="ot">fs ::</span> <span class="dt">FS</span> <span class="fu">|</span> eff) <span class="dt">Unit</span>)</code></pre>
<p>これらのFFIの宣言が与えられれば、<code>readFile</code>と<code>writeFile</code>の実装を書くことができます。<code>Data.Function</code>ライブラリを使って、多引数のFFIバインディングを通常の(カリー化された)PureScript関数へと変換するので、もう少し読みやすい型になるでしょう。</p>
<p>さらに、成功時と失敗時の２つの必須のコールバックに代わって、成功か失敗の<strong>どちらか</strong>(Either) に対応した単一のコールバックを要求するようにします。つまり、新しいコールバックは引数として<code>Either ErrorCode</code>モナドの値をとります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">readFile<span class="ot"> ::</span> forall eff<span class="fu">.</span> 
  FilePath <span class="ot">-&gt;</span> 
  (<span class="dt">Either</span> <span class="dt">ErrorCode</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">fs ::</span> <span class="dt">FS</span> <span class="fu">|</span> eff) <span class="dt">Unit</span>) <span class="ot">-&gt;</span> 
  <span class="dt">Eff</span> (<span class="ot">fs ::</span> <span class="dt">FS</span> <span class="fu">|</span> eff) <span class="dt">Unit</span>
readFile path k <span class="fu">=</span> 
  runFn3 readFileImpl 
         path 
         (k <span class="fu">&lt;&lt;&lt;</span> <span class="dt">Right</span>) 
         (k <span class="fu">&lt;&lt;&lt;</span> <span class="dt">Left</span>)

writeFile<span class="ot"> ::</span> forall eff<span class="fu">.</span> 
  FilePath <span class="ot">-&gt;</span> 
  <span class="dt">String</span> <span class="ot">-&gt;</span> 
  (<span class="dt">Either</span> <span class="dt">ErrorCode</span> <span class="dt">Unit</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">fs ::</span> <span class="dt">FS</span> <span class="fu">|</span> eff) <span class="dt">Unit</span>) <span class="ot">-&gt;</span> 
  <span class="dt">Eff</span> (<span class="ot">fs ::</span> <span class="dt">FS</span> <span class="fu">|</span> eff) <span class="dt">Unit</span>
writeFile path text k <span class="fu">=</span> 
  runFn4 writeFileImpl 
         path 
         text 
         (k <span class="fu">$</span> <span class="dt">Right</span> unit) 
         (k <span class="fu">&lt;&lt;&lt;</span> <span class="dt">Left</span>)</code></pre>
<p><code>Eff</code>モナドはこれらの型シグネチャの両方に現れます。次のような新しい型同義語を導入すると、型を​​簡素化できます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">M</span> eff <span class="fu">=</span> <span class="dt">Eff</span> (<span class="ot">fs ::</span> <span class="dt">FS</span> <span class="fu">|</span> eff)

readFile<span class="ot"> ::</span> forall eff<span class="fu">.</span> 
  FilePath <span class="ot">-&gt;</span> 
  (<span class="dt">Either</span> <span class="dt">ErrorCode</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">M</span> eff <span class="dt">Unit</span>) <span class="ot">-&gt;</span> 
  <span class="dt">M</span> eff <span class="dt">Unit</span>

writeFile<span class="ot"> ::</span> forall eff<span class="fu">.</span> 
  FilePath <span class="ot">-&gt;</span> 
<span class="dt">String</span>
  (<span class="dt">Either</span> <span class="dt">ErrorCode</span> <span class="dt">Unit</span> <span class="ot">-&gt;</span> <span class="dt">M</span> eff <span class="dt">Unit</span>) <span class="ot">-&gt;</span> 
  <span class="dt">M</span> eff <span class="dt">Unit</span></code></pre>
<p>ここで、重要なパターンを見つけることができます。これらの関数は何らかのモナド(この場合は<code>M eff</code>)で値を返すコールバックをとり、<strong>同一のモナド</strong>で値を返します。これは、最初のコールバックが結果を返したときに、そのモナドは次の非同期関数の入力に結合するためにその結果を使用することができることを意味しています。実際、<code>copyFile</code>の例で手作業でやったことがまさにそれです。</p>
<p>これは<code>purescript-transformers</code>の <code>Control.Monad.Cont.Trans</code>モジュールで定義されている<strong>継続モナド変換子</strong>(continuation monad transformer)の基礎となっています。</p>
<p><code>ContT</code>は次のようなnewtypeとして定義されます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ContT</span> r m a <span class="fu">=</span> <span class="dt">ContT</span> ((a <span class="ot">-&gt;</span> m r) <span class="ot">-&gt;</span> m r)</code></pre>
<p><strong>継続</strong>(continuation)はコールバックの別名です。継続は計算の<strong>残余</strong>(remainder)を捕捉します。ここで「残余」とは、非同期呼び出しが行われ、結果が提供された後に起こることを指しています。</p>
<p><code>ContT</code>データ構築子の引数は<code>readFile</code>と<code>writeFile</code>の型ととてもよく似ています。実際、もし型<code>a</code> を型<code>Either ErrorCode String</code>、<code>r</code>を<code>Unit</code>、<code>m</code> をモナド<code>M eff</code>というように選ぶと、<code>readFile</code>の型の右辺を復元することができます。</p>
<p>今回の目的では<code>Eff</code>モナドを変換するために常に<code>ContT</code>を使い、型<code>r</code>は常に<code>Unit</code>になりますが、このことは必須ではありません。</p>
<p><code>ContT</code>構築子を適用するだけで、<code>readFile</code>と<code>writeFile</code>を<code>ContT Unit (M eff)</code>モナドの計算として扱うことができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">C</span> eff <span class="fu">=</span> <span class="dt">ContT</span> <span class="dt">Unit</span> (<span class="dt">M</span> eff)

<span class="ot">readFileCont ::</span> forall eff<span class="fu">.</span> 
  FilePath <span class="ot">-&gt;</span> 
  <span class="dt">C</span> eff (<span class="dt">Either</span> <span class="dt">ErrorCode</span> <span class="dt">String</span>)
readFileCont path <span class="fu">=</span> <span class="dt">ContT</span> <span class="fu">$</span> readFile path

<span class="ot">writeFileCont ::</span> forall eff<span class="fu">.</span> 
  FilePath <span class="ot">-&gt;</span> 
  <span class="dt">String</span> <span class="ot">-&gt;</span> 
  <span class="dt">C</span> eff (<span class="dt">Either</span> <span class="dt">ErrorCode</span> <span class="dt">Unit</span>)
writeFileCont path text <span class="fu">=</span> <span class="dt">ContT</span> <span class="fu">$</span> writeFile path text</code></pre>
<p>ここで<code>ContT</code>モナド変換子に対してdo記法を使うだけで、ファイル複製処理を書くことができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">copyFileCont ::</span> forall eff<span class="fu">.</span> FilePath <span class="ot">-&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">C</span> eff (<span class="dt">Either</span> <span class="dt">ErrorCode</span> <span class="dt">Unit</span>)
copyFileCont src dest <span class="fu">=</span> <span class="kw">do</span>
  e <span class="ot">&lt;-</span> readFileCont src
  <span class="kw">case</span> e <span class="kw">of</span>
    <span class="dt">Left</span> err <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">Left</span> err
    <span class="dt">Right</span> content <span class="ot">-&gt;</span> writeFileCont dest content</code></pre>
<p><code>readFileCont</code>の非同期性がdo記法によってモナドの束縛に隠されていることに注目してください。これはまさに同期的なコードのように見えますが、<code>ContT</code>モナドは非同期関数を書くのを手助けしているのです。</p>
<p>継続を与えて<code>runContT</code>ハンドラを使うと、この計算を実行することができます。この継続は<strong>次に何をするか</strong>、例えば非同期なファイル複製処理が完了した時に何をするか、を表しています。この簡単な例では、型<code>Either ErrorCode Unit</code>の結果をコンソールに出力する<code>print</code>関数を単に継続として選んでいます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Debug.Trace</span>

<span class="kw">import </span><span class="dt">Control.Monad.Eff</span>
<span class="kw">import </span><span class="dt">Control.Monad.Cont.Trans</span>

main <span class="fu">=</span> runContT 
  (copyFileCont <span class="st">&quot;/tmp/1.txt&quot;</span> <span class="st">&quot;/tmp/2.txt&quot;</span>) 
  print</code></pre>
<blockquote>
<h2 id="演習-37" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単) <code>readFileCont</code>と<code>writeFileCont</code>を使って、2つのテキストフ​​ァイルを連結する関数を書いてください。</p></li>
<li><p>(やや難しい) FFIを使って、<code>setTimeout</code>関数に適切な型を与えてください。また、<code>ContT</code>モナド変換子を使った次のようなラッパー関数を書いてください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Milliseconds</span> <span class="fu">=</span> <span class="dt">Number</span>

foreign <span class="kw">import </span>data <span class="dt">Timeout</span> :: !

<span class="ot">setTimeoutCont ::</span> forall eff<span class="fu">.</span> 
  <span class="dt">Milliseconds</span> <span class="ot">-&gt;</span> 
  <span class="dt">ContT</span> <span class="dt">Unit</span> (<span class="dt">Eff</span> (<span class="ot">timeout ::</span> <span class="dt">Timeout</span> <span class="fu">|</span> eff)) <span class="dt">Unit</span></code></pre></li>
</ol>
</blockquote>
<h2 id="errortを機能させる"><span class="header-section-number">12.5</span> ErrorTを機能させる</h2>
<p>この方法はうまく動きますが、まだ改良の余地があります。</p>
<p><code>copyFileCont</code>の実装において、次に何をするかを決定するためには、パターン照合を使って(型<code>Either ErrorCode String</code>の)<code>readFileCont</code>計算の結果を解析しなければなりません。しかしながら、<code>Either</code>モナドは対応するモナド変換子<code>ErrorT</code>を持っていることがわかっているので、<code>ErrorT</code>を使って非同期計算とエラー処理の２つの作用を結合できると期待するのは理にかなっています。</p>
<p>実際にそれは可能で、<code>ErrorT</code>の定義を見ればそれがなぜかがわかります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ErrorT</span> e m a <span class="fu">=</span> <span class="dt">ErrorT</span> (m (<span class="dt">Either</span> e a))</code></pre>
<p><code>ErrorT</code>は基礎のモナドの結果を単純に<code>a</code>から<code>Either e a</code>に変更します。現在のモナドスタックを<code>ErrorT ErrorCode</code>変換子で変換するように、<code>copyFileCont</code>を書き換えることができることを意味します。それは現在の方法に<code>ErrorT</code>データ構築子を適用するだけなので簡単です。型同義語を与えると、ここでも型シグネチャを整理することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">EC</span> eff <span class="fu">=</span> <span class="dt">ErrorT</span> <span class="dt">ErrorCode</span> (<span class="dt">C</span> eff)

<span class="ot">readFileContErr ::</span> forall eff<span class="fu">.</span> FilePath <span class="ot">-&gt;</span> <span class="dt">EC</span> eff <span class="dt">String</span>
readFileContErr path <span class="fu">=</span> <span class="dt">ErrorT</span> <span class="fu">$</span> readFileCont path

<span class="ot">writeFileContErr ::</span> forall eff<span class="fu">.</span> FilePath <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">EC</span> eff <span class="dt">Unit</span>
writeFileContErr path text <span class="fu">=</span> <span class="dt">ErrorT</span> <span class="fu">$</span> writeFileCont path text</code></pre>
<p>非同期エラー処理が<code>ErrorT</code>モナド変換子の内部に隠されているので、このファイル複製処理ははるかに単純になります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">copyFileContErr ::</span> forall eff<span class="fu">.</span> FilePath <span class="ot">-&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">EC</span> eff <span class="dt">Unit</span>
copyFileContErr src dest <span class="fu">=</span> <span class="kw">do</span>
  content <span class="ot">&lt;-</span> readFileContErr src
  writeFileContErr dest content</code></pre>
<blockquote>
<h2 id="演習-38" class="unnumbered">演習</h2>
<ol type="1">
<li>(やや難しい) 任意のエラーを処理するために、<code>ErrorT</code>を使用して2つのファイルを連結しする先ほどの解決策を書きなおしてください。</li>
</ol>
</blockquote>
<h2 id="httpクライアント"><span class="header-section-number">12.6</span> HTTPクライアント</h2>
<p><code>ContT</code>を使って非同期機能を処理する例として、この章のソースコードの<code>Network.HTTP.Client</code>モジュールについても見ていきましょう。このモジュールでは、NodeJSの非同期HTTPリクエストをラップするために継続を使っています。</p>
<p><code>http</code>モジュールを使った典型的な<code>GET</code>リクエストは次のようになります。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">getRequest</span>(onChunk, onComplete) {
  <span class="kw">return</span> <span class="kw">function</span>() {
    <span class="fu">require</span>(<span class="st">&#39;http&#39;</span>).<span class="fu">request</span>({
      <span class="dt">host</span>: <span class="st">&#39;www.purescript.org&#39;</span>,
      <span class="dt">path</span>: <span class="st">&#39;/&#39;</span> 
    }, <span class="kw">function</span>(res) {
      <span class="ot">res</span>.<span class="fu">setEncoding</span>(<span class="st">&#39;utf8&#39;</span>);
      <span class="ot">res</span>.<span class="fu">on</span>(<span class="st">&#39;data&#39;</span>, <span class="kw">function</span> (chunk) {
        <span class="fu">onChunk</span>(chunk);
      });
      <span class="ot">res</span>.<span class="fu">on</span>(<span class="st">&#39;end&#39;</span>, <span class="kw">function</span> () {
        <span class="fu">onComplete</span>();
      });
    }).<span class="fu">end</span>();
  };
}</code></pre>
<p><code>http</code>モジュールの<code>request</code>メソッドは、ホストとパスを指定するオブジェクトをとり、レスポンスオブジェクトを返します。レスポンスオブジェクトは今回扱う2種類のイベントを発します。</p>
<ul>
<li>レスポンスの新しいチャンクが使用可能であることを示す <code>data</code>イベント</li>
<li>レスポンスが完了したことを示す <code>end</code>イベント</li>
</ul>
<p>上の例では、<code>data</code>と<code>end</code>イベントが発生した時に呼び出される2つのコールバック <code>onChunk</code>と<code>onComplete</code>を渡しています。</p>
<p><code>Network.HTTP.Client</code>モジュールでは、 <code>request</code>メソッドは以下のようなAPIを持つ関数<code>getImpl</code>としてラップされています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foreign <span class="kw">import </span>data <span class="dt">HTTP</span> :: !

<span class="kw">type</span> <span class="dt">WithHTTP</span> eff <span class="fu">=</span> <span class="dt">Eff</span> (<span class="ot">http ::</span> <span class="dt">HTTP</span> <span class="fu">|</span> eff)

<span class="kw">newtype</span> <span class="dt">Request</span> <span class="fu">=</span> <span class="dt">Request</span>
  {<span class="ot"> host ::</span> <span class="dt">String</span>
  ,<span class="ot"> path ::</span> <span class="dt">String</span>
  }

<span class="kw">newtype</span> <span class="dt">Chunk</span> <span class="fu">=</span> <span class="dt">Chunk</span> <span class="dt">String</span>

<span class="ot">getImpl ::</span> forall eff<span class="fu">.</span> 
  <span class="dt">Fn3</span> <span class="dt">Request</span>
      (<span class="dt">Chunk</span> <span class="ot">-&gt;</span> <span class="dt">WithHTTP</span> eff <span class="dt">Unit</span>)
      (<span class="dt">WithHTTP</span> eff <span class="dt">Unit</span>)
      (<span class="dt">WithHTTP</span> eff <span class="dt">Unit</span>)</code></pre>
<p>再び<code>Data.Function</code>モジュールを使って、これを通常のカリー化されたPureScript関数に変換します。先ほどと同じように、２つのコールバックを型<code>Maybe Chunk</code>の値を受け入れるひとつのコールバックに変換しています。コールバックに渡された<code>Nothing</code>の値は<code>end</code>イベントに対応しており、<code>Just chunk</code>の値は<code>deta</code>イベントに対応しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getChunk ::</span> forall eff<span class="fu">.</span> 
  <span class="dt">Request</span> <span class="ot">-&gt;</span>
  (<span class="dt">Maybe</span> <span class="dt">Chunk</span> <span class="ot">-&gt;</span> <span class="dt">WithHTTP</span> eff <span class="dt">Unit</span>) <span class="ot">-&gt;</span>
  <span class="dt">WithHTTP</span> eff <span class="dt">Unit</span>
getChunk req k <span class="fu">=</span> 
  runFn3 getImpl 
         req 
         (k <span class="fu">&lt;&lt;&lt;</span> <span class="dt">Just</span>) 
         (k <span class="dt">Nothing</span>)</code></pre>
<p>ここでも<code>ContT</code>データ構築子を適用することにより、この非同期関数をこの継続モナドの演算に変換しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getCont ::</span> forall eff<span class="fu">.</span> 
  <span class="dt">Request</span> <span class="ot">-&gt;</span> 
  <span class="dt">ContT</span> <span class="dt">Unit</span> (<span class="dt">WithHTTP</span> eff) (<span class="dt">Maybe</span> <span class="dt">Chunk</span>)
getCont req <span class="fu">=</span> <span class="dt">ContT</span> <span class="fu">$</span> getChunk req</code></pre>
<p><code>readFile</code>の例では、ファイルの内容が利用可能になったとき(または、エラーが発生したとき)、コールバックは一度だけ呼ばれていました。しかし今度は、レスポンスのそれぞれのチャンクについて１回づつ、複数回コールバックが呼び出されることが期待されます。</p>
<blockquote>
<h2 id="演習-39" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(やや難しい) <code>runContT</code>を使ってHTTP応答の各チャンクをコンソールへ出力することで、<code>getCont</code>を試してみてください。</p></li>
<li><p>(難しい) <code>getImpl</code>と<code>getCont</code>関数は非同期エラーを処理しません。<code>getImpl</code>を<code>error</code>イベントに対応するよう変更し、<code>ErrorT</code>を使って非同期エラーを表現する<code>getCont</code>の亜種を書いてください。</p>
<p><strong>ヒント</strong>： <code>readFile</code>の例で取ったのと同じアプローチに従うことができます。</p></li>
</ol>
</blockquote>
<h2 id="チャンク応答の畳み込み"><span class="header-section-number">12.7</span> チャンク応答の畳み込み</h2>
<p>これでHTTP応答の個々のチャンクを集めることができるようになりましたが、すべての応答が利用可能になったときだけ継続が呼び出される非同期関数を作ると便利な時があるかもしれません。このような関数を実装する方法のひとつは、HTTP応答のチャンクに対する<strong>畳み込み</strong>を書くことです。</p>
<p>継続に渡された複数の結果を畳み込む関数<code>foldC</code>を書きましょう。<code>foldC</code>関数はこの章のソースコードの<code>Control.Monad.Cont.Extras</code>モジュールで定義されています。</p>
<p>累積値を追跡するために、<code>Eff</code>モナドで<code>Ref</code>作用を使います。次の型同義語を使って型シグネチャを整理します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">WithRef</span> eff <span class="fu">=</span> <span class="dt">Eff</span> (<span class="ot">ref ::</span> <span class="dt">Ref</span> <span class="fu">|</span> eff)

<span class="kw">type</span> <span class="dt">ContRef</span> eff <span class="fu">=</span> <span class="dt">ContT</span> <span class="dt">Unit</span> (<span class="dt">WithRef</span> eff)</code></pre>
<p>これらの同義語を使うと、<code>foldC</code>には次のような型を与えることができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foldC ::</span> forall eff a b r<span class="fu">.</span> 
  (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> b r) <span class="ot">-&gt;</span> 
  b <span class="ot">-&gt;</span> <span class="dt">ContRef</span> eff a <span class="ot">-&gt;</span> <span class="dt">ContRef</span> eff r</code></pre>
<p><code>foldC</code>に渡された関数は、現在の累積値と継続に渡された値を受け取り、新しい累積値か新しい継続に渡される結果のどちらかを返します。</p>
<p><code>foldC</code>が実装されれば、応答のデータ本体の様々なチャンクの収集を可能にする簡単な関数<code>collect</code>を書くことができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">collect ::</span> forall eff a<span class="fu">.</span> 
  <span class="dt">ContRef</span> eff (<span class="dt">Maybe</span> a) <span class="ot">-&gt;</span> 
  <span class="dt">ContRef</span> eff [a]
collect <span class="fu">=</span> foldC f []
  <span class="kw">where</span>
  f xs <span class="dt">Nothing</span> <span class="fu">=</span> <span class="dt">Right</span> xs
  f xs (<span class="dt">Just</span> x) <span class="fu">=</span> <span class="dt">Left</span> (xs <span class="fu">++</span> [x])</code></pre>
<p><code>foldC</code>の実装では、累積値の初期値を持つ新しい参照を作成して開始します。この参照は、コールバックの本体でそれが変更されるときに、累積器を追跡し続けるために使用されます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foldC f b0 c <span class="fu">=</span> <span class="kw">do</span>
  current <span class="ot">&lt;-</span> lift <span class="fu">$</span> newRef b0</code></pre>
<p>また、<code>foldC</code>は<strong>現在の継続とともに呼び出す</strong>(call with current continuation)を略して<code>callCC</code>と呼ばれる関数を使っています。<code>callCC</code>は引数として関数をひとつ取りますが、この関数は<strong>現在の継続</strong>、つまり現在のdo記法ブロックの<code>callCC</code>の<strong>あと</strong>のコードを表しています。現在の継続に返り値を渡すと、<code>callCC</code>内のコードのブロックからいつでも早期に返ることができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  callCC <span class="fu">$</span> \k <span class="ot">-&gt;</span> quietly <span class="fu">$</span> <span class="kw">do</span></code></pre>
<p>ここで<code>k</code>は現在の継続です。これは <code>foldC</code>を定義するdo記法ブロックの最後の式であるため、現在の継続は実際には<code>foldC</code>に渡されたちょうどその継続です。畳み込み関数の結果が累積の結果を表しているとき、<code>foldC</code>の最終的な値にこれを使います。</p>
<p><code>quietly</code>コンビネータは<code>where</code>宣言で定義されており、あとでその定義について見ていきます。<code>quietly</code>コンビネータの役目は、ここで明示的に<code>k</code>を呼び出さない場合に、<code>callCC</code>の内側のコードがその継続へ値を返すのを妨げることです。これが必要な理由はすぐに明らかになるはずです。</p>
<p>次に、<code>foldC</code>は非同期関数<code>c</code>の結果を名前<code>a</code>に束縛します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    a <span class="ot">&lt;-</span> c</code></pre>
<p>もとの計算によって新しい値が非同期に生成されたとき(この場合は、HTTP応答の新しいチャンクが利用可能になったとき)、この行の後ろのコードが実行されるでしょう。それが起こるとき、畳み込み関数を適用したいので、次のように累積器の現在の値を読み取る必要があります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    r <span class="ot">&lt;-</span> lift <span class="fu">$</span> readRef current</code></pre>
<p>最後に、畳み込み関数を評価し、その結果に応じて2つの場合に場合分けします。畳み込み関数が新しい累積値を返すなら、参照を新しい値で更新します。畳み込み関数が結果を返すなら、これを継続<code>k</code>に渡します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">case</span> f b a <span class="kw">of</span>
      <span class="dt">Left</span> next <span class="ot">-&gt;</span> lift <span class="fu">$</span> writeRef current next
      <span class="dt">Right</span> r <span class="ot">-&gt;</span> k r</code></pre>
<p>ここで<code>quietly</code>関数が必要だった理由が明らかになったと思います。<code>callCC</code>内部のコードの結果 を<code>quietly</code>関数で黙らせなかったら、畳み込み関数が<code>Left</code>構築子で包んだ値を返すとき、型<code>r</code>の結果を生成しなければならなくなったでしょう。しかし、そのような結果を生成する方法は一切ありません！</p>
<p><code>quietly</code>関数の定義は次のようになっています。<code>quietly</code>は非同期関数の結果の型を変更できるようにします。これは継続関数を変換することを可能にする<code>withContT</code>関数を使って書かれています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">where</span>
<span class="ot">  quietly ::</span> forall m a b<span class="fu">.</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">ContT</span> <span class="dt">Unit</span> m a <span class="ot">-&gt;</span> <span class="dt">ContT</span> <span class="dt">Unit</span> m b
  quietly <span class="fu">=</span> withContT (\_ _ <span class="ot">-&gt;</span> return unit)</code></pre>
<p><code>foldC</code>関数とその亜種<code>collect</code>は特に、チャンクが利用可能になった時に連結することで、完全なHTTP応答本体を累積することを可能にします。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Response</span> <span class="fu">=</span> <span class="dt">Response</span> [<span class="dt">Chunk</span>]

<span class="ot">getAll ::</span> forall eff<span class="fu">.</span> 
  <span class="dt">Request</span> <span class="ot">-&gt;</span> 
  <span class="dt">ContT</span> <span class="dt">Unit</span> (<span class="dt">WithHTTP</span> (<span class="ot">ref ::</span> <span class="dt">Ref</span> <span class="fu">|</span> eff)) <span class="dt">Response</span>
getAll req <span class="fu">=</span> <span class="dt">Response</span> <span class="fu">&lt;$&gt;</span> collect (getCont req)</code></pre>
<p>これで、<code>String</code>として応答本体を次のように取得することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getResponseText ::</span> forall eff<span class="fu">.</span> 
  <span class="dt">Request</span> <span class="ot">-&gt;</span> 
  <span class="dt">ContT</span> <span class="dt">Unit</span> (<span class="dt">WithHTTP</span> (<span class="ot">ref ::</span> <span class="dt">Ref</span> <span class="fu">|</span> eff)) <span class="dt">String</span>
getResponseText req <span class="fu">=</span> responseToString <span class="fu">&lt;$&gt;</span> getAll req
  <span class="kw">where</span>
<span class="ot">  responseToString ::</span> <span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
  responseToString (<span class="dt">Response</span> chunks) <span class="fu">=</span> joinWith <span class="st">&quot;&quot;</span> <span class="fu">$</span> map runChunk chunks</code></pre>
<p>例えば、次のように継続の中で<code>getResponseText</code>と<code>trace</code>アクションを使えば、HTTP応答本体の長さをコンソールに出力することができるでしょう。</p>
<pre class="main"><code>main = runContT (getResponseText request) $ \response -&gt; do
  let responseLength = length response
  trace responseLength
  
  where
  request :: Request
  request = Request
    { host: &quot;www.purescript.org&quot;
    , path: &quot;/&quot;
    }</code></pre>
<p>これはうまく動作しますが、次の演習で見るように、もっと慎重に<code>foldC</code>を使うとこの方法を改良することができます。</p>
<blockquote>
<h2 id="演習-40" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(やや難しい) <code>writeFileCont</code>を使用して、ディスク上のファイルにそのHTTP要求の応答本体を保存する関数を書いてください。</p></li>
<li><p>(難しい) 長さを決定するのに、メモリ内のHTTP応答本体全体を連結する必要はありません。チャンクが利用可能になるたびにそのバイトサイズを調べるようにすれば、応答全体のザイズから単一のチャンクのサイズへと、この関数のメモリ使用量を低減することができます。</p>
<p><code>collect</code>の代わりに<code>foldC</code>を直接使って、このコード例を書きなおしてください。</p></li>
</ol>
</blockquote>
<h2 id="並列計算"><span class="header-section-number">12.8</span> 並列計算</h2>
<p><code>ContT</code>モナドとdo記法を使って、非同期計算を順番に実行されるように合成する方法を見てきました。非同期計算を<strong>並列に</strong>合成することもできたら便利でしょう。</p>
<p><code>Eff</code>モナドを変換するために<code>ContT</code>を使用している場合、単に２つの計算のうち一方を開始した後に他方の計算を開始すれば、並列に計算することができます。</p>
<p>次のような型シグネチャを持つ関数を書きましょう。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">par ::</span> forall a b r eff<span class="fu">.</span> 
  (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> 
  <span class="dt">ContRef</span> eff a <span class="ot">-&gt;</span> <span class="dt">ContRef</span> eff b <span class="ot">-&gt;</span> <span class="dt">ContRef</span> eff r</code></pre>
<p><code>par</code>は、2つの非同期計算とその結果を合成する関数をとり、並列に計算を実行し結果を合成するような単一の計算を返します。</p>
<p>(<code>Ref</code>作用で)変更可能な参照を使い、呼び出された2つの継続を追跡します。両方の結果が返ってきたとき、最終的な結果を計算し、メインの継続に渡すことができます。</p>
<p>直接<code>ContT</code>データ構築子で値を構築すると、<code>par</code>を最も簡単に実装できます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">par f ca cb <span class="fu">=</span> <span class="dt">ContT</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> <span class="kw">do</span></code></pre>
<p>ここで<code>f</code>は合成を行う関数で、<code>ca</code>と <code>cb</code>はそれぞれ型<code>a</code>と<code>b</code>の値を返す非同期的な計算です。<code>k</code>は<code>ca</code>と<code>cb</code>の両方が完了した時に型<code>r</code>の値を返すのに使う継続です。</p>
<p>利用可能になったときに<code>ca</code>と<code>cb</code>の結果を保持するために、2つの新しい参照を作成することから始めます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  ra <span class="ot">&lt;-</span> newRef <span class="dt">Nothing</span>
  rb <span class="ot">&lt;-</span> newRef <span class="dt">Nothing</span></code></pre>
<p>これらの参照<code>ra</code>と<code>rb</code>は、それぞれ型<code>Maybe a</code>と<code>Maybe b</code>の値を保持します。どちらも最初は<code>Nothiing</code>の値が格納されていますが、計算が完了したとき値が更新されます。</p>
<p>次に、<code>runContT</code>を使用して最初の非同期計算を開始します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  runContT ca <span class="fu">$</span> \a <span class="ot">-&gt;</span> <span class="kw">do</span>
    mb <span class="ot">&lt;-</span> readRef rb
    <span class="kw">case</span> mb <span class="kw">of</span>
      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> writeRef ra <span class="fu">$</span> <span class="dt">Just</span> a
      <span class="dt">Just</span> b <span class="ot">-&gt;</span> k (f a b)</code></pre>
<p>第二の値が利用可能であるかどうかを調べるする継続を提供します。そうである場合は、継続 <code>k</code>に最終結果を渡すために結合関数を使用します。そうでなければ、単に最初の値を含むように参照<code>ra</code>を更新します。</p>
<p>ふたつめの計算についても同様です。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  runContT cb <span class="fu">$</span> \b <span class="ot">-&gt;</span> <span class="kw">do</span>
    ma <span class="ot">&lt;-</span> readRef ra
    <span class="kw">case</span> ma <span class="kw">of</span>
      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> writeRef rb <span class="fu">$</span> <span class="dt">Just</span> b
      <span class="dt">Just</span> a <span class="ot">-&gt;</span> k (f a b)</code></pre>
<p><code>par</code>コンビネータを使うと、ふたつのファイルを並列に読んだり、2つのHTTP要求を平行して発行し、並列に結果を待つことができます。</p>
<p>２つのテキストファイルを並列に読み取り、連結してその結果を出力する簡単な例は次のようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Apply</span> (lift2)

main <span class="fu">=</span> flip runContT print <span class="fu">$</span>
  par (lift2 (<span class="fu">++</span>)) (readFileCont <span class="st">&quot;/tmp/1.txt&quot;</span>)
                   (readFileCont <span class="st">&quot;/tmp/2.txt&quot;</span>)</code></pre>
<p><code>readFileCont</code>は型<code>Either ErrorCode String</code>の値を返すので、結合関数を作るには<code>lift2</code>を使って演算子<code>(++)</code>を<code>Either</code>型構築子まで持ち上げなければいけません。</p>
<blockquote>
<h2 id="演習-41" class="unnumbered">演習</h2>
<ol type="1">
<li>(簡単) <code>par</code>を使用して、２つのHTTP要求を作成し、並列に応答本体を集めてください。結合関数は2つの応答本体を連結する必要があり、継続は<code>trace</code>を使用してコンソールに結果を出力しなくてはいけません。</li>
<li><p>(やや難しい) ２つの計算を並列に実行し、先に完了したほうの計算の結果を返す次のような関数を書いてください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">race ::</span> forall a eff<span class="fu">.</span> 
  <span class="dt">ContRef</span> eff a <span class="ot">-&gt;</span> 
  <span class="dt">ContRef</span> eff a <span class="ot">-&gt;</span> 
  <span class="dt">ContRef</span> eff a</code></pre>
<p><strong>ヒント</strong>：結果が返されたかどうかを示す<code>Boolean</code>を格納する参照を使ってみましょう。</p></li>
<li><p>(やや難しい) <code>race</code>関数を<code>setTimeoutCont</code>関数と一緒に使って、次のような関数を定義してください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">timeout ::</span> forall a eff<span class="fu">.</span> 
  <span class="dt">Milliseconds</span> <span class="ot">-&gt;</span> 
  <span class="dt">ContRef</span> eff a <span class="ot">-&gt;</span> 
  <span class="dt">ContRef</span> eff (<span class="dt">Maybe</span> a)</code></pre>
<p>この関数は指定された計算が与えられたミリ秒以内で結果を返さないなら<code>Nothing</code>を返します。</p></li>
</ol>
</blockquote>
<h2 id="並列処理のためのapplicative関手"><span class="header-section-number">12.9</span> 　並列処理のためのApplicative関手</h2>
<p><code>par</code>コンビネータの型は<code>ContRef eff</code>モナドについての<code>lift2</code>の型にとても良く似ています。実際に、<code>par</code>が<strong>厳密に</strong><code>lift2</code>であるような新しいApplicative関手を定義することは可能で、<code>par</code>と<code>ContRef eff</code>に関してこれを簡単に定義することができます。</p>
<p><code>par</code>に関する<code>ContRef eff</code>の<code>Applicative</code>インスタンスを定義していないのはなぜかと不思議に思われるかもしれません。これには２つの理由があります。</p>
<ul>
<li><p>型コンストラクタが <code>Monad</code>インスタンスも持っている場合、それは通常<code>(&lt;*&gt;)</code>が以下の関数と同値であるという意味で、<code>Monad</code>と<code>Applicative</code>インスタンスは一致しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ap ::</span> forall m a b<span class="fu">.</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> m (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b
ap mf ma <span class="fu">=</span> <span class="kw">do</span>
  f <span class="ot">&lt;-</span> mf
  a <span class="ot">&lt;-</span> ma
  return (f a)</code></pre>
<p>しかしながら、この仮定的な<code>Applicative</code>インスタンスは、並列性に関して<code>Monad</code>インスタンスとは異なるでしょう。<code>(&lt;*&gt;)</code>は引数を並列に評価するのに対して、<code>ap</code>は２番めの計算を実行する前に、最初の計算の完了を待つからです。</p></li>
<li><p>PureScriptは行型を含む型の型クラスのインスタンスを許可していません。<code>Eff</code>モナドは作用の行によってパラメータ化され、その場合、行は<code>Ref</code>作用を含まなければならないので、<code>ContRef</code>についての<code>Applicative</code>インスタンスを定義することは不可能なのです。</p></li>
</ul>
<p>その代わりに、<code>Parallel eff</code>と呼ばれる<code>ContRef eff</code>のnewtypeラッパーを次のように作成します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Parallel</span> eff a <span class="fu">=</span> <span class="dt">Parallel</span> (<span class="dt">ContRef</span> eff a)</code></pre>
<p>単に外側のデータ構築子を除去することで、<code>Parallel</code>計算を<code>ContRef eff</code>モナドにおける演算に変換する関数を書くことができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runParallel ::</span> forall eff a<span class="fu">.</span> <span class="dt">Parallel</span> eff a <span class="ot">-&gt;</span> <span class="dt">ContRef</span> eff a
runParallel (<span class="dt">Parallel</span> c) <span class="fu">=</span> c</code></pre>
<p>型クラスのインスタンスは、大部分は<code>ContT</code>の対応するインスタンスから複製することができます。しかし、<code>Apply</code>型クラスの場合には、<code>(&lt;*&gt;)</code>を再定義するために<code>par</code>を使用してください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> functorParallel ::</span> <span class="dt">Functor</span> (<span class="dt">Parallel</span> eff) <span class="kw">where</span>
  (<span class="fu">&lt;$&gt;</span>) f (<span class="dt">Parallel</span> c) <span class="fu">=</span> <span class="dt">Parallel</span> (f <span class="fu">&lt;$&gt;</span> c)

<span class="kw">instance</span><span class="ot"> applyParallel ::</span> <span class="dt">Apply</span> (<span class="dt">Parallel</span> eff) <span class="kw">where</span>
  (<span class="fu">&lt;*&gt;</span>) (<span class="dt">Parallel</span> f) (<span class="dt">Parallel</span> x) <span class="fu">=</span> <span class="dt">Parallel</span> (par (<span class="fu">$</span>) f x)

<span class="kw">instance</span><span class="ot"> applicativeParallel ::</span> <span class="dt">Applicative</span> (<span class="dt">Parallel</span> eff) <span class="kw">where</span>
  pure a <span class="fu">=</span> <span class="dt">Parallel</span> <span class="fu">$</span> pure a</code></pre>
<p><code>Apply</code>インスタンスの定義では、結合関数として関数適用<code>($)</code>を使って、関数をその引数と結合するために<code>par</code>を使っています。</p>
<p><code>Parallel</code>型構築子を使用して並列に二つのファイルを読むように上の例を書き直すことができるようになりました。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Apply</span> (lift2)

main <span class="fu">=</span> flip runContT print <span class="fu">$</span> runParallel <span class="fu">$</span>
  lift2 (<span class="fu">++</span>) <span class="fu">&lt;$&gt;</span> <span class="dt">Parallel</span> (readFileCont <span class="st">&quot;/tmp/1.txt&quot;</span>)
             <span class="fu">&lt;*&gt;</span> <span class="dt">Parallel</span> (readFileCont <span class="st">&quot;/tmp/2.txt&quot;</span>)</code></pre>
<p>Applicative関手では任意個引数の関数の持ち上げができるので、このApplicativeコンビネータを使ってより多くの計算を並列に実行することができます。<code>traverse</code>と<code>sequence</code>のようなApplicative関手を扱うすべての標準ライブラリ関数から恩恵を受けることもできます。</p>
<p>必要に応じて<code>Parralel</code>と<code>runParallel</code>を使って型構築子を変更することで、do記法ブロックのApplicativeコンビネータを使って、直列的なコードの一部で並列計算を結合したり、またはその逆を行ったりすることができます。</p>
<blockquote>
<h2 id="演習-42" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単) <code>traverse</code>関数を使って、ファイルの名前の配列を与えるとその内容を並列に読み取り、内容の文字列表現の配列を返す関数<code>readMany</code>を書いてください。</p></li>
<li><p>(簡単) <code>race</code>コンビネータを使って、<code>Parallel eff</code>の<code>Alt</code>インスタンスを書いてください。<code>Alternative</code>のインスタンスは作れるでしょうか。</p></li>
<li><p>(やや難しい) <code>lift2</code>で<code>(++)</code>を持ち上げる代わりに、<code>ErrorT</code>を使ってエラー処理を行うように、並列ファイル入出力の例を書きなおしてください。解決策は<code>Parallel</code>関手を変換するために<code>ErrorT</code>変換子を使用しなければいけません。</p>
<p>同様の手法で<code>readMany</code>関数を書き換えてください。</p></li>
<li><p>(難しい、拡張) ディスク上のJSON文書のコレクションが与えられ、それぞれの文書はディスク上の他のファイルへの参照の配列を含んでいるとします。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">{ <span class="dt">references</span>: [<span class="st">&#39;/tmp/1.json&#39;</span>, <span class="st">&#39;/tmp/2.json&#39;</span>] }</code></pre>
<p>入力として単一のファイル名をとり、そのファイルから参照されているディスク上のすべてのJSONファイルをたどって、参照されたすべてのファイルの一覧を収集するユーティリティを書いてください。</p>
<p>そのユーティリティは、JSON文書を解析するために <code>purescript-foreign</code>ライブラリを使用する必要があり、単一のファイルが参照するファイルは並列に取得しなければなりません！</p></li>
</ol>
</blockquote>
<h2 id="まとめ-10"><span class="header-section-number">12.10</span> まとめ</h2>
<p>この章ではモナド変換子の実用的なデモンストレーションを見てきました。</p>
<ul>
<li>コールバック渡しの一般的なJavaScriptのイディオムを <code>ContT</code>モナド変換子によって捉えることができる方法を説明しました。</li>
<li>どのようにコールバック地獄の問題を解決するかを説明しました。　直列の非同期計算を表現するdo記法を使用して、かつ並列性を表現するためにApplicative関手によって解決することができる方法を説明しました。</li>
<li><strong>非同期エラー</strong>を表現するために<code>ErrorT</code>を使いました。</li>
</ul>
<h1 id="テストの自動生成"><span class="header-section-number">13</span> テストの自動生成</h1>
<h2 id="この章の目標-10"><span class="header-section-number">13.1</span> この章の目標</h2>
<p>この章では、テスティングの問題に対する、型クラスの特に洗練された応用について示します。<strong>どのようにテストするのかを</strong>コンパイラに教えるのではなく、コードが<strong>どのような性質を持っているべきか</strong>を教えることでテストします。型クラスを使って無作為データ生成のための定型コードを隠し、テストケースを仕様から無作為に生成することができます。これは<strong>生成的テスティング</strong>(generative testing、またはproperty-based testing）と呼ばれ、Haskellの<a href="http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck1">QuickCheck</a>ライブラリによって知られるようになった手法です。</p>
<p><code>purescript-quickcheck</code>パッケージはHaskellのQuickCheckをライブラリをPureScriptにポーティングしたもので、型や構文はもとのライブラリとほとんど同じようになっています。<code>purescript-quickcheck</code>を使って簡単なライブラリをテストし、Gruntでテストスイートを自動化されたビルドに統合する方法を見ていきます。</p>
<h2 id="プロジェクトの準備-10"><span class="header-section-number">13.2</span> プロジェクトの準備</h2>
<p>この章のプロジェクトにはBower依存関係として<code>purescript-quickcheck</code>が追加されます。実際には、<code>purescript-quickcheck</code>は<code>bower.json</code> の<code>devDependencies</code>セクションに追加されます。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">  <span class="st">&quot;devDependencies&quot;</span>: {
    <span class="st">&quot;purescript-quickcheck&quot;</span>: <span class="st">&quot;~0.1.3&quot;</span>
  }</code></pre>
<p>これは <code>purescript-quickcheck</code>は開発時のみ必要であることを示しています。製品ビルドのときは QuickCheck ライブラリコードを出力に含むのを避けるため、 <code>bower</code>コマンドで<code>--production</code>フラグを使ってください。</p>
<pre class="text"><code>$ bower update --production

$ grunt build</code></pre>
<h2 id="テストの自動化"><span class="header-section-number">13.3</span> テストの自動化</h2>
<p>このプロジェクトの <code>Gruntfile.js</code>ファイルは、テストスイートをサポートするために少し変更されています。</p>
<p>まず、<code>psc</code>タスクに新しいセクションが追加されています。これはソースコードをテストスイートのコードと一緒にビルドし、副次的なJavaScriptファイルを出力するようにします。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">psc: {
  <span class="dt">lib</span>: {
    <span class="dt">src</span>: [<span class="st">&quot;&lt;%=srcFiles%&gt;&quot;</span>],
    <span class="dt">dest</span>: <span class="st">&quot;dist/Main.js&quot;</span>
  },
  <span class="dt">tests</span>: {
    <span class="dt">options</span>: {
      <span class="dt">module</span>: [<span class="st">&quot;Main&quot;</span>],
      <span class="dt">main</span>: <span class="kw">true</span>
    },
    <span class="dt">src</span>: [<span class="st">&quot;tests/Main.purs&quot;</span>, <span class="st">&quot;&lt;%=srcFiles%&gt;&quot;</span>],
    <span class="dt">dest</span>: <span class="st">&quot;dist/tests.js&quot;</span>
  }
}</code></pre>
<p><code>psc:tests</code>タスクはテストスイートを実行するためにの追加の<code>dist/tests.js</code>ファイルを生成するようになっています。次の手順は、<code>grunt-execute</code>パッケージを使って、このプロセスを自動化することです。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript">execute: {
  <span class="dt">tests</span>: {
    <span class="dt">src</span>: <span class="st">&quot;dist/tests.js&quot;</span>
  }
}</code></pre>
<p><code>grunt-execute</code>パッケージもNPMの​依存関係として追加されます。最後に、Gruntタスクリストにタスクとしてこれを追加する必要があります。</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="ot">grunt</span>.<span class="fu">loadNpmTasks</span>(<span class="st">&quot;grunt-execute&quot;</span>);

<span class="ot">grunt</span>.<span class="fu">registerTask</span>(<span class="st">&quot;build&quot;</span>, 
  [<span class="st">&quot;psc:lib&quot;</span>, <span class="st">&quot;dotPsci&quot;</span>]);
<span class="ot">grunt</span>.<span class="fu">registerTask</span>(<span class="st">&quot;test&quot;</span>, 
  [<span class="st">&quot;build&quot;</span>, <span class="st">&quot;psc:tests&quot;</span>, <span class="st">&quot;execute:tests&quot;</span>]);</code></pre>
<p>これで、ライブラリのソースコードだけをビルドする<code>build</code>、ライブラリとテストスイートをビルドしテストも実行する<code>test</code>の、2つのタスクが新しく利用できるようになります。</p>
<h2 id="プロパティの書き込み"><span class="header-section-number">13.4</span> プロパティの書き込み</h2>
<p><code>Merge.purs</code>ファイルでは<code>purescript-quickcheck</code>ライブラリの機能を実演するために使う簡単な関数<code>merge</code>が実装されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">merge ::</span> [<span class="dt">Number</span>] <span class="ot">-&gt;</span> [<span class="dt">Number</span>] <span class="ot">-&gt;</span> [<span class="dt">Number</span>]</code></pre>
<p><code>merge</code>は2つのソートされた数の配列をとって、その要素を統合し、ソートされた結果を返します。例えば次のようになります。</p>
<pre class="text"><code>&gt; :i Merge
&gt; merge [1, 3, 5] [2, 4, 6]

[1, 2, 3, 4, 5, 6]</code></pre>
<p>典型的なテストスイートでは、手作業でこのような小さなテストケースをいくつも作成し、結果が正しい値と等しいことを確認することでテスト実施します。しかし、<code>merge</code>関数について知る必要があるものはすべて、2つの性質に要約することができます。</p>
<ul>
<li>(既ソート性) <code>xs</code>と<code>ys</code>がソート済みなら、<code>merge xs ys</code>もソート済みになります。</li>
<li>（部分配列） <code>xs</code>と<code>ys</code>ははどちらも<code>merge xs ys</code>の部分配列で、要素は元の配列と同じ順序で現れます。</li>
</ul>
<p><code>purescript-quickcheck</code>では、無作為なテストケースを生成することで、直接これらの性質をテストすることができます。コードが持つべき性質を、次のような関数として述べるだけです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
  quickCheck <span class="fu">$</span> \xs ys <span class="ot">-&gt;</span> 
    isSorted <span class="fu">$</span> merge (sort xs) (sort ys)
  quickCheck <span class="fu">$</span> \xs ys <span class="ot">-&gt;</span> 
    xs <span class="ot">`isSubarrayOf`</span> merge xs ys</code></pre>
<p>ここで、<code>isSorted</code>と<code>isSubarrayOf</code>は次のような型を持つ補助関数として実装されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isSorted ::</span> forall a<span class="fu">.</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Boolean</span>
<span class="ot">isSubarrayOf ::</span> forall a<span class="fu">.</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Boolean</span></code></pre>
<p>このコードを実行すると、 <code>purescript-quickcheck</code>は無作為な入力<code>xs</code>と <code>ys</code>を生成してこの関数に渡すことで、主張しようとしている性質を反証しようとします。何らかの入力に対して関数が<code>false</code>を返した場合、性質は正しくないことが示され、ライブラリはエラーを発生させます。幸いなことに、次のように100個の無作為なテストケースを生成しても、ライブラリはこの性質を反証することができません。</p>
<pre class="text"><code>$ grunt

Running &quot;execute:tests&quot; (execute) task
-&gt; executing dist/tests.js
100/100 test(s) passed.
100/100 test(s) passed.
-&gt; completed dist/tests.js

&gt;&gt; 1 file and 0 calls executed

Done, without errors.</code></pre>
<p>もし<code>merge</code>関数に意図的にバグを混入した場合（例えば、大なりのチェックを小なりのチェックへと変更するなど）、最初に失敗したテストケースの後で例外が実行時に投げられます。</p>
<pre class="text"><code>Error: Test 1 failed: 
Test returned false</code></pre>
<p>このエラーメッセージではあまり役に立ちませんが、これから見ていくように、少しの作業で改良することができます。</p>
<h2 id="エラーメッセージの改善"><span class="header-section-number">13.5</span> エラーメッセージの改善</h2>
<p>テストケースが失敗した時に同時にエラーメッセージを提供するには、<code>purescript-quickcheck</code>の<code>&lt;?&gt;</code>演算子を使います。次のように性質の定義に続けて<code>&lt;?&gt;</code>で区切ってエラーメッセージを書くだけです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">quickCheck <span class="fu">$</span> \xs ys <span class="ot">-&gt;</span> 
  <span class="kw">let</span>
    result <span class="fu">=</span> merge xs ys 
  <span class="kw">in</span> 
    xs <span class="ot">`isSubarrayOf`</span> result <span class="fu">&lt;?&gt;</span> show xs <span class="fu">++</span> <span class="st">&quot; not a subarray of &quot;</span> <span class="fu">++</span> show result</code></pre>
<p>このとき、もしバグを混入するようにコードを変更すると、最初のテストケースが失敗したときに改良されたエラーメッセージが表示されます。</p>
<pre class="text"><code>Error: Test 6 failed: 
[0.85] not a subarray of [0.89,0.82,0.44,0.01]</code></pre>
<p>入力<code>xs</code>が無作為に選ばれた数の配列として生成されていることに注目してください。</p>
<blockquote>
<h2 id="演習-43" class="unnumbered">演習</h2>
<ol type="1">
<li><p>（簡単）　空の配列を持つ配列を統合しても元の配列は変更されない、と主張する性質を書いてください。</p></li>
<li><p>（簡単） <code>merge</code>の残りの性質に対して、適切なエラーメッセージを追加してください。</p></li>
</ol>
</blockquote>
<h2 id="多相的なコードのテスト"><span class="header-section-number">13.6</span> 多相的なコードのテスト</h2>
<p><code>Merge</code>モジュールでは、数の配列だけでなく、<code>Ord</code>型クラスに属するどんな型の配列に対しても動作する、<code>merge</code>関数を一般化した<code>mergePoly</code>という関数が定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mergePoly ::</span> forall a<span class="fu">.</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</code></pre>
<p><code>merge</code>の代わりに<code>mergePoly</code>を使うように元のテストを変更すると、次のようなエラーメッセージが表示されます。</p>
<pre class="text"><code>Error in declaration main
No instance found for Testable ([u1] -&gt; [u1] -&gt; Boolean)</code></pre>
<p>このエラーメッセージは、配列に持たせたい要素の型が何なのかわからないので、コンパイラが無作為なテストケースを生成できなかったということを示しています。このような場合、補助関数を使と、コンパイラが特定の型を推論すること強制できます。例えば、恒等関数の同義語として<code>numbers</code>という関数を定義します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">numbers ::</span> [<span class="dt">Number</span>] <span class="ot">-&gt;</span> [<span class="dt">Number</span>]
numbers <span class="fu">=</span> id</code></pre>
<p>それから、コンパイラが引数の２つの配列の型 <code>[Number]</code> を推論するように、テストを変更します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">quickCheck <span class="fu">$</span> \xs ys <span class="ot">-&gt;</span> 
  isSorted <span class="fu">$</span> numbers <span class="fu">$</span> mergePoly (sort xs) (sort ys)
quickCheck <span class="fu">$</span> \xs ys <span class="ot">-&gt;</span> 
  numbers xs <span class="ot">`isSubarrayOf`</span> mergePoly xs ys</code></pre>
<p>ここで、<code>numbers</code>関数が不明な型を解消するために使われるので、<code>xs</code>と<code>ys</code> はどちらも型<code>[Number]</code>を持っています。</p>
<blockquote>
<h2 id="演習-44" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単) <code>xs</code>と<code>ys</code>の型を<code>[Boolean]</code>に強制する関数<code>bools</code>を書き、<code>mergePoly</code>をその型でテストする性質を追加してください。</p></li>
<li><p>(やや難しい) 標準関数から(例えば<code>purescript-arrays</code>パッケージから)ひとつ関数を選び、適切なエラーメッセージを含めてQuickCheckの性質を書いてください。その性質は、補助関数を使って多相型引数を<code>Number</code>か<code>Boolean</code>のどちらかに固定しなければいけません。</p></li>
</ol>
</blockquote>
<h2 id="任意のデータの生成"><span class="header-section-number">13.7</span> 任意のデータの生成</h2>
<p><code>purescript-quickcheck</code>ライブラリを使って性質についてのテストケースを無作為に生成する方法について説明します。</p>
<p>無作為に値を生成することができるような型は、次のような型クラス<code>Arbitary</code>のインスタンスを持っています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Arbitrary</span> t <span class="kw">where</span>
<span class="ot">  arbitrary ::</span> <span class="dt">Gen</span> t</code></pre>
<p><code>Gen</code>型構築子は<strong>決定的無作為データ生成</strong>の副作用を表しています。 決定的無作為データ生成は、擬似乱数生成器を使って、シード値から決定的無作為関数の引数を生成します。<code>Gen</code>はモナドでもApplicative関手でもあるので、<code>Arbitary</code>型クラスの新しいインスタンスを作成するのに、いつも使っているようなコンビネータを自由に使うことができます。</p>
<p>例えば、<code>purescript-quickcheck</code>ライブラリで提供されている<code>Number</code>型の<code>Arbitrary</code>インスタンスは、0と1の間に均一に分布した値を生成します。もし異なる分布を持った数を生成する<code>Arbitary</code>インスタンスを持った型を定義したい場合は、<code>Applicative</code>インスタンスを使うと、関数適用によって、均一な無作為な変数を、次のような無作為な値へと変換することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Byte</span> <span class="fu">=</span> <span class="dt">Byte</span> <span class="dt">Number</span>

<span class="kw">instance</span><span class="ot"> arbitraryByte ::</span> <span class="dt">Arbitary</span> <span class="dt">Byte</span> <span class="kw">where</span>
  arbitrary <span class="fu">=</span> uniformToByte <span class="fu">&lt;$&gt;</span> arbitrary
    <span class="kw">where</span>
    uniformToByte n <span class="fu">=</span> Math.floor (n <span class="fu">*</span> <span class="dv">256</span>)</code></pre>
<p>ここでは、0から255までの間の整数値であるような型<code>Byte</code>を定義しています。<code>Arbitrary</code>インスタンスの<code>&lt;$&gt;</code>演算子を使って、<code>uniformToByte</code>関数を<code>arbitrary</code>アクションまで持ち上げています。この型の<code>arbitrary</code>アクションの型は<code>Gen Number</code>だと推論されますが、これは0から1の間に均一に分布する数を生成することを意味しています。</p>
<p>この考え方を<code>merge</code>に対しての既ソート性テストを改良するのに使うこともできます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">quickCheck <span class="fu">$</span> \xs ys <span class="ot">-&gt;</span> 
  isSorted <span class="fu">$</span> numbers <span class="fu">$</span> mergePoly (sort xs) (sort ys)</code></pre>
<p>このテストでは、任意の配列<code>xs</code>と<code>ys</code>を生成しますが、<code>merge</code>はソート済みの入力を期待しているので、<code>xs</code>と<code>ys</code>をソートしておかなければなりません。一方で、ソートされた配列を表すnewtypeを作成し、ソートされたデータを生成する<code>Arbitrary</code>インスタンスを書くこともできます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Sorted</span> a <span class="fu">=</span> <span class="dt">Sorted</span> [a]

<span class="ot">sorted ::</span> forall a<span class="fu">.</span> <span class="dt">Sorted</span> a <span class="ot">-&gt;</span> [a]
sorted (<span class="dt">Sorted</span> xs) <span class="fu">=</span> xs

<span class="kw">instance</span><span class="ot"> arbSorted ::</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Sorted</span> a) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="dt">Sorted</span> <span class="fu">&lt;&lt;&lt;</span> sort <span class="fu">&lt;$&gt;</span> arbitrary</code></pre>
<p>この型構築子を使うと、テストを次のように変更することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">quickCheck <span class="fu">$</span> \xs ys <span class="ot">-&gt;</span> 
  isSorted <span class="fu">$</span> numbers <span class="fu">$</span> mergePoly (sorted xs) (sorted ys)</code></pre>
<p>これは些細な変更に見えるかもしれませんが、<code>xs</code>と<code>ys</code>の型はただの<code>[Number]</code>から<code>Sorted Number</code>へと変更されています。これにより、<code>mergePoly</code>関数はソート済みの入力を取る、という<strong>意図</strong>を、わかりやすく示すことができます。理想的には、 <code>mergePoly</code>関数自体の型が<code>Sorted</code>型構築子を使うようにするといいでしょう。</p>
<p>より興味深い例として、<code>Tree.purs</code>ファイルでは枝の値でソートされた二分木の型が定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a
  <span class="fu">=</span> <span class="dt">Leaf</span>
  <span class="fu">|</span> <span class="dt">Branch</span> (<span class="dt">Tree</span> a) a (<span class="dt">Tree</span> a)</code></pre>
<p><code>Tree</code>モジュールでは次のAPIが定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">insert ::</span> forall a<span class="fu">.</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a
<span class="ot">member ::</span> forall a<span class="fu">.</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Boolean</span>

<span class="ot">toArray ::</span> forall a<span class="fu">.</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]
<span class="ot">fromArray ::</span> forall a<span class="fu">.</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</code></pre>
<p><code>insert</code>関数は新しい要素をソート済みの二分木に挿入するのに使われ、<code>member</code>関数は特定の値の有無を木に問い合わせるのに使われます。例えば次のようになります。</p>
<pre class="text"><code>&gt; :i Tree

&gt; member 2 $ insert 1 $ insert 2 Leaf
true

&gt; member 1 Leaf
false</code></pre>
<p><code>toArray</code>関数と<code>fromArray</code>関数は、ソートされた木とソートされた配列を相互に変換するために使われます。<code>fromArray</code>を使うと、木についての<code>Arbitrary</code>インスタンスを書くことができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> arbTree ::</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Tree</span> a) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> fromArray <span class="fu">&lt;&lt;&lt;</span> sorted <span class="fu">&lt;$&gt;</span> arbitrary</code></pre>
<p><code>fromArray</code>への入力がソートされた配列であることを保証するために、ここで<code>sort</code>関数を使っていることに注意してください。</p>
<p>型<code>a</code>についての有効な<code>Arbitary</code>インスタンスが存在していれば、テストする性質の引数の型として<code>Tree a</code>を使うことができます。例えば、<code>member</code>テストは値を挿入した後は常に<code>true</code>を返すことをテストできます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">quickCheck <span class="fu">$</span> \t a <span class="ot">-&gt;</span> 
  member a <span class="fu">$</span> insert a (<span class="ot">t ::</span> <span class="dt">Tree</span> <span class="dt">Number</span>) </code></pre>
<p>ここでは、引数<code>t</code>は<code>Tree Number</code>型の無作為に生成された木です。</p>
<blockquote>
<h2 id="演習-45" class="unnumbered">演習</h2>
<ol type="1">
<li><p>（やや難しい） <code>a-z</code>の範囲から無作為に選ばれた文字の集まりを生成する<code>Arbitrary</code>インスタンスを持った、<code>String</code>のnewtypeを作ってください。<strong>ヒント</strong>： <code>[Number]</code>の<code>Arbitrary</code>インスタンスと、 型<code>[Number] -&gt; String</code>を持つ関数を使ってください。</p></li>
<li><p>（難しい） 木に挿入された値は、任意に多くの挿入があった後も、その木の構成要素であることを主張する性質を書いてください。</p></li>
</ol>
</blockquote>
<h2 id="高階関数のテスト"><span class="header-section-number">13.8</span> 高階関数のテスト</h2>
<p><code>Merge</code>モジュールは<code>merge</code>関数についての他の生成も定義します。<code>mergeAith</code>関数は、統合される要素の順序を決定するのに使われる、追加の関数を引数としてとります。つまり<code>mergeWith</code>は高階関数です。</p>
<p>例えば、すでに長さの昇順になっている２つの配列を統合するのに、<code>length</code>関数を最初の引数として渡します。このとき、結果も長さの昇順になっていなければなりません。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="fu">:</span>i <span class="dt">Data.String</span>
<span class="fu">&gt;</span> mergeWith length 
    [<span class="st">&quot;&quot;</span>, <span class="st">&quot;ab&quot;</span>, <span class="st">&quot;abcd&quot;</span>] 
    [<span class="st">&quot;x&quot;</span>, <span class="st">&quot;xyz&quot;</span>]

[<span class="st">&quot;&quot;</span>,<span class="st">&quot;x&quot;</span>,<span class="st">&quot;ab&quot;</span>,<span class="st">&quot;xyz&quot;</span>,<span class="st">&quot;abcd&quot;</span>]</code></pre>
<p>このような関数をテストするにはどうしたらいいでしょうか。理想的には、関数であるような最初の引数を含めた、３つの引数すべてについて、値を生成したいと思うでしょう。</p>
<p>関数を無作為に生成せきるようにする、もうひとつの型クラスがあります。この型クラスは<code>CoArbitrary</code>と呼ばれており、次のように定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">CoArbitrary</span> t <span class="kw">where</span>
<span class="ot">  coarbitrary ::</span> forall r<span class="fu">.</span> t <span class="ot">-&gt;</span> <span class="dt">Gen</span> r <span class="ot">-&gt;</span> <span class="dt">Gen</span> r</code></pre>
<p><code>coarbitrary</code>関数は、型<code>t</code>と、関数の結果の型<code>r</code>についての無作為な生成器を関数の引数としてとり、無作為な生成器を<strong>かき乱す</strong>のにこの引数を使います。つまり、この引数を使って、乱数生成器の無作為な出力を変更しているのです。</p>
<p>また、もし関数の定義域が<code>CoArbitrary</code>で、値域が<code>Arbitrary</code>なら、<code>Arbitrary</code>の関数を与える型クラスインスタンスが存在しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> arbFunction ::</span> (<span class="dt">CoArbitrary</span> a, <span class="dt">Arbitrary</span> b) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (a <span class="ot">-&gt;</span> b)</code></pre>
<p>実は、これが意味しているのは、引数として関数を取るような性質を記述できるということです。<code>mergeWith</code>関数の場合では、新しい引数を考慮するようにテストを修正すると、最初の引数を無作為に生成することができます。</p>
<p>既ソート性の性質については、必ずしも<code>Ord</code>インスタンスを持っているとは限らないので、結果がソートされているということを保証することができませんが、引数として渡す関数<code>f</code>にしたがって結果がソートされている期待することはできます。さらに、２つの入力配列が<code>f</code>に従ってソートされている必要がありますので、<code>sortBy</code>関数を使って関数<code>f</code>が適用されたあとの比較に基づいて<code>xs</code>と<code>ys</code>をソートします。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">quickCheck <span class="fu">$</span> \xs ys f <span class="ot">-&gt;</span> 
  isSorted <span class="fu">$</span> 
    map f <span class="fu">$</span> 
      mergeWith (numberToBool f) 
                (sortBy (compare <span class="ot">`on`</span> f) xs) 
                (sortBy (compare <span class="ot">`on`</span> f) ys)</code></pre>
<p>ここでは、関数<code>f</code>の型を明確にするために、関数<code>numberToBool</code>を使用しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">numberToBool ::</span> (<span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Boolean</span>) <span class="ot">-&gt;</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Boolean</span>
numberToBool <span class="fu">=</span> id</code></pre>
<p>部分配列性については、単に関数の名前を<code>mergeWith</code>に変えるだけです。引き続き入力配列は結果の部分配列になっていると期待できます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">quickCheck <span class="fu">$</span> \xs ys f <span class="ot">-&gt;</span> 
  xs <span class="ot">`isSubarrayOf`</span> mergeWith (numberToBool f) xs ys</code></pre>
<p>関数は<code>Arbitrary</code>であるだけでなく<code>CoArbitrary</code>でもあります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> coarbFunction ::</span> (<span class="dt">Arbitrary</span> a, <span class="dt">CoArbitrary</span> b) <span class="ot">=&gt;</span> <span class="dt">CoArbitrary</span> (a <span class="ot">-&gt;</span> b)</code></pre>
<p>これは値の生成が単純な関数だけに限定されるものではないことを意味しています。つまり、<strong>高階関数</strong>や、引数が高階関数であるような関数すら無作為に生成することができるのです。</p>
<h2 id="coarbitraryのインスタンスを書く"><span class="header-section-number">13.9</span> CoArbitraryのインスタンスを書く</h2>
<p><code>Gen</code>の<code>Monad</code>や<code>Applicative</code>インスタンスを使って独自のデータ型に対して<code>Arbitrary</code>インスタンスを書くことができるのとちょうど同じように、独自の<code>CoArbitrary</code>インスタンスを書くこともできます。これにより、無作為に生成される関数の定義域として、独自のデータ型を使うことができるようになります。</p>
<p><code>Tree</code>型の<code>CoArbitrary</code>インスタンスを書いてみましょう。枝に格納されている要素の型に<code>CoArbitrary</code>インスタンスが必要になります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> coarbTree ::</span> (<span class="dt">CoArbitrary</span> a) <span class="ot">=&gt;</span> <span class="dt">CoArbitrary</span> (<span class="dt">Tree</span> a) <span class="kw">where</span></code></pre>
<p>型<code>Tree a</code>の値を与えられた乱数発生器をかき乱す関数を記述する必要があります。入力値が <code>Leaf</code>であれば、そのままの生成器を返します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  coarbitrary <span class="dt">Leaf</span> <span class="fu">=</span> id</code></pre>
<p>もし木が<code>Branch</code>なら、 関数合成で独自のかき乱し関数を作ることにより、 左の部分木、値、右の部分木を使って生成器をかき乱します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  coarbitrary (<span class="dt">Branch</span> l a r) <span class="fu">=</span>
    coarbitrary l <span class="fu">&lt;&lt;&lt;</span>
    coarbitrary a <span class="fu">&lt;&lt;&lt;</span>
    coarbitrary r</code></pre>
<p>これで、木を引数にとるような関数を含む性質を自由に書くことができるようになりました。たとえば、<code>Tree</code>モジュールでは述語が引数のどんな部分木についても成り立っているかを調べる関数<code>anywhere</code>が定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">anywhere ::</span> forall a<span class="fu">.</span> (<span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Boolean</span>) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Boolean</span></code></pre>
<p>これで、無作為にこの述語関数<code>anywhere</code>を生成することができるようになりました。例えば、<code>anywhere</code>関数が次のような<strong>ある命題のもとで不変</strong>であることを期待します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">quickCheck <span class="fu">$</span> \f g t <span class="ot">-&gt;</span>
  anywhere (\s <span class="ot">-&gt;</span> f s <span class="fu">||</span> g s) t <span class="fu">==</span>
    anywhere f (treeOfNumber t) <span class="fu">||</span> anywhere g t</code></pre>
<p>ここで、<code>treeOfNumber</code>関数は木に含まれる値の型を型<code>Number</code>に固定するために使われています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">treeOfNumber ::</span> <span class="dt">Tree</span> <span class="dt">Number</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Number</span>
treeOfNumber <span class="fu">=</span> id</code></pre>
<h2 id="副作用のないテスト"><span class="header-section-number">13.10</span> 副作用のないテスト</h2>
<p>テストの目的では通常、テストスイートの <code>main</code>アクションには<code>quickCheck</code>関数の呼び出しが含まれています。しかし、副作用を使わない<code>quickCheckPure</code>と呼ばれる<code>quickCheck</code>関数の亜種もあります。<code>quickCheckPure</code>は、入力として乱数の種をとり、テスト結果の配列を返す純粋な関数です。</p>
<p><code>psci</code>を使用して<code>quickCheckPure</code>を使ってみましょう。ここでは <code>merge</code>操作が結合法則を満たすことをテストしてみます。</p>
<pre class="text"><code>&gt; :i Test.QuickCheck
&gt; :i Merge

&gt; quickCheckPure 12345 10 $ \xs ys zs -&gt; 
    ((xs `merge` ys) `merge` zs) == 
      (xs `merge` (ys `merge` zs))
  
[Success, Success, ..., Success]</code></pre>
<p><code>quickCheckPure</code>は乱数の種、生成するテストケースの数、テストする性質の３つの引数をとります。もしすべてのテストケースに成功したら、<code>Success</code>データ構築子の配列がコンソールに出力されます。</p>
<p><code>quickCheckPure</code>は、性能ベンチマークの入力データ生成や、ウェブアプリケーションのフォームデータ例を無作為に生成するというような状況で便利かもしれません。</p>
<blockquote>
<h2 id="演習-46" class="unnumbered">演習</h2>
<ol type="1">
<li><p>（簡単） <code>Byte</code>と<code>Sorted</code>型構築子についての <code>CoArbitrary</code>インスタンスを書いてください。</p></li>
<li><p>（やや難しい）任意の関数 <code>f</code>について、<code>mergeWith f</code>関数の結合性を主張する(高階)性質を書いてください。<code>quickCheckPure</code>を使って<code>psci</code>でその性質をテストしてください。</p></li>
<li><p>（やや難しい）次のデータ型の <code>CoArbitrary</code>インスタンスを書いてください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">OneTwoThree</span> a <span class="fu">=</span> <span class="dt">One</span> a <span class="fu">|</span> <span class="dt">Two</span> a a <span class="fu">|</span> <span class="dt">Three</span> a a a</code></pre></li>
<li><p>(やや難しい) <code>all</code>関数を使って<code>quickCheckPure</code>関数の結果を単純化してください。その関数はもしどんなテストもパスするなら<code>true</code>を返し、そうでなければ<code>false</code>を返さなくてはいけません。<code>purescript-monoids</code>で定義されている<code>First</code>モノイドを 、失敗時の最初のエラーを保存するために<code>foldMap</code>関数と一緒に使ってみてください。</p></li>
</ol>
</blockquote>
<h2 id="まとめ-11"><span class="header-section-number">13.11</span> まとめ</h2>
<p>この章では、生成的テスティングのパラダイムを使って宣言的な方法でテストを書くための、<code>purescript-quickcheck</code>パッケージを導入しました。</p>
<ul>
<li>Grunt使ってQuickCheckをテストを自動化する方法を説明しました。</li>
<li>エラーメッセージを改良する<code>&lt;?&gt;</code>演算子の使い方と、性質を関数として書く方法を説明しました。</li>
<li><code>Arbitrary</code>と<code>CoArbitrary</code>型クラスは、定型的なテストコードの自動生成を可能にし、高階性質関数を可能にすることも説明しました。</li>
<li>独自のデータ型に対して<code>Arbitrary</code>と<code>CoArbitrary</code>インスタンスを実装する方法を説明しました。</li>
</ul>
<h1 id="領域特化言語"><span class="header-section-number">14</span> 領域特化言語</h1>
<h2 id="この章の目標-11"><span class="header-section-number">14.1</span> この章の目標</h2>
<p>この章では、多数の標準的な手法を使ったPureScriptにおける<strong>領域特化言語</strong>(domain-specific language, DSL) の実装について探求していきます。</p>
<p>領域特化言語とは、特定の問題領域での開発に適した言語のことです。領域特化言語の構文および機能は、その領域内の考え方を表現するコードの読みやすさを最大限に発揮すべく選択されます。本書の中では、すでに領域特化言語の例を幾つか見てきています。</p>
<ul>
<li>第11章で開発された<code>Game</code>モナドと関連するアクションは、<strong>テキストアドベンチャーゲーム開発</strong>という領域に対しての領域特化言語を構成しています。</li>
<li>第12章で <code>ContT</code>と<code>Parallel</code>関手のために書いたコンビネータのライブラリは、<strong>非同期プログラミング</strong>の領域に対する領域特化言語の例と考えることができます。</li>
<li>第13章で扱った <code>purescript-quickcheck</code>パッケージは、<strong>生成的テスティング</strong>の領域の領域特化言語です。このコンビネータはテストの性質対して特に表現力の高い記法を可能にします。</li>
</ul>
<p>この章では、領域特化言語の実装において、いくつかの標準的な手法による構造的なアプローチを取ります。これがこの話題の完全な説明だということでは決してありませんが、独自の目的に対する具体的なDSLを構築するには十分な知識を与えてくれるでしょう。</p>
<p>この章で実行している例は、HTML文書を作成するための領域特化言語になります。正しいHTML文書を記述するための型安全な言語を開発することが目的で、少しづつ実装を改善することによって作業していきます。</p>
<h2 id="プロジェクトの準備-11"><span class="header-section-number">14.2</span> プロジェクトの準備</h2>
<p>この章で使うプロジェクトには新しいBower依存性が追加されます。これから使う道具のひとつである<strong>Freeモナド</strong>が定義されている<code>purescript-free</code>ライブラリです。</p>
<p>このプロジェクトのソースコードは、Gruntを使ってビルドすることができます。</p>
<h2 id="htmlデータ型"><span class="header-section-number">14.3</span> HTMLデータ型</h2>
<p>このHTMLライブラリの最も基本的なバージョンは <code>Data.DOM.Simple</code>モジュールで定義されています。このモジュールには次の型定義が含まれています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Element</span> <span class="fu">=</span> <span class="dt">Element</span>
  {<span class="ot"> name         ::</span> <span class="dt">String</span>
  ,<span class="ot"> attribs      ::</span> [<span class="dt">Attribute</span>]
  ,<span class="ot"> content      ::</span> <span class="dt">Maybe</span> [<span class="dt">Content</span>]
  }

<span class="kw">data</span> <span class="dt">Content</span>
  <span class="fu">=</span> <span class="dt">TextContent</span> <span class="dt">String</span>
  <span class="fu">|</span> <span class="dt">ElementContent</span> <span class="dt">Element</span>

<span class="kw">newtype</span> <span class="dt">Attribute</span> <span class="fu">=</span> <span class="dt">Attribute</span>
  {<span class="ot"> key          ::</span> <span class="dt">String</span>
  ,<span class="ot"> value        ::</span> <span class="dt">String</span>
  }</code></pre>
<p><code>Element</code>型はHTMLの要素を表しており、各要素は要素名、属性のペア​​の配列と、要素の内容でで構成されています。<code>content</code>プロパティでは、<code>Maybe</code>タイプを使って要素が開いている(他の要素やテキストを含む)か閉じているかを示しています。</p>
<p>このライブラリの鍵となる機能は次の関数です。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">render ::</span> <span class="dt">Element</span> <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre>
<p>この関数はHTML要素をHTML文字列として出力します。<code>psci</code> で明示的に適当な型の値を構築し、ライブラリのこのバージョンを試してみましょう。</p>
<pre class="text"><code>&gt; :i Data.DOM.Simple
&gt; :i Data.Maybe

&gt; render $ Element 
    { name: &quot;p&quot;
    , attribs: [
        Attribute 
          { key: &quot;class&quot;
          , value: &quot;main&quot; 
          }
      ]
    , content: Just [
        TextContent &quot;Hello World!&quot;
      ] 
    }
  
&quot;&lt;p class=\&quot;main\&quot;&gt;Hello World!&lt;/p&gt;&quot;</code></pre>
<p>現状のライブラリにはいくつかの問題があります。</p>
<ul>
<li>HTML文書の作成に手がかかります。すべての新しい要素が少なくとも1つのレコードと1つのデータ構築子が必要です。</li>
<li>無効な文書を表現できてしまいます。
<ul>
<li>要素名の入力を間違えるかもしれません</li>
<li>要素に間違った型の属性を関連付けることができてしまいます</li>
<li>開いた要素が正しい場合でも、閉じた要素を使用することができてしまいます</li>
</ul></li>
</ul>
<p>この章では、さまざまな手法を用いてこれらの問題を解決し、このライブラリーをHTML文書を作成するために使える領域特化言語にしていきます。</p>
<h2 id="スマート構築子"><span class="header-section-number">14.4</span> スマート構築子</h2>
<p>最初に導入する手法は方法は単純なものですが、とても効果的です。モジュールの使用者にデータの表現を露出する代わりに、モジュールエクスポートリスト(module exports list)を使ってデータ構築子<code>Element</code>、<code>Content</code>、<code>Attribute</code>を隠蔽し、正しいことが明らかなデータだけ構築する、いわゆる<strong>スマート構築子</strong>(smart constructors)だけをエクスポートします。</p>
<p>例を示しましょう。まず、HTML要素を作成するための便利な関数を提供します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">element ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Attribute</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Content</span>] <span class="ot">-&gt;</span> <span class="dt">Element</span>
element name attribs content <span class="fu">=</span> <span class="dt">Element</span>
  { name<span class="fu">:</span>      name
  , attribs<span class="fu">:</span>   attribs
  , content<span class="fu">:</span>   content
  }</code></pre>
<p>次に、<code>element</code>関数を適用することによってHTML要素を作成する、スマート構築子を作成します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">a ::</span> [<span class="dt">Attribute</span>] <span class="ot">-&gt;</span> [<span class="dt">Content</span>] <span class="ot">-&gt;</span> <span class="dt">Element</span>
a attribs content <span class="fu">=</span> element <span class="st">&quot;a&quot;</span> attribs (<span class="dt">Just</span> content)

div<span class="ot"> ::</span> [<span class="dt">Attribute</span>] <span class="ot">-&gt;</span> [<span class="dt">Content</span>] <span class="ot">-&gt;</span> <span class="dt">Element</span>
div attribs content <span class="fu">=</span> element <span class="st">&quot;div&quot;</span> attribs (<span class="dt">Just</span> content)

<span class="ot">p ::</span> [<span class="dt">Attribute</span>] <span class="ot">-&gt;</span> [<span class="dt">Content</span>] <span class="ot">-&gt;</span> <span class="dt">Element</span>
p attribs content <span class="fu">=</span> element <span class="st">&quot;p&quot;</span> attribs (<span class="dt">Just</span> content)

<span class="ot">img ::</span> [<span class="dt">Attribute</span>] <span class="ot">-&gt;</span> <span class="dt">Element</span>
img attribs <span class="fu">=</span> element <span class="st">&quot;img&quot;</span> attribs <span class="dt">Nothing</span></code></pre>
<p>最後に、正しいデータ構造だけを構築することがわかっているこれらの関数をエクスポートするように、モジュールエクスポートリストを更新します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Data.DOM.Smart</span>
  ( <span class="dt">Element</span>()
  , <span class="dt">Attribute</span>(<span class="fu">..</span>)
  , <span class="dt">Content</span>(<span class="fu">..</span>)

  , a
  , div
  , p
  , img

  , render
  ) <span class="kw">where</span></code></pre>
<p>モジュールエクスポートリストはモジュール名の直後の括弧内に書きます。各モジュールのエクスポートは次の3種類のいずれかです。</p>
<ul>
<li>値の名前で示された、値(または関数)</li>
<li>クラスの名で示された、型クラス</li>
<li>型の名前で示された型構築子、およびそれに続けて括弧で囲まれた関連するデータ構築子のリスト</li>
</ul>
<p>ここでは、 <code>Element</code>の<strong>型</strong>をエクスポートしていますが、データ構築子はエクスポートしていません。もしデータ構築子をエクスポートすると、モジュールの使用者が不正なHTML要素を構築できてしまいます。</p>
<p><code>Attribute</code>と<code>Content</code>型についてはデータ構築子をすべてエクスポートしています(エクスポートリストの記号<code>..</code>で示されています)。これから、これらの型にスマート構築子の手法を適用していきます。</p>
<p>すでにライブラリにいくつかの大きな改良を加わっていることに注意してください。</p>
<ul>
<li>不正な名前を持つHTML要素を表現することは不可能です(もちろん、ライブラリが提供する要素名に制限されています)。</li>
<li>閉じた要素は、構築するときに内容を含めることはできません。</li>
</ul>
<p><code>Content</code>型にもとても簡単にこの手法を適用することができます。単にエクスポートリストから<code>Content</code>型のデータ構築子を取り除き、次のスマート構築子を提供します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">text ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Content</span>
text <span class="fu">=</span> <span class="dt">TextContent</span>

elem<span class="ot"> ::</span> <span class="dt">Element</span> <span class="ot">-&gt;</span> <span class="dt">Content</span>
elem <span class="fu">=</span> <span class="dt">ElementContent</span></code></pre>
<p><code>Attribute</code>型にも同じ手法を適用してみましょう。まず、属性のための汎用のスマート構築子を用意します。最初の試みとしては、次のようなものになるかもしれません。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(:=) ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Attribute</span>
(<span class="fu">:=</span>) key value <span class="fu">=</span> <span class="dt">Attribute</span>
  { key<span class="fu">:</span> key
  , value<span class="fu">:</span> value
  }</code></pre>
<p>この定義では元の<code>Element</code>型と同じ問題に悩まされています。存在しなかったり、名前が間違っているような属性を表現することが可能です。この問題を解決するために、属性名を表すnewtypeを作成します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">AttributeKey</span> <span class="fu">=</span> <span class="dt">AttributeKey</span> <span class="dt">String</span></code></pre>
<p>それから、この演算子を次のように変更します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(:=) ::</span> <span class="dt">AttributeKey</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Attribute</span>
(<span class="fu">:=</span>) (<span class="dt">AttributeKey</span> key) value <span class="fu">=</span> <span class="dt">Attribute</span>
  { key<span class="fu">:</span> key
  , value<span class="fu">:</span> value
  }</code></pre>
<p><code>AttributeKey</code>データ構築子をエクスポートしなければ、明示的にエクスポートされた次のような関数を使う以外に、使用者が型<code>AttributeKey</code>の値を構築する方法はありません。いくつかの例を示します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">href ::</span> <span class="dt">AttributeKey</span>
href <span class="fu">=</span> <span class="dt">AttributeKey</span> <span class="st">&quot;href&quot;</span>

_<span class="ot">class ::</span> <span class="dt">AttributeKey</span>
_class <span class="fu">=</span> <span class="dt">AttributeKey</span> <span class="st">&quot;class&quot;</span>

<span class="ot">src ::</span> <span class="dt">AttributeKey</span>
src <span class="fu">=</span> <span class="dt">AttributeKey</span> <span class="st">&quot;src&quot;</span>

<span class="ot">width ::</span> <span class="dt">AttributeKey</span>
width <span class="fu">=</span> <span class="dt">AttributeKey</span> <span class="st">&quot;width&quot;</span>

<span class="ot">height ::</span> <span class="dt">AttributeKey</span>
height <span class="fu">=</span> <span class="dt">AttributeKey</span> <span class="st">&quot;height&quot;</span></code></pre>
<p>新しいモジュールの最終的なエクスポートリストは次のようになります。もうどんなデータ構築子も直接エクスポートしていないことに注意してください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Data.DOM.Smart</span>
  ( <span class="dt">Element</span>()
  , <span class="dt">Attribute</span>()
  , <span class="dt">Content</span>()
  , <span class="dt">AttributeKey</span>()

  , a
  , div
  , p
  , img

  , href
  , _class
  , src
  , width
  , height

  , (<span class="fu">:=</span>)
  , text
  , elem

  , render
  ) <span class="kw">where</span></code></pre>
<p><code>psci</code> でこの新しいモジュールを試してみると、コードが大幅に簡潔になり、改良されていることがわかります。</p>
<pre class="text"><code>&gt; :i Data.DOM.Smart
&gt; render $ p [ _class := &quot;main&quot; ] [ text &quot;Hello World!&quot; ]
  
&quot;&lt;p class=\&quot;main\&quot;&gt;Hello World!&lt;/p&gt;&quot;</code></pre>
<p>しかし、基礎のデータ表現が変更されていないので、<code>render</code>関数を変更する必要はなかったことにも注目してください。これはスマート構築子による手法の利点のひとつです。外部APIの使用者によって認識される表現から、モジュールの内部データ表現を分離することができるのです。</p>
<blockquote>
<h2 id="演習-47" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(簡単) <code>Data.DOM.Smart</code>モジュールで<code>render</code>を使った新しいHTML文書の作成を試してみましょう。</p></li>
<li><p>(やや難しい)　<code>checked</code>と<code>disabled</code>など、値を要求しないHTML属性がありますが、これらは次のような<strong>空の属性</strong>として表示されるかもしれません。</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span><span class="ot"> disabled</span><span class="kw">&gt;</span></code></pre>
<p>空の属性を扱えるように<code>Attribute</code>の表現を変更してください。要素に空の属性を追加するために、 <code>：(=)</code>の代わりに使える関数を記述してください。</p></li>
</ol>
</blockquote>
<h2 id="幻影型"><span class="header-section-number">14.5</span> 幻影型</h2>
<p>次に適用する手法についての動機を与えるために、次のコードを考えてみます。</p>
<pre class="text"><code>&gt; :i Data.DOM.Phantom
&gt; render $ img [ src    := &quot;cat.jpg&quot;
               , width  := &quot;foo&quot;
               , height := &quot;bar&quot; 
               ]
  
&quot;&lt;img src=\&quot;cat.jpg\&quot; width=\&quot;foo\&quot; height=\&quot;bar\&quot; /&gt;&quot;</code></pre>
<p>ここでの問題は、<code>width</code>と<code>height</code>についての文字列値を提供しているということで、ここで与えることができるのはピクセルやパーセントの単位の数値だけであるべきです。</p>
<p><code>AttributeKey</code>型にいわゆる<strong>幻影型</strong>(phantom type)引数を導入すると、この問題を解決できます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">AttributeKey</span> a <span class="fu">=</span> <span class="dt">AttributeKey</span> <span class="dt">String</span></code></pre>
<p>定義の右辺に対応する型<code>a</code>の値が存在しないので、この型変数<code>a</code>は<strong>幻影型</strong>と呼ばれています。この型<code>a</code>はコンパイル時により多くの情報を提供するためだけに存在しています。任意の型<code>AttributeKey a</code>の値は実行時には単なる文字列ですが、そのキーに関連付けられた値に期待されている型を教えてくれます。</p>
<p><code>AttributeKey</code>の新しい形式で受け取るように、<code>(:=)</code>演算子の型を次のように変更します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(:=) ::</span> forall a<span class="fu">.</span> (<span class="dt">IsValue</span> a) <span class="ot">=&gt;</span> <span class="dt">AttributeKey</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Attribute</span>
(<span class="fu">:=</span>) (<span class="dt">AttributeKey</span> key) value <span class="fu">=</span> <span class="dt">Attribute</span>
  { key<span class="fu">:</span> key
  , value<span class="fu">:</span> toValue value
  }</code></pre>
<p>ここで、ファントム型引数 <code>a</code>は、属性キーと属性値が互換性のある型を持っていることを確認するために使われます。使用者は<code>AttributeKey a</code>を型の値を直接作成できないので(ライブラリで提供されている定数を介してのみ得ることができます)、すべての属性が正しくなります。</p>
<p><code>IsValue</code>制約は、キーに関連付けられた値がなんであれ、その値を文字列に変換し、生成したHTML内に出力できることを保証します。<code>IsValue</code>型クラスは次のように定義されています。　　</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">IsValue</span> a <span class="kw">where</span>
<span class="ot">  toValue ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre>
<p><code>String</code>と<code>Number</code>型についての型クラスインスタンスも提供しておきます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> stringIsValue ::</span> <span class="dt">IsValue</span> <span class="dt">String</span> <span class="kw">where</span>
  toValue <span class="fu">=</span> id

<span class="kw">instance</span><span class="ot"> numberIsValue ::</span> <span class="dt">IsValue</span> <span class="dt">Number</span> <span class="kw">where</span>
  toValue <span class="fu">=</span> show</code></pre>
<p>また、これらの型が新しい型変数を反映するように、<code>AttributeKey</code>定数を更新しなければいけません。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">href ::</span> <span class="dt">AttributeKey</span> <span class="dt">String</span>
href <span class="fu">=</span> <span class="dt">AttributeKey</span> <span class="st">&quot;href&quot;</span>

_<span class="ot">class ::</span> <span class="dt">AttributeKey</span> <span class="dt">String</span>
_class <span class="fu">=</span> <span class="dt">AttributeKey</span> <span class="st">&quot;class&quot;</span>

<span class="ot">src ::</span> <span class="dt">AttributeKey</span> <span class="dt">String</span>
src <span class="fu">=</span> <span class="dt">AttributeKey</span> <span class="st">&quot;src&quot;</span>

<span class="ot">width ::</span> <span class="dt">AttributeKey</span> <span class="dt">Number</span>
width <span class="fu">=</span> <span class="dt">AttributeKey</span> <span class="st">&quot;width&quot;</span>

<span class="ot">height ::</span> <span class="dt">AttributeKey</span> <span class="dt">Number</span>
height <span class="fu">=</span> <span class="dt">AttributeKey</span> <span class="st">&quot;height&quot;</span></code></pre>
<p>これで、不正なHTML文書を表現することが不可能で、<code>width</code>と<code>height</code>属性を表現するのに数を使うことが強制されていることがわかります。</p>
<pre class="text"><code>&gt; :i Data.DOM.Phantom
&gt; render $ img [ src    := &quot;cat.jpg&quot;
               , width  := 100
               , height := 200 
               ]
  
&quot;&lt;img src=\&quot;cat.jpg\&quot; width=\&quot;100\&quot; height=\&quot;200\&quot; /&gt;&quot;</code></pre>
<blockquote>
<h2 id="演習-48" class="unnumbered">演習　</h2>
<ol type="1">
<li><p>(簡単) ピクセルまたはパーセントの長さのいずれかを表すデータ型を作成してください。その型について <code>IsValue</code>のインスタンスを書いてください。この型を使うように<code>width</code>と<code>height</code>属性を変更してください。</p></li>
<li><p>(難しい) ファントム型を使って真偽値<code>true</code>、<code>false</code>についての表現を最上位で定義することで、<code>AttributeKey</code>が<code>disabled</code>や<code>chacked</code>のような<strong>空の属性</strong>を表現しているかどうかを符号化することができます。、</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">True</span>
<span class="kw">data</span> <span class="dt">False</span></code></pre>
<p>ファントム型を使って、使用者が<code>(:=)</code>演算子を空の属性に対して使うことを防ぐように、前の演習の解答を変更してください。</p></li>
</ol>
</blockquote>
<h2 id="freeモナド"><span class="header-section-number">14.6</span> Freeモナド</h2>
<p>APIに施す最後の変更は、<code>Content</code>型をモナドにしてdo記法を使えるようにするために、<strong>Freeモナド</strong>と呼ばれる構造を使うことです。Freeモナドは、入れ子になった要素をわかりやすくなるよう、HTML文書の構造化を可能にします。次のようなコードを考えます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">p [ _class <span class="fu">:=</span> <span class="st">&quot;main&quot;</span> ]
  [ elem <span class="fu">$</span> img 
      [ src    <span class="fu">:=</span> <span class="st">&quot;cat.jpg&quot;</span>
      , width  <span class="fu">:=</span> <span class="dv">100</span>
      , height <span class="fu">:=</span> <span class="dv">200</span> 
      ]
  , text <span class="st">&quot;A cat&quot;</span>
  ]</code></pre>
<p>これを次のように書くことができるようになります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">p [ _class <span class="fu">:=</span> <span class="st">&quot;main&quot;</span> ] <span class="fu">$</span> <span class="kw">do</span>
  elem <span class="fu">$</span> img 
    [ src    <span class="fu">:=</span> <span class="st">&quot;cat.jpg&quot;</span>
    , width  <span class="fu">:=</span> <span class="dv">100</span>
    , height <span class="fu">:=</span> <span class="dv">200</span> 
    ]
  text <span class="st">&quot;A cat&quot;</span></code></pre>
<p>しかし、do記法だけがFreeモナドの恩恵だというわけではありません。モナドのアクションの<strong>表現</strong>をその<strong>解釈</strong>から分離し、同じアクションに<strong>複数の解釈</strong>を持たせることをFreeモナドは可能にします。</p>
<p><code>Free</code>モナドは<code>purescript-free</code>ライブラリの<code>Control.Monad.Free</code>モジュールで定義されています。<code>psci</code>を使うと、次のようにFreeモナドについての基本的な情報を見ることができます。</p>
<pre class="text"><code>&gt; :i Control.Monad.Free
&gt; :k Free
(* -&gt; *) -&gt; * -&gt; *</code></pre>
<p><code>Free</code>の種は、引数として型構築子を取り、別の型構築子を返すことを示しています。実は、<code>Free</code>モナドは任意の<code>Functor</code>を<code>Monad</code>にするために使うことができます！</p>
<p>モナドのアクションの<strong>表現</strong>を定義することから始めます。これを行うには、サポートする各モナドアクションそれぞれについて、ひとつのデータ構築子を持つ<code>Functor</code>を作成する必要があります。今回の場合、2つのモナドのアクションは<code>elem</code>と<code>text</code>になります。実際には、<code>Content</code>型を次のように変更するだけです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ContentF</span> a
  <span class="fu">=</span> <span class="dt">TextContent</span> <span class="dt">String</span> a
  <span class="fu">|</span> <span class="dt">ElementContent</span> <span class="dt">Element</span> a

<span class="kw">instance</span><span class="ot"> functorContentF ::</span> <span class="dt">Functor</span> <span class="dt">ContentF</span> <span class="kw">where</span>
  (<span class="fu">&lt;$&gt;</span>) f (<span class="dt">TextContent</span> s a) <span class="fu">=</span> <span class="dt">TextContent</span> s (f a)
  (<span class="fu">&lt;$&gt;</span>) f (<span class="dt">ElementContent</span> e a) <span class="fu">=</span> <span class="dt">ElementContent</span> e (f a)</code></pre>
<p>ここで、この<code>ContentF</code>型構築子は以前の<code>Content</code>データ型とよく似ています。<code>Functor</code>インスタンスでは、単に各データ構築子で型<code>a</code>の構成要素に関数<code>f</code>を適用します。</p>
<p>これにより、最初の型引数として<code>ContentF</code>型構築子を使うことで構築された、新しい<code>Content</code>型構築子を<code>Free</code>モナドを包むnewtypeとして定義することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Content</span> a <span class="fu">=</span> <span class="dt">Content</span> (<span class="dt">Free</span> <span class="dt">ContentF</span> a)</code></pre>
<p>ここでnewtypeを使っているのは、使用者に対してライブラリの内部表現を露出することを避けるためです。<code>Content</code>データ構築子を隠すことで、提供しているモナドのアクションだけを使うことを仕様者に制限しています。</p>
<p><code>ContentF</code>は<code>Functor</code>なので、<code>Free ContentF</code>に対する<code>Monad</code>インスタンスが自動的に手に入り、このインスタンスを<code>Content</code>上の<code>Monad</code>インスタンスへと持ち上げることができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runContent ::</span> forall a<span class="fu">.</span> <span class="dt">Content</span> a <span class="ot">-&gt;</span> <span class="dt">Free</span> <span class="dt">ContentF</span> a
runContent (<span class="dt">Content</span> x) <span class="fu">=</span> x

<span class="kw">instance</span><span class="ot"> functorContent ::</span> <span class="dt">Functor</span> <span class="dt">Content</span> <span class="kw">where</span>
  (<span class="fu">&lt;$&gt;</span>) f (<span class="dt">Content</span> x) <span class="fu">=</span> <span class="dt">Content</span> (f <span class="fu">&lt;$&gt;</span> x)

<span class="kw">instance</span><span class="ot"> applyContent ::</span> <span class="dt">Apply</span> <span class="dt">Content</span> <span class="kw">where</span>
  (<span class="fu">&lt;*&gt;</span>) (<span class="dt">Content</span> f) (<span class="dt">Content</span> x) <span class="fu">=</span> <span class="dt">Content</span> (f <span class="fu">&lt;*&gt;</span> x)

<span class="kw">instance</span><span class="ot"> applicativeContent ::</span> <span class="dt">Applicative</span> <span class="dt">Content</span> <span class="kw">where</span>
  pure <span class="fu">=</span> <span class="dt">Content</span> <span class="fu">&lt;&lt;&lt;</span> pure

<span class="kw">instance</span><span class="ot"> bindContent ::</span> <span class="dt">Bind</span> <span class="dt">Content</span> <span class="kw">where</span>
  (<span class="fu">&gt;&gt;=</span>) (<span class="dt">Content</span> x) f <span class="fu">=</span> <span class="dt">Content</span> (x <span class="fu">&gt;&gt;=</span> (runContent <span class="fu">&lt;&lt;&lt;</span> f))

<span class="kw">instance</span><span class="ot"> monadContent ::</span> <span class="dt">Monad</span> <span class="dt">Content</span></code></pre>
<p><code>Content</code>の新しい型引数を考慮するように、少し<code>Element</code>データ型を変更する必要があります。モナドの計算の戻り値の型が<code>Unit</code>であることだけが要求されます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Element</span> <span class="fu">=</span> <span class="dt">Element</span>
  {<span class="ot"> name         ::</span> <span class="dt">String</span>
  ,<span class="ot"> attribs      ::</span> [<span class="dt">Attribute</span>]
  ,<span class="ot"> content      ::</span> <span class="dt">Maybe</span> (<span class="dt">Content</span> <span class="dt">Unit</span>)
  }</code></pre>
<p>また、 <code>Content</code>モナドについての新しいモナドのアクションになる<code>elem</code>と<code>text</code>関数を変更する必要があります。これを行うには、 <code>Control.Monad.Free</code>モジュールで提供されている<code>liftF</code>関数を使います。この関数の(簡略化された)型は次のようになっています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">liftF ::</span> forall f a<span class="fu">.</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Free</span> f a</code></pre>
<p><code>liftF</code>は、何らかの型<code>a</code>について、型<code>f a</code>の値からFreeモナドのアクションを構築できるようにします。今回の場合、<code>ContentF</code>型構築子のデータ構築子を次のようにそのまま使うだけです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">text ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Content</span> <span class="dt">Unit</span>
text s <span class="fu">=</span> <span class="dt">Content</span> <span class="fu">$</span> liftF <span class="fu">$</span> <span class="dt">TextContent</span> s unit

elem<span class="ot"> ::</span> <span class="dt">Element</span> <span class="ot">-&gt;</span> <span class="dt">Content</span> <span class="dt">Unit</span>
elem e <span class="fu">=</span> <span class="dt">Content</span> <span class="fu">$</span> liftF <span class="fu">$</span> <span class="dt">ElementContent</span> e unit</code></pre>
<p>他にもコードの変更はありますが、興味深い変更は<code>render</code>関数に対してのものです。ここでは、このFreeモナドを<strong>解釈</strong>しなければいけません。</p>
<h2 id="モナドの解釈"><span class="header-section-number">14.7</span> モナドの解釈</h2>
<p><code>Control.Monad.Free</code>モジュールでは、Freeモナドで計算を解釈するための多数の関数が提供されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">go ::</span> forall f a<span class="fu">.</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> 
  (f (<span class="dt">Free</span> f a) <span class="ot">-&gt;</span> <span class="dt">Free</span> f a) <span class="ot">-&gt;</span> 
  <span class="dt">Free</span> f a <span class="ot">-&gt;</span> 
  a
  
<span class="ot">goM ::</span> forall f m a<span class="fu">.</span> (<span class="dt">Functor</span> f, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> 
  (f (<span class="dt">Free</span> f a) <span class="ot">-&gt;</span> m (<span class="dt">Free</span> f a)) <span class="ot">-&gt;</span> 
  <span class="dt">Free</span> f a <span class="ot">-&gt;</span> 
  m a
  
<span class="ot">iterM ::</span> forall f m a<span class="fu">.</span> (<span class="dt">Functor</span> f, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> 
  (forall a<span class="fu">.</span> f (m a) <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> 
  <span class="dt">Free</span> f a <span class="ot">-&gt;</span> 
  m a</code></pre>
<p><strong>純粋な</strong>結果を計算するためにFreeモナドを使いたいなら、 <code>go</code>関数が便利です。<code>goM</code>関数と<code>iterM</code>関数は、モナドを使用してFreeモナドのアクションを解釈することができます。この2つの関数は解釈関数の型が若干異なりますが、ここでは<code>iterM</code>関数を使います。興味のある読者は、代わりに<code>goM</code>関数を使用してこのコードを再実装してみるといいでしょう。</p>
<p>まず、アクションを解釈することができるモナドを選ばなければなりません。<code>Writer String</code>モナドを使って、結果のHTML文字列を累積することにします。</p>
<p>新しい<code>render</code>メソッドは補助関数<code>renderElement</code>に移譲して開始し、<code>Writer</code>モナドで計算を実行するため<code>execWriter</code>を使用します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">render ::</span> <span class="dt">Element</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
render e <span class="fu">=</span> execWriter <span class="fu">$</span> renderElement e</code></pre>
<p><code>renderElement</code>はwhereブロックで定義されています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">where</span>
<span class="ot">  renderElement ::</span> <span class="dt">Element</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> <span class="dt">String</span> <span class="dt">Unit</span>
  renderElement (<span class="dt">Element</span> e) <span class="fu">=</span> <span class="kw">do</span></code></pre>
<p><code>renderElement</code> の定義は簡単で、いくつかの小さな文字列を累積するために<code>Writer</code>モナドの<code>tell</code>アクションを使っています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    tell <span class="st">&quot;&lt;&quot;</span>
    tell e<span class="fu">.</span>name
    for_ e<span class="fu">.</span>attribs <span class="fu">$</span> \a <span class="ot">-&gt;</span> <span class="kw">do</span>
      tell <span class="st">&quot; &quot;</span>
      renderAttribute a
    renderContent e<span class="fu">.</span>content</code></pre>
<p>次に、同じように簡単な<code>renderAttribute</code>関数を定義します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">where</span>
<span class="ot">    renderAttribute ::</span> <span class="dt">Attribute</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> <span class="dt">String</span> <span class="dt">Unit</span>
    renderAttribute (<span class="dt">Attribute</span> a) <span class="fu">=</span> <span class="kw">do</span>
      tell a<span class="fu">.</span>key
      tell <span class="st">&quot;=\&quot;&quot;</span>
      tell a<span class="fu">.</span>value
      tell <span class="st">&quot;\&quot;&quot;</span></code></pre>
<p><code>renderContent</code>関数は、もっと興味深いものです。ここでは、<code>iterM</code>関数を使って、Freeモナドの内部で補助関数<code>renderContentItem</code>に移譲する計算を解釈しています。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">    renderContent ::</span> <span class="dt">Maybe</span> (<span class="dt">Content</span> <span class="dt">Unit</span>) <span class="ot">-&gt;</span> <span class="dt">Writer</span> <span class="dt">String</span> <span class="dt">Unit</span>
    renderContent <span class="dt">Nothing</span> <span class="fu">=</span> tell <span class="st">&quot; /&gt;&quot;</span>
    renderContent (<span class="dt">Just</span> (<span class="dt">Content</span> content)) <span class="fu">=</span> <span class="kw">do</span>
      tell <span class="st">&quot;&gt;&quot;</span>
      iterM renderContentItem content
      tell <span class="st">&quot;&lt;/&quot;</span>
      tell e<span class="fu">.</span>name
      tell <span class="st">&quot;&gt;&quot;</span></code></pre>
<p><code>renderContentItem</code>の型は<code>iterM</code>の型シグネチャから推測することができます。関手<code>f</code>は型構築子<code>ContentF</code>で、モナド<code>m</code>は解釈している計算のモナド、つまり<code>Writer String</code>です。これにより<code>renderContentItem</code> について次の型シグネチャがわかります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">    renderContentItem ::</span> forall a<span class="fu">.</span> <span class="dt">ContentF</span> (<span class="dt">Writer</span> <span class="dt">String</span> a) <span class="ot">-&gt;</span> <span class="dt">Writer</span> <span class="dt">String</span> a</code></pre>
<p><code>ContentF</code>の二つのデータ構築子でパターン照合するだけで、この関数を実装することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    renderContentItem (<span class="dt">TextContent</span> s rest) <span class="fu">=</span> <span class="kw">do</span>
      tell s
      rest
    renderContentItem (<span class="dt">ElementContent</span> e rest) <span class="fu">=</span> <span class="kw">do</span>
      renderElement e
      rest</code></pre>
<p>それぞれの場合において、式<code>rest</code>は型<code>Writer String</code>を持っており、解釈計算の残りを表しています。<code>rest</code>アクションを呼び出すことによって、それぞれの場合を完了することができます。</p>
<p>これで完了です！<code>psci</code>で、次のように新しいモナドのAPIを試してみましょう。</p>
<pre class="text"><code>&gt; :i Data.DOM.Free
&gt; render $ p [] $ do
    elem $ img [ src := &quot;cat.jpg&quot; ]
    text &quot;A cat&quot;
  
&quot;&lt;p&gt;&lt;img src=\&quot;cat.jpg\&quot; /&gt;A cat&lt;/p&gt;&quot;</code></pre>
<blockquote>
<h2 id="演習-49" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(やや難しい) <code>ContentF</code>型に新しいデータ構築子を追加して、生成されたHTMLにコメントを出力する新しいアクション<code>comment</code>に対応してください。<code>liftF</code>を使ってこの新しいアクションを実装してください。新しい構築子を適切に解釈するように、解釈<code>renderContentItem</code>を更新してください。</p></li>
<li><p>(難しい)　<code>goM</code>と<code>iterM</code>関数の問題のひとつに、<strong>スタック安全</strong>でないというものがあります。大きいモナドのアクションは、解釈したときにスタックオーバーフローを引き起こす可能性があるのです。しかしながら、<code>Control.Monad.Free</code>ライブラリは、スタック安全な <code>go</code>と<code>goEff</code>関数を提供しています。<code>Writer</code>モナドの代わりに<code>ST</code>作用を利用して、<code>goEff</code>関数を使って<code>Content</code>モナドを解釈してください。</p></li>
</ol>
</blockquote>
<h2 id="言語の拡張"><span class="header-section-number">14.8</span> 言語の拡張</h2>
<p>すべてのアクションが型<code>Unit</code>の何かを返すようなモナドは、さほど興味深いものではありません。実際のところ、概ね良くなったと思われる構文は別として、このモナドは<code>Monoid</code>以上の機能は何の追加していません。</p>
<p>意味のある結果を返す新しいモナドアクションでこの言語を拡張することで、Freeモナド構造の威力を説明しましょう​​。</p>
<p><strong>アンカー</strong>を使用して文書のさまざまな節へのハイパーリンクが含まれているHTML文書を生成するとします。手作業でアンカーの名前を生成すればいいので、これは既に実現できています。文書中で少なくとも２回、ひとつはアンカーの定義自身に、もうひとつはハイパーリンクに、アンカーが含まれています。しかし、この方法には根本的な問題がいくつかあります。</p>
<ul>
<li>開発者は一意なアンカー名を生成するために失敗することがあります。</li>
<li>開発者は、アンカー名のひとつまたは複数のインスタンスを誤って入力するかもしれません。</li>
</ul>
<p>自分の間違いから開発者を保護するために、アンカー名を表す新しい型を導入し、新しい一意な名前を生成するためのモナドアクションを提供することができます。</p>
<p>最初の手順は、名前の型を新しく追加することです。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">Name</span> <span class="dt">String</span>

<span class="ot">runName ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
runName (<span class="dt">Name</span> n) <span class="fu">=</span> n</code></pre>
<p>繰り返しになりますが、<code>Name</code>は<code>String</code>のnewtypeとして定義しており、モジュールのエクスポートリスト内でデータ構築子をエクスポートしないように注意する必要があります。</p>
<p>次に、属性値として<code>Name</code>を使うことができるように、新しい型<code>IsValue</code>型クラスのインスタンスを定義します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> nameIsValue ::</span> <span class="dt">IsValue</span> <span class="dt">Name</span> <span class="kw">where</span>
  toValue (<span class="dt">Name</span> n) <span class="fu">=</span> n</code></pre>
<p>また、次のように<code>a</code>要素に現れるハイパーリンクの新しいデータ型を定義します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Href</span>
  <span class="fu">=</span> <span class="dt">URLHref</span> <span class="dt">String</span>
  <span class="fu">|</span> <span class="dt">AnchorHref</span> <span class="dt">Name</span>

<span class="kw">instance</span><span class="ot"> hrefIsValue ::</span> <span class="dt">IsValue</span> <span class="dt">Href</span> <span class="kw">where</span>
  toValue (<span class="dt">URLHref</span> url) <span class="fu">=</span> url
  toValue (<span class="dt">AnchorHref</span> (<span class="dt">Name</span> nm)) <span class="fu">=</span> <span class="st">&quot;#&quot;</span> <span class="fu">++</span> nm</code></pre>
<p><code>href</code>属性の型の値を変更して、この新しい<code>Href</code>型の使用を強制します。また、要素をアンカーに変換するのに使う新しい<code>name</code>属性を作成します。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">href ::</span> <span class="dt">AttributeKey</span> <span class="dt">Href</span>
href <span class="fu">=</span> <span class="dt">AttributeKey</span> <span class="st">&quot;href&quot;</span>

<span class="ot">name ::</span> <span class="dt">AttributeKey</span> <span class="dt">Name</span>
name <span class="fu">=</span> <span class="dt">AttributeKey</span> <span class="st">&quot;name&quot;</span></code></pre>
<p>残りの問題は、現在モジュールの使用者が新しい名前を生成する方法がないということです。<code>Content</code>モナドでこの機能を提供することができます。まず、<code>ContentF</code>型構築子に新しいデータ構築子を追加する必要があります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ContentF</span> a
  <span class="fu">=</span> <span class="dt">TextContent</span> <span class="dt">String</span> a
  <span class="fu">|</span> <span class="dt">ElementContent</span> <span class="dt">Element</span> a
  <span class="fu">|</span> <span class="dt">NewName</span> (<span class="dt">Name</span> <span class="ot">-&gt;</span> a)</code></pre>
<p><code>NewName</code>データ構築子は型<code>Name</code>の値を返すアクションに対応しています。データ構築子の引数として<code>Name</code>を要求するのではなく、型<code>Name -&gt; a</code>の<strong>関数</strong>を提供するように使用者に要求していることに注意してください。型<code>a</code>は<strong>計算の残り</strong>を表していることを思い出すと、この関数は、型<code>Name</code>の値が返されたあとで、計算を継続する方法を提供するというように直感的に理解することができます。</p>
<p>新しいデータ構築子を考慮するように、<code>ContentF</code>についての<code>Functor</code>インスタンスを更新する必要があります。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span class="ot"> functorContentF ::</span> <span class="dt">Functor</span> <span class="dt">ContentF</span> <span class="kw">where</span>
  (<span class="fu">&lt;$&gt;</span>) f (<span class="dt">TextContent</span> s a) <span class="fu">=</span> <span class="dt">TextContent</span> s (f a)
  (<span class="fu">&lt;$&gt;</span>) f (<span class="dt">ElementContent</span> e a) <span class="fu">=</span> <span class="dt">ElementContent</span> e (f a)
  (<span class="fu">&lt;$&gt;</span>) f (<span class="dt">NewName</span> k) <span class="fu">=</span> <span class="dt">NewName</span> (f <span class="fu">&lt;&lt;&lt;</span> k)</code></pre>
<p>そして、先ほど述べたように、<code>liftF</code>関数を使うと新しいアクションを構築することができます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">newName ::</span> <span class="dt">Content</span> <span class="dt">Name</span>
newName <span class="fu">=</span> <span class="dt">Content</span> <span class="fu">$</span> liftF <span class="fu">$</span> <span class="dt">NewName</span> id</code></pre>
<p><code>id</code>関数を継続として提供していることに注意してください。型<code>Name</code>の結果を変更せずに返すということを意味しています。</p>
<p>最後に、新しいアクションを解釈するために、解釈関数を更新する必要があります。以前は計算を解釈するために<code>Writer String</code>モナドを使っていましたが、このモナドは新しい名前を生成する能力を持っていないので、何か他のものに切り替えなければなりません。<code>RWS</code>モナドなら、<code>Writer</code>の機能を提供するだけでなく、純粋な状態を扱うことができます。型シグネチャを短く保てるように、この解釈モナドを型同義語としての定義しておきます。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Interp</span> <span class="fu">=</span> <span class="dt">RWS</span> <span class="dt">Unit</span> <span class="dt">String</span> <span class="dt">Number</span></code></pre>
<p><code>RWS</code>モナドは3つの型引数を取ることを思い出してください。 最初は大域的な設定で、今回は単なる<code>Unit</code>です。２つめは「ログ」型で、累積するH TML文字列です。最後の引数は状態の型で、この場合は増加していくカウンタとして振る舞う数で、一意な名前を生成するのに使われます。</p>
<p><code>Writer</code>と<code>RWS</code>モナドはそれらのアクションを抽象化するのに同じ型クラスメンバを使うので、どのアクションも変更する必要がありません。必要なのは、<code>Writer String</code>への参照すべてを<code>Interp</code>で置き換えることだけです。しかし、この計算を実行するために使われるハンドラを変更しなければいけません。<code>execWriter</code>の代わりに、<code>evalRWS</code>を使います。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">render ::</span> <span class="dt">Element</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
render e <span class="fu">=</span> snd <span class="fu">$</span> evalRWS (renderElement e) unit <span class="dv">0</span></code></pre>
<p><code>snd</code>の呼び出しは<code>evalRWS</code>から返された<code>Tuple</code>の<strong>２番めの要素</strong>だけを返すようにします。この場合は、累積されたHTML文字列を表しています。</p>
<p>新しい<code>NewName</code>データ構築子を解釈するために、<code>renderContentItem</code>に新しい場合分けを追加しなければいけません。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    renderContentItem (<span class="dt">NewName</span> k) <span class="fu">=</span> <span class="kw">do</span>
      n <span class="ot">&lt;-</span> get
      <span class="kw">let</span> name <span class="fu">=</span> <span class="dt">Name</span> <span class="fu">$</span> <span class="st">&quot;name&quot;</span> <span class="fu">++</span> show n
      put <span class="fu">$</span> n <span class="fu">+</span> <span class="dv">1</span>
      k name</code></pre>
<p>ここで、型<code>Name -&gt; Interp a</code>の継続<code>k</code>が与えられているので、型<code>Interp a</code>の解釈を構築しなければいけません。この解釈は単純です。<code>get</code>を使って状態を読み、その状態を使って一意な名前を生成し、それから<code>put</code>で状態をインクリメントしています。最後に、継続にこの新しい名前を渡して、計算を完了します。</p>
<p>これにより、<code>psci</code>で、<code>Content</code>モナドの内部で一意な名前を生成し、要素の名前とハイパーリンクのリンク先の両方を使って、この新しい機能を試してみましょう。</p>
<pre class="text"><code>&gt; :i Data.DOM.Name
&gt; render $ p [ ] $ do
    top &lt;- newName
    elem $ a [ name := top ] $ 
      text &quot;Top&quot;
    elem $ a [ href := AnchorHref top1 ] $ 
      text &quot;Back to top&quot;
  
&quot;&lt;p&gt;&lt;a name=\&quot;name0\&quot;&gt;Top&lt;/a&gt;&lt;a href=\&quot;#name0\&quot;&gt;Back to top&lt;/a&gt;&lt;/p&gt;&quot;</code></pre>
<p>複数回の<code>newName</code>呼び出しの結果が、実際に一意な名前になっていることを確かめてみてください。</p>
<blockquote>
<h2 id="演習-50" class="unnumbered">演習</h2>
<ol type="1">
<li><p>(やや難しい) 使用者から<code>Element</code>型を隠蔽すると、さらにAPIを簡素化することができます。次の手順に従って、これらの変更を行ってください。</p>
<ul>
<li><code>p</code>や<code>img</code>のような(返り値が<code>Element</code>の)関数を<code>elem</code>アクションと結合して、型<code>Content Unit</code>を返す新しいアクションを作ってください。</li>
<li>型<code>Content a</code>の引数を許容し、結果の型<code>Tuple String</code>を返すように、<code>render</code>関数を変更してください。</li>
</ul></li>
<li><p>(難しい) 次の新しいアクションをサポートするように、<code>ContentF</code>タイプを変更してください。</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isMobile ::</span> <span class="dt">Content</span> <span class="dt">Boolean</span></code></pre></li>
</ol>
<p>　 このアクションは、この文書がモバイルデバイス上での表示のためにレンダリングされているかどうかを示す真偽値を返します。 　<br />　 <strong>ヒント</strong>： <code>RWS</code>モナドの<code>ask</code>アクションと <code>Reader</code>コンポーネントを使って、このアクションを解釈してください。</p>
</blockquote>
<h2 id="まとめ-12"><span class="header-section-number">14.9</span> まとめ</h2>
<p>この章では、いくつかの標準的な技術を使って、単純な実装を段階的に改善することにより、HTML文書を作成するための領域特化言語を開発しました。</p>
<ul>
<li>データ表現の詳細を隠蔽し、<strong>構築方法により正しい</strong>文書を作ることだけを許可するために、<strong>スマート構築子</strong>を使いました。</li>
<li>言語の構文を改善するために、<strong>ユーザ定義の中置２項演算子</strong>を使用しました。</li>
<li>使用者が間違った型の属性値を提供するのを防ぐために、データの型に追加の情報を符号化する<strong>幻影型</strong>を使用しました。</li>
<li>Freeモナドを使って、内容の集まりの配列内包表記をdo表記を提供するモナド表現に変換しました。モナドの新しいアクションをサポートするためにこの表現を拡張し、<code>Writer</code>と<code>RWS</code>モナドでモナド計算を解釈しました。</li>
</ul>
<p>使用者が間違いを犯すのを防ぎ、領域特化言語の構文を改良するために、これらの手法はすべてPureScriptのモジュールと型システムを活用しています。</p>
<p>関数型プログラミング言語による領域特化言語の実装は活発に研究されている分野ですが、いくつかの簡単なテクニックに対して役に立つ導入を提供し、表現力豊かな型を持つ言語で作業すること威力を示すことができていれば幸いです。</p>
      <p class="previous" style="visibility:hidden;"><a href="index.html">&lt; 目次に戻る</a></p>
    </div>

    <script>
        if(location.pathname !== "/purescript/" && location.pathname !== "/purescript/index.html"){
            Array.prototype.forEach.call(document.querySelectorAll(".previous"), function(elem){
                elem.style.visibility = "visible";
            });
        }
    </script>
  </div>
</body>
</html>
