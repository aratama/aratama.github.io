<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@cubbit2"><meta name="twitter:creator" content="@cubbit2"><meta name="twitter:title" content="モナドのまほう　第４話『WebGLとCannonでどう見てもマインクラフトです』 - ちょっと小さいのはたしかですが。"><meta name="twitter:description" content="Admittedly something small."><meta name="twitter:image" content="/img/fc43ae6c-da24-aab2-65e6-d7307350cdb2.png"><link rel="icon" href="icon.png"><link rel="stylesheet" href="/res/reset.css"><link rel="stylesheet" href="/res/style.css"><title>モナドのまほう　第４話『WebGLとCannonでどう見てもマインクラフトです』 - ちょっと小さいのはたしかですが。</title><script>
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-61162129-3', 'auto');
                ga('send', 'pageview');
            </script></head><body><header><div class="block-centered"><div class="site-title"><a href="/">ちょっと小さいのはたしかですが。</a></div><div class="sub-title">Admittedly something small.</div></div></header><div class="content"><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/res/article.css"><article id="rendered"><div class="date">2016年11月12日</div><h1 class="article-title"><a href="44f118b649367f010cb0.html">モナドのまほう　第４話『WebGLとCannonでどう見てもマインクラフトです』</a></h1><p class="tags"><a href="/blog/tag/JavaScript"><span class="tag"><i class="fa fa-tag"></i>JavaScript</span></a><a href="/blog/tag/WebGL"><span class="tag"><i class="fa fa-tag"></i>WebGL</span></a><a href="/blog/tag/CANNON.js"><span class="tag"><i class="fa fa-tag"></i>CANNON.js</span></a><a href="/blog/tag/purescript"><span class="tag"><i class="fa fa-tag"></i>purescript</span></a><a href="/blog/tag/関数型プログラミング"><span class="tag"><i class="fa fa-tag"></i>関数型プログラミング</span></a></p><hr><div><ul>
<li><a href="/blog/5321d8cebce7b87851f6.html">第一話　画像が表示できました</a>　←初回</li>
<li><a href="/blog/5d3f61339e84d2715f71.html">第三話　オンラインゲームになりました</a>　←前回</li>
</ul>
<p>ゲームを作る日記的なヤツのつづきです。今回あんまりコードが出てこないので面白くないと思います。</p><h1><a name="webgl-" class="anchor" href="#webgl-"><span class="header-link"></span></a>WebGL ゴリゴリ</h1><p>途中まではCanvas APIでグラフィックを描いていたのですが、暗闇の表現で画像をちょっと暗くして描画、みたいなことがやりにくくて、結局WebGLを直接叩いてグラフィックをゴリゴリ描いていくことにしました。PureScriptにも<a href="https://github.com/jutaro/purescript-webgl">WebGLバインディング</a>がすでにあるのですが、これはIDLから自動生成したもので、少々扱いづらいところがあります。これを使ったからと言ってあまり楽になるとも思えなかったので、WebGLを自力である程度高レベルにラップして叩いています。</p><p>ウェブ向けのライブラリとしてはthree.jsもよく知られています。筆者もthree.jsをちょっと試してみたことがあったのですが、今回はパスしました。グラフィックスAPIには<a href="https://msdn.microsoft.com/ja-jp/library/windows/desktop/ff684178(v=vs.85">保持モードと直接モード</a>.aspx)というのがあって、three.jsみたいなのは保持モードに相当します。保持モードのライブラリは『シーングラフ』などと呼ばれる独自のデータ構造を持っていて、そこに適宜オブジェクトを追加したり取り除いたりします。Cocos2DやHTMLのDOMやSVGなんかも保持モードの一種です。それに対して、CanvasAPIやWebGL、OpenGL、DirectXなんかはシーングラフを提供しない直接モードのAPIです。</p><p>一見、保持モードのAPIのほうが扱いやすそうなんですが、保持モードではシーングラフの状態を常に気にしながらコーディングする必要があります。3Dモデルを閲覧するだけのようなアプリケーションなら保持モードでもいいんですが、ゲームのようなアプリケーションではオブジェクトが頻繁に追加されたり削除されたりするわけで、あっさり状態を管理しそこねて画面にゴミなオブジェクトが残ったり、特定の状態の時だけ起こる再現性の低いバグに遭遇したりと、あまり良いことがありません。</p><p>人類は仮想DOMなんてものを発明してまでDOMというシーングラフから解放されようとあがいているのに、保持モードのAPIを備えるライブラリは、WebGLのシーングラフがないAPIにわざわざシーングラフを設けて管理すべき状態を作り出してしまっています。そういうAPIはあまり使いたくはありませんでした。</p><p>グラフィックAPIをWebGLに移行した副産物で、一人称視点でのプレイも出来るようになりました。現状のゲーム画面はこんな感じです。</p><p><a href="/img/fc43ae6c-da24-aab2-65e6-d7307350cdb2.png"><img src="/img/fc43ae6c-da24-aab2-65e6-d7307350cdb2.png"></img></a></p><p>オーケイ、スティーブ。君の言いたいことはよくわかる。これがマインクラフトそっくりであるという事実を認めるのは、私としてもやぶさかでない。でも、この画面を見た瞬間、君は言葉では言い表せない『ときめき』のようなものを感じてくれたと思う。実際、マインクラフトは良く出来ている。単純であるが、うまくデフォルメされ統一感のあるグラフィックデザイン。自由度が高く、クリエイティブで飽きのこないゲームシステム。一人称視点で没入感のある操作感。サンドボックス形式のゲームはマインクラフト以前にも存在したが、ゲーム実況が動画サイトで定着しつつあったという時流にもぴったりマッチしていた。実況者のオリジナリティを出しやすいモノづくりゲーほどプレイ実況に向いたゲームはない。マインクラフト以降、TerrariaやStarboundのような2Dスタイルのもの、RobocraftやFrom the Depthes、Besiegeのような乗り物デザインもの、Cube Worldのようなアクション、Space EngineersのようなSFチックなもの、まさしく雨後の筍のようにサンドボックスゲームが濫造されたが、その末席に筆者が加わろうと大した問題ではないだろう。</p><h1><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>フォントでちょっと雰囲気出したい！</h1><p>デザインではフォントは重要ですよね。今回はゲームということもあって、フォントでも楽しい雰囲気を演出したいと思い、<a href="http://www.fontna.com/blog/1706/">ラノベPOPフォント</a>を借りることにしました。こういう感じのフォントです。</p><p><a href="/img/5c02a317-6d4b-0c57-0c9f-bd86466c067a.png"><img src="/img/5c02a317-6d4b-0c57-0c9f-bd86466c067a.png"></img></a></p><p>これを<a href="https://developer.mozilla.org/ja/docs/Web/CSS/@font-face"><code>@fontface</code></a>で読み込むわけですが……このフォントファイル、1.5メガバイト弱もの大きさがあります。貧弱なネットワーク環境だと体感的にもちょっと待たされる感じです。</p><p>一見したところ、PureScriptが書き出すJavaScriptはかなり冗長に見えますが、現状のアプリケーションでせいぜい260キロバイトほど。<code>firebase.js</code>が300キロバイト以上あるので、現状では依存しているライブラリよりアプリケーション本体のほうが小さいです。そして、ここに1.5メガバイトのフォントファイル、さらに５メガバイトもあるBGMも読み込むつもりですから、もうスクリプト自体のファイルサイズなんてどうでもよくなるレベルです。</p><h1><a name="ui-" class="anchor" href="#ui-"><span class="header-link"></span></a>UIゴリゴリ</h1><p>今までひたすらCanvasにゴリゴリ描いていたんですが、そろそろUIも作らないと！</p><p>筆者が以前作った<a href="/blog/7b1b6eb45f8207ea96e4.html">コレ</a>ではpurescript-halogenというUIライブラリを使っていたんですが、今回はゲームということで<code>requestAnimationFrame</code>のタイミングでDOMを更新しまくるつもりなので、halogenがそういう用途に耐えられるか確信がありませんでした。一番の問題は、Halogenのようなライブラリでは状態を更新すると自動的に再描画も走ってしまうことです。通常のUIのインタラクションではこれは自然ですが、ゲームでは一定時間ごとに状態更新があり再描画しまくるので、外部からの入力で状態が変更されたとしてもすぐさま再描画を行う必要はないわけです。それどころか、どうせすぐあとで再描画するのに入力のたびに描画を走らせるのは明らかに過剰です。そこでIncremental-domを軽くラップして簡単なUIライブラリを自分で作ることにしました。</p><p>purescript-incrementalというincremental-domのラッパもすでにあるのですが、あんまりメンテナンスされている気配がないですし、APIもちょっと気に入らなかったのでそれも今回はスルー。</p><h1><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>物理演算ゴリゴリ</h1><p>PureScriptは純粋な言語であり、データは基本的にすべて不変になっています。このことは状態の管理をとても楽にしてくれるのですが、現実のアプリケーションではなかなかそううまくは行きません。ゲームではゲームループが回るたびに事実上アプリケーションの状態が変化していくわけで、このために<code>Ref</code>を使いました。そして、状態を扱うハメになるもうひとつの原因が、外部のライブラリが持つ状態です。</p><p>ウェブのDOMについては、ご存知のとおり、仮想DOMを使うと一切の状態を覆い隠して純粋な計算に見せかけることができます。今回はincremental-domでこれをクリアしました。そしてグラフィックについても、three.jsのような内部に専用のデータ構造を抱えるライブラリを避けて直接WebGLを叩くことでクリアしています。それで、物理演算についてはどうするかなんですが、今回は<a href="http://www.cannonjs.org/">Cannon.js</a>を使うことにしました。</p><p>物理エンジンライブラリのほとんどがそうであるように、Cannon.jsも内部に独自のデータ構造を持っています。そのため、せっかく状態管理を避け続けてきたのに、ここでまた新たに管理すべき状態を持ち込むことに……。本当はあまり気が進まないのですが、物理演算を自分で実装するのは相当に大変ですし、ゲームの致命的なボトルネックになりうるので、やむなくCannonに頼ることを選びました。仮想DOMみたいに、毎回新しくデータを与えれば差分だけを計算してくれるような物理エンジンがあるといいんですが……。それにFirebaseのデータベースの状態も状態の一種ですから、現実のアプリケーションでは状態のない理想的な世界にはまだまだ遠いです。</p><p>今回ぜんぜんコードを出してないですし、念のためにCannonを叩く部分のコード出しておきましょうか。純粋関数型プログラミング言語PureScriptといえど、実際書いてみたら見た目のうえではJavaScriptと大して変わりはありませんから、この部分はあんまり面白くないですよ？　JavaScriptならこんな感じ。</p><pre><code class="js">var sphere = new CANNON.Sphere(0.5);    // 半径0.5の球の形状を作成

var body = new CANNNON.Body({
    shape: sphere,                      // 形状をさっきつくったsphereにする
    mass: 1.0                           // 質量を1.0にする
});                                     

world.addBody(body);                    // 作成したBodyを空間に追加

step (1 / 60) world</code></pre><p>PureScriptならこんな感じです。</p><pre><code class="haskell">sphere &lt;- newSphere 0.5     -- 半径0.5の球の形状を作成

body &lt;- newBody {
    shape: sphere,          -- 形状をさっきつくったsphereにする
    mass: 1.0               -- 質量を1.0にする
}                        

world # addBody body        -- 作成したBodyを空間に追加

world # step (1.0 / 60.0)   -- 1 / 60時間を進める</code></pre><p>Cannonは内部に状態を持っており、<code>world</code>オブジェクトや<code>body</code>オブジェクトの状態は実際に書き換わっています。でもコードのうえではどちらの言語も大した差はないでしょう。それでも、『純粋関数型プログラミング言語だと副作用の扱いが大変』とかいうデマが飛び交っていますから困ったものです。え？　『<strong><code>world # addBody body</code>という式は、明らかに<code>world</code>オブジェクトの状態を書き換えている、どうみてもこの式には副作用があり、純粋でない</strong>』って？　いえいえ、ですから<strong>これらすべての式はあくまで純粋</strong>ですってば。『純粋関数型』ってそういうことじゃないんです。</p><p>今回絵文字使いませんでした。絵文字書くの面倒くさい……。</p><h1><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>次のお話</h1><ul>
<li><a href="/blog/7cba851de4d84a535bbb.html">第五話　Babylonjsでｹﾞｰﾄｵﾌﾞﾊﾞﾋﾞﾛﾝ</a></li>
</ul>
</div><div>
    
<hr style="margin-top: 60px;">

<div class="snsbuttons">

    <!-- Twitter -->
    <a href="https://twitter.com/share" class="twitter-share-button" data-related="cubbit2">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

    <!-- Hatena -->
    <div>
        <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="basic-label-counter" data-hatena-bookmark-lang="ja" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
    </div>

    <!-- line -->
    <div>
        <div class="line-it-button" style="display: none;" data-type="share-a" data-lang="ja" ></div>
        <script src="//scdn.line-apps.com/n/line_it/thirdparty/loader.min.js" async="async" defer="defer" ></script>
    </div>

    <!--facebook -->
    <div>
        <div id="fb-root"></div>
        <script>(function(d, s, id) {
        var js, fjs = d.getElementsByTagName(s)[0];
        if (d.getElementById(id)) return;
        js = d.createElement(s); js.id = id;
        js.src = "//connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v2.8";
        fjs.parentNode.insertBefore(js, fjs);
        }(document, 'script', 'facebook-jssdk'));</script>
        <div class="fb-like" data-href="https://aratama.github.io/blog/44f118b649367f010cb0.md" data-layout="button_count" data-action="like" data-size="small" data-show-faces="true" data-share="false"></div>
    </div>

    <!-- google+ -->
    <div>
        <script src="https://apis.google.com/js/platform.js" async defer>
        {lang: 'ja'}
        </script>
        <div class="g-plusone" data-size="medium"></div>
    </div>

</div>

</div></article></div><footer><div class="block-centered footer-inner"><p class="copy">&amp;nbsp;</p><p class="author">このブログを書いてる人:&amp;nbsp;&amp;nbsp; 竹内稲穂</p></div><script>
                    const poem = [
                        "なんにもない毎日が、なによりの宝物。",
                        "今日という日を、何度でも繰り返したい。",
                        "世界を追いかけなくても、世界は私のまわりにある。", 
                        "速すぎる雑踏。鼻先をくすぐる春風。", 
                        "明日撮る写真を飾る場所を、アルバムに空けておこう。", 
                        "落ち葉が地面に、触れる音がした。", 
                        "明日は、明日の楽しさが待っている。", 
                        "風が泣いている。この想いを紡ぐ言葉を持たないから。", 
                        "もうここには何もない。だから、次の場所に旅立とう。", 
                        "もう此処にはこないだろう。そう言って私は過去に背を向けた。", 
                        "散りゆくからこそ、美しい。私は桜の花びらをかかとで踏みしめた。", 
                        "思い出はいつだって輝いてる。",
                        "正直ばかりじゃつまらない。たまには楽しい嘘をつこう。", 
                        "ゆっくり歩けば歩くほど、時間がゆっくり過ぎてゆく。",
                        "夜明けを、探しにいこう。", 
                        "空はこんなに青かったんだ。", 
                        "地球は青かった。それはこの空を見上げたことのある全員が知っている。", 
                        "休み時間は、長すぎるということはない。", 
                        "缶コーヒーを飲むときだけは、それ以外のすべてを忘れることにしてる。", 
                        "ちょっと小さいのは確かですが、それは確かにここにあります。", 
                        "ちょっと小さいのは確かですが、広すぎる家というのも寂しいでしょう？", 
                        "ひつじが一匹、ひつじが二匹。五十匹までは、数えたことがある。"
                    ];
                    document.querySelector(".copy").textContent = poem[Math.floor(poem.length * Math.random())];
                </script></footer></body></html>