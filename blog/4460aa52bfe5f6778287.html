<title>逆引きLensサンプルコード - ちょっと小さいのはたしかですが。</title><!DOCTYPE html>
<meta charset="UTF-8">
<link type="text/css" rel="stylesheet" href="style.css">

<header>
    <div class="block-centered">
        <div class="site-title"><a href="/">ちょっと小さいのはたしかですが。</a></div>
        <div class="sub-title">わたしのブログです。面白いかどうかは、わかりませんが。</div>
    </div>
</header>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

<link rel="stylesheet" href="/res/highlight/styles/default.css">
<script src="/res/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$']]}
});
</script>

<link rel="stylesheet" href="../reset.css">
<link rel="stylesheet" href="../style.css">
<link rel="stylesheet" href="../article.css">


    <div class="content">

        <article id="rendered">
            <div class="date">2016年2月7日</div>
            <h1 class="article-title">
                <!-- <i class="fa fa-coffee" aria-hidden="true"></i> -->
                <a href="4460aa52bfe5f6778287.html">逆引きLensサンプルコード<a>
            </h1>        
            <p class="tags"><a href="Haskell.html"><span class="tag"><i class="fa fa-tag" aria-hidden="true"></i>Haskell</span></a>
<a href="purescript.html"><span class="tag"><i class="fa fa-tag" aria-hidden="true"></i>purescript</span></a></p>
            <hr>
            <!-- {
  "id": "4460aa52bfe5f6778287",
  "created_at": "2016-02-07T02:07:17+09:00",
  "tags": [
    {
      "name": "Haskell",
      "versions": []
    },
    {
      "name": "purescript",
      "versions": []
    }
  ],
  "title": "逆引きLensサンプルコード"
} -->
<p>複雑なデータ構造の内部への読み書きを抽象化するライブラリ<a href="/blog/https://github.com/ekmett/lens.html">Lens</a>の練習メモです。言語はPureScriptを使っています。この記事はHaskellな人も読めなくはないと思いますが、PureScriptとHaskellでは異なる部分が結構あるので注意してください。パッケージは<a href="/blog/https://github.com/purescript-contrib/purescript-profunctor-lenses.html"><code>purescript-profunctor-lenses</code></a>を使っています<a href="/blog/`purescript-lens`というライブラリもあるのですが、こちらは古いライブラリでもう使われていないようです。.html">^lib</a>。</p>
<h1><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>単純なオブジェクトのプロパティの読み書き</h1><pre><code class="hs">-- 読み書きしたいデータの型
type Task = { name :: String, completed :: Boolean }</code></pre><pre><code class="hs">-- サンプルデータ
task :: Task
task = { name: "meeting", completed: false }</code></pre><pre><code class="hs">-- Lensの定義
name :: forall a b . Lens { name :: a | b } { name :: a | b } a a 
name = lens _.name _ { name = _ }

completed :: forall a b . Lens { completed :: a | b } { completed :: a | b } a a 
completed = lens _.completed _ { completed = _ }</code></pre><pre><code class="hs">-- lensを使わない通常のプロパティ読み取り
-- ここの『name』はLensの`name`じゃなくて、JavaScriptと同様のそういう専用の構文です
task.name          -- "meeting"

-- view関数と先ほど定義したLensのnameを使ったプロパティ読み取り
view name task     -- "meeting"

-- ^.演算子(viewの別名)によるのプロパティ読み取り
-- viewとは引数の順序が逆転しているのに注意
task ^. name         -- "meeting"

-- 通常のプロパティ書き込み構文。
-- ここのcompletedもLensじゃなくてそういう構文です
-- JavaScriptでいう task.completed = true; というコードの意図に近い操作です。
task { completed = true }    -- { name: "meeting", completed: true }

-- set関数とLensのcompleteを使った書き込み
set completed true task      -- { name: "meeting", completed: true }

-- .~演算子
(completed .~ true) task     -- { name: "meeting", completed: true }

-- #演算子も使うと語順が自然に
task # completed .~ true     -- { name: "meeting", completed: true }</code></pre><h1><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>配列の読み書き</h1><pre><code class="haskell">-- サンプルデータ
xs :: Array String
xs = ["zero", "one", "two"]

ys :: Array Int
ys = [10, 20, 30]</code></pre><pre><code class="hs">-- 通常の!!演算子でのアクセス
xs !! 1        -- Just "one"

-- ix関数で指定したインデックスへのアクセサを作れます
-- 基本的には^.演算子ではなく^?演算子のほうを使います
xs ^? ix 1     -- Just "one"

-- 範囲外へのアクセスはNothingが返ります
xs ^? ix 100   -- Nothing

-- view関数や^.演算子でもアクセスできますが、その場合はMaybeじゃないナマの値が直接返ります
xs ^. ix 1      -- "one" 

-- ^.演算子で範囲外にアクセスするとmemptyが返ります 
xs ^. ix 100      -- "" 

-- ^.演算子は要素がMonoidの配列でないと使えません
ys ^. ix 100      -- コンパイルエラー

-- 通常のupdateAtによる書き込み
-- updateAtはMaybeで結果を返してくるので、ここではfromMaybeで失敗を握りつぶしています
fromMaybe xs $ updateAt 1 "foo" xs      -- ["zero", "foo", "two"]

-- ixでの指定インデックスへの書き込み
xs # ix 1 .~ "foo"                      -- ["zero", "foo", "two"]      

-- 範囲外なら何もなかったことになる
xs # ix 100 .~ "foo"                      -- ["zero", "one", "two"]</code></pre><h1><a name="strmap-" class="anchor" href="#strmap-"><span class="header-link"></span></a>StrMapの読み書き</h1><pre><code class="hs">-- サンプルデータ
-- fromFoldableでタプルの配列から文字列のマップを作れます。
-- 内部的には { one: 1, two: 2, three: 3 } というようなJavaScriptのオブジェクトと同じものです
nmap :: StrMap Int
nmap = fromFoldable [
    Tuple "one" 1, 
    Tuple "two" 2,
    Tuple "three" 3
]</code></pre><pre><code class="hs">-- 通常のlookupによる読み取り
lookup "one" nmap      -- Just 1

-- StrMapの場合でも、ixでインデックスに文字列を使うだけ
nmap ^? ix "one"       -- Just 1

-- 通常のinsertによる書き込み
insert "two" 222 nmap   -- { one:1, two:222, three:3 }

-- ixを使った書き込み
-- JavaScriptの nmap["two"] = 222; という式と字面がよく対応していて直感的です
nmap # ix "two" .~ 222  -- { one:1, two:222, three:3 }

-- ixのほかにatというものもあります。
-- ixはキーが存在しなかったときには何も起きませんが、atはその値を挿入するという違いがあります。
-- そのためatが使えるコンテナにも違いがあり、配列やリストではatは使えません
-- .~の代わりに?~を使うことにも注意
nmap # at "ten" ?~ 10      -- { one:1, two:2, three:3, ten: 10 }</code></pre><h1><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>配列の配列の読み書き</h1><pre><code class="hs">-- サンプルデータ
zs :: Array (Array String)
zs = [["zero"], ["one"], ["two"]]</code></pre><pre><code class="hs">-- ベタな方法での読み取り 
-- 一回目の配列アクセスは単に!!演算子の適用なのに、
-- 2回目のアクセスは<#>を噛ませることになる一貫性のなさがちょっと直感的でないと思います
zs !! 1 <#> (!! 0)        -- Just "one"

-- 人によってはFunctorよりdo記法のほうが好きかもしれません
do xs <- zs !! 1
   xs !! 0                -- Just "one"

-- >=>演算子でつなげると、<#>よりはいくらか対称性があります
zs # ((!! 1) >=> (!! 0))  -- Just "one"

-- lensは<<<で合成できます。配列の配列の内部を読むにはixの2個のLensを合成すればいい 
-- ただしうまく型推論ができず、型注釈を加えないとコンパイルできません
-- PureScriptのコンパイラの問題なのかどうかまだよくわかりません
zs ^? (ix 1 <<< ix 0)     -- Just "one"

-- 書き込みのほうはあんまりいい方法が思いつきません
-- ホント汚い
do xs <- zs !! 1
   ys <- updateAt 0 "foo" xs
   updateAt 1 ys zs　　　　　      -- [["zero"], ["foo"], ["two"]]

-- lensだと割りと素直に書けます
-- JavaScriptで zs[1][0] = "foo"; とするのと同じ思考で書けます
zs # (ix 1 <<< ix 0) .~ "foo"     -- [["zero"], ["foo"], ["two"]]</code></pre><h1><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>配列を含むより複雑なオブジェクトの読み書き</h1><pre><code class="hs">-- 型
type Task = { name :: String, completed :: Boolean }

type TodoList = { title :: String, tasks :: Array Task }</code></pre><pre><code class="hs">-- サンプルデータ
todoList :: TodoList
todoList = {
    title: "Today's todo",
    tasks: [
        { name: "meeting at 15:00", completed: false },
        { name: "purchase a milk", completed: true },
        { name: "dog walk", completed: false }
    ]
}</code></pre><pre><code class="hs">-- 通常のプロパティアクセス。
-- 基本的にはa.b.c.dとドットで繋げばいいですが、Maybeが絡むと<#>が必要になって読みにくくなります
todoList.tasks !! 1 <#> _.name           -- Just "purchase a milk"         

-- Lensなら<<<演算子でtasksやnameのような自分で定義したLensとixを自在に合成できます
-- ただしこれも現状型注釈を加えないと通りません
todoList ^? (tasks <<< ix 1 <<< name)    -- Just "purchase a milk"      


-- こういう複雑なオブジェクトの内部を書き換えようとすると、素朴な方法では一気に可読性が悪化します
todoList { tasks = fromMaybe todoList.tasks $ modifyAt 1 (_ { name = "purchase two bottles of milk" }) todoList.tasks  }  
-- {
--    title: "Today's todo",
--    tasks: [
--        { name: "meeting at 15:00", completed: false },
--        { name: "purchase two bottles of milk", completed: true },
--        { name: "dog walk", completed: false }
--    ]
-- }

-- Lensなら短いくてJSのコードにもよく似ている語順で直感的
-- JavaScriptだと todoList.tasks[1].name = "purchase two bottles of milk"; と書くのと同じイメージ
todoList # (tasks <<< ix 1 <<< name) .~ "purchase two bottles of milk"      
-- {
--    title: "Today's todo",
--    tasks: [
--        { name: "meeting at 15:00", completed: false },
--        { name: "purchase two bottles of milk", completed: true },
--        { name: "dog walk", completed: false }
--    ]
-- }

-- 値の置き換えではなく、値に対して例えば配列の要素を追加したいなどの操作をするときは、
-- overもしくは別名の%~を使います。
-- JavaScriptでいう todoList.tasks.push({ name: "have a lunch with her", completed: false }) のような操作は次のようになります
todoList # tasks %~ (++ [{ name: "have a lunch with her", completed: false }])
-- {
--    title: "Today's todo",
--    tasks: [
--        { name: "meeting at 15:00", completed: false },
--        { name: "purchase two bottles of milk", completed: true },
--        { name: "dog walk", completed: false },
--        { name: "have a lunch with her", completed: false }
--    ]
-- }</code></pre><h1><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>直和型を含むデータ構造の読み書き</h1><pre><code class="hs">-- データ型
type Element = { name :: String, attributes :: StrMap String, children :: Array XML }

data XML = Text String | Element Element</code></pre><pre><code class="hs">-- LensとPrism
-- XMLのように複数のデータコンストラクタが含まれる直和型的なデータ型は、
-- prismでアクセサを表現していきます
element :: Prism XML XML Element Element
element = prism Element \s -> case s of 
    Text str -> Left (Text str)
    Element e -> Right e

text :: Prism XML XML String String
text = prism Text \v -> case v of 
    Element elem -> Left (Element elem)
    Text str -> Right str

children :: forall a b . Lens { children :: a | b } { children :: a | b } a a
children = lens _.children _ { children = _ }</code></pre><pre><code class="hs">-- データ
xml :: XML
xml = Element { name: "div", attributes: empty, children: [
    Element { name: "hr", attributes: empty, children: [] },
    Text "Hello" 
] }</code></pre><pre><code class="hs">-- <<<で合成していけば中のほうに触れるのも簡単
-- JavaScriptの　xml.children[1] は安全でないですが、Lensの方は型安全です
xml ^? (element <<< children <<< ix 1 <<< text)     -- Just "Hello"

-- 書き込みも簡単
-- JavaScriptで xml.children[1] = "See you"; と書くのと同じ思考で書けます
xml # (element <<< children <<< ix 1 <<< text)　.~ "See you"
-- Element { name: "div", attributes: empty, children: [
--    Element { name: "hr", attributes: empty, children: [] },
--    Text "See you"
-- ] }</code></pre><h1><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>さいごに</h1><p>自分はTemplate Haskellみたいな黒魔術は好きじゃないし、PureScriptにはJavaScriptに似たオブジェクト型があって構文が多少マシなのでLensなしでもいいかと思っていましたが、このあいだLensには単なるプロパティアクセス以外の面白い使い方があることを知って少し興味がわいたので、自分も練習してみることにしました。</p>
<p>Lensはあまりに抽象的すぎるので、APIドキュメントや定義そのものとにらめっこしても使い方は理解できないと思います。そういうライブラリは、とにかく具体的な使用例をたくさん覚えていくのがいいのではないでしょうか。もちろん定義が理解に役に立たないというわけではなく、Lensのさまざまな関数の使い方がわかったあとで定義を見返してみると理解が深まります。それに、使い道のない抽象化は、数学ならともかくプログラミングでは意味がありません。コードをどのように改善するのかという具体的な比較があってこそ、このライブラリは役に立つといえるわけです。</p>
<p>ただこのライブラリ、抽象的な型クラスが多すぎ、型の別名が多すぎ、型変数が多すぎ、抽象的すぎてドキュメント見ても関数の使い方がわからなすぎと、とにかく難易度が凄まじいライブラリです。自分が今まで触ったライブラリの中でも軽々トップ３には入るであろう難易度だと思います。うかつに手を出すと手首ごと食いちぎられます。その難易度のわりにコードの改善は局所的ですし、別にLensを使わなくてもちょっとコードが冗長で少し可読性が落ちるだけの話ですし、別にコードの型安全性などには変化はないし、アプリケーション全体の設計に影響するようなライブラリでもありません。Lensより優先して学ぶべきライブラリは他にたくさんあると思います。</p>
<p>PureScriptだと手作業でLensやPrismを定義する面倒さはもとより、型推論でちょっとハマる場面があったのもつらみを感じました。上で比較したとおり明らかに構文は改善されるので使ってみる価値はあると思いますが、他にお勧めしたいライブラリはいくらでもあるので、Lensに取り組むのは目ぼしいライブラリにひと通り触れてからでいいと思います。上で試した以外にも大量の関数や型が用意されているので、また理解が進み次第追記していこうかと思います。</p>
<h1><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>参考文献</h1><ul>
<li><a href="/blog/https://github.com/ekmett/lens/wiki/Overview.html">https://github.com/ekmett/lens/wiki/Overview</a></li>
<li><a href="/blog/http://tokiwoousaka.github.io/takahashi/contents/20150530LensPrism.html.html">http://tokiwoousaka.github.io/takahashi/contents/20150530LensPrism.html</a></li>
<li><a href="/blog/http://stackoverflow.com/questions/29742634/could-someone-explain-the-diagram-about-the-lens-library.html">http://stackoverflow.com/questions/29742634/could-someone-explain-the-diagram-about-the-lens-library</a></li>
<li><a href="/blog/http://stackoverflow.com/questions/18414177/what-is-the-difference-between-ix-and-at-in-the-lens-library-of-haskell.html">http://stackoverflow.com/questions/18414177/what-is-the-difference-between-ix-and-at-in-the-lens-library-of-haskell</a></li>
<li><a href="/blog/http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html.html">http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html</a></li>
</ul>



            
<hr style="margin-top: 200px;">

<div class="snsbuttons">

    <!-- Twitter -->
    <a href="https://twitter.com/share" class="twitter-share-button" data-related="cubbit2">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

    <!-- Hatena -->
    <div>
        <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="basic-label-counter" data-hatena-bookmark-lang="ja" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
    </div>

    <!-- line -->
    <div>
        <div class="line-it-button" style="display: none;" data-type="share-a" data-lang="ja" ></div>
        <script src="//scdn.line-apps.com/n/line_it/thirdparty/loader.min.js" async="async" defer="defer" ></script>
    </div>

    <!--facebook -->
    <div>
        <div id="fb-root"></div>
        <script>(function(d, s, id) {
        var js, fjs = d.getElementsByTagName(s)[0];
        if (d.getElementById(id)) return;
        js = d.createElement(s); js.id = id;
        js.src = "//connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v2.8";
        fjs.parentNode.insertBefore(js, fjs);
        }(document, 'script', 'facebook-jssdk'));</script>
        <div class="fb-like" data-href="https://aratama.github.io/blog/${metadata.id}.md" data-layout="button_count" data-action="like" data-size="small" data-show-faces="true" data-share="false"></div>
    </div>

    <!-- google+ -->
    <div>
        <script src="https://apis.google.com/js/platform.js" async defer>
        {lang: 'ja'}
        </script>
        <div class="g-plusone" data-size="medium"></div>
    </div>

</div>

        </article>
    </div>

<footer>
    <div class="block-centered footer-inner">
        <p class="copy">&nbsp;</p>
        <p class="author">このブログを書いてる人:&nbsp;&nbsp; 兎沢<p>
    </div>

    <script>
        const poem = [
            "なんにもない毎日が、なによりの宝物。",
            "今日という日を、何度でも繰り返したい。",
            "世界を追いかけなくても、世界は私のまわりにある。", 
            "速すぎる雑踏。鼻先をくすぐる春風。", 
            "明日撮る写真を飾る場所を、アルバムに空けておこう。", 
            "落ち葉が地面に、触れる音がした。", 
            "明日は、明日の楽しさが待っている。", 
            "風が泣いている。この想いを紡ぐ言葉を持たないから。", 
            "もうここには何もない。つまり、はじまりの時が来た。", 
            "もう此処にはこないだろう。そう言って私は過去に背を向けた。", 
            "散りゆくからこそ、美しい。私は桜の花びらをかかとで踏みしめた。", 
            "思い出はいつだって輝いてる。"
        ];
    document.querySelector(".copy").textContent = poem[Math.floor(poem.length * Math.random())];
    </script>
</footer>

