<!DOCTYPE html>
<meta charset="UTF-8">

<!-- Twitter card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@cubbit2">
<meta name="twitter:creator" content="@cubbit2">
<meta name="twitter:title" content="『先にヘッダを送信してから、そのあとでレスポンスボディを送信しなくてはならない』ことをコンパイル時に検証する - ちょっと小さいのはたしかですが。">
<meta name="twitter:description" content="Admittedly something small.">
<meta name="twitter:image" content="https://aratama.github.io/img/3c3b376d-5c80-47c6-58b9-23d264453a65.png">

<link rel="icon" type="image/png" href="icon.png">
<link rel="stylesheet" href="/res/reset.css">
<link rel="stylesheet" href="/res/style.css">

<title>『先にヘッダを送信してから、そのあとでレスポンスボディを送信しなくてはならない』ことをコンパイル時に検証する - ちょっと小さいのはたしかですが。</title>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-61162129-3', 'auto');
  ga('send', 'pageview');

</script>

<header>
    <div class="block-centered">
        <div class="site-title"><a href="/">ちょっと小さいのはたしかですが。</a></div>
        <div class="sub-title">Admittedly something small.</div>
    </div>
</header>



<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

<!--
<link rel="stylesheet" href="/lib/highlight/styles/default.css">
<script src="/lib/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
-->

<!--
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$']]}
});
</script>
-->


<link rel="stylesheet" href="/res/article.css">


    <div class="content">

        <article id="rendered">
            <div class="date">2017年4月22日</div>
            <h1 class="article-title">
                <!-- <i class="fa fa-coffee" aria-hidden="true"></i> -->
                <a href="9e37a6bb6b6b3c9a59e4.html">『先にヘッダを送信してから、そのあとでレスポンスボディを送信しなくてはならない』ことをコンパイル時に検証する<a>
            </h1>        
            <p class="tags"><a href="JavaScript.html"><span class="tag"><i class="fa fa-tag" aria-hidden="true"></i>JavaScript</span></a>
<a href="Node.html"><span class="tag"><i class="fa fa-tag" aria-hidden="true"></i>Node</span></a>
<a href="Node.js.html"><span class="tag"><i class="fa fa-tag" aria-hidden="true"></i>Node.js</span></a>
<a href="purescript.html"><span class="tag"><i class="fa fa-tag" aria-hidden="true"></i>purescript</span></a>
<a href="hyper.html"><span class="tag"><i class="fa fa-tag" aria-hidden="true"></i>hyper</span></a></p>
            <hr>
            <p><a href="/img/3c3b376d-5c80-47c6-58b9-23d264453a65.png"><img src="/img/3c3b376d-5c80-47c6-58b9-23d264453a65.png"></img></a></p><h1><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>動機</h1><p>Nodeで簡単なサーバサイドアプリケーションを作ることを考えてみます。</p><pre><code class="js">const http = require(&#x27;http&#x27;);

const hostname = &#x27;127.0.0.1&#x27;;
const port = 3000;

const server = http.createServer((req, res) =&gt; {
  res.statusCode = 200;
  res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/plain&#x27;);
  res.write(&#x27;Hello World\n&#x27;);
  res.end();
});

server.listen(port, hostname, () =&gt; {
  console.log(&#x60;Server running at http://${hostname}:${port}/&#x60;);
});</code></pre><p>このコードが何をやっているかは明白ですし、Nodeを知らない人でもなんとなく見当がつくでしょう。さて、HTTPのレスポンスというのは、最初にステータス行、それからヘッダが続いて、最後にレスポンスボディの順で送信するプロトコルで、例えば次のような内容になっています。</p><pre><code class="undefined">HTTP/1.0 200 OK
Content-Type: text/plain

Hello World</code></pre><p>そういうプロトコルなので、レスポンスボディを送信したあとにヘッダを送信することはできません。たとえば、コードを次のように変更してみます。</p><pre><code class="js">  res.write(&#x27;Hello World\n&#x27;);
  res.statusCode = 200;
  res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/plain&#x27;);
  res.end();</code></pre><p>変更後のコードでは、<code>write</code>でレスポンスボディを書いたあとに、<code>setHeader</code>でヘッダを書き込んでいます。これを実行すると、実行時例外でサーバはお亡くなりになります。</p><pre><code class="undefined">http_outgoing.js:371
    throw new Error(&#x27;Can\&#x27;t set headers after they are sent.&#x27;);
    ^

Error: Can&#x27;t set headers after they are sent.
    at ServerResponse.setHeader (_http_outgoing.js:371:11)
    at Server.http.createServer (C:\dev\nodehttptest\test.js:9:7)
    at emitTwo (events.js:106:13)
    at Server.emit (events.js:194:7)
    at parserOnIncoming (_http_server.js:563:12)
    at HTTPParser.parserOnHeadersComplete (_http_common.js:99:23)</code></pre><p>なので、<code>setHeader</code>は<code>write</code>よりも手前に書くように気をつけましょう。</p><p><br></p><p><br></p><p><br></p><p><strong>……何が「気をつけましょう」だよ！アホか！「気をつけましょう」なんていう心がけで本当にミスを防げたら誰も苦労しねーよ！</strong>『自動車のアクセルとブレーキを踏み間違えないようにしましょう』とか呼びかければ不幸な事故が減るとでも思ってるのか！？それに、ミスは不注意な人とか知識に乏しい人だけがするものではありません。疲労や寝不足で頭がおかしくなって訳のわからないコードを書くことは誰にでもあります。頻繁な変更が入り複雑怪奇に成り果てたコードからは、単純なミスでもそう簡単に見つけられるものではありません。ミスに対する有効な対策とは、「気をつけましょう」とかそういう心がけじゃなくて、機械がミスを発見して自動的に報告する機構を用意することでしょう。</p><p>そこで、<a href="https://hyper.wickstrom.tech/"><strong>Hyper</strong></a>というウェブサーバサイドフレームワークの手法を簡単に紹介します。<code>Hyper</code>は、『ヘッダを書き終えてからレスポンスボディを書く』という条件が満たされているかを、<strong>コンパイル時に</strong>検証してくれます。</p><h1><a name="hyper-" class="anchor" href="#hyper-"><span class="header-link"></span></a>Hyperによる解決</h1><p>HyperによるHelloWorldは、例えば次のようになります。PureScriptのコードですし、コードの詳細は気にしなくていいです。フィーリングで読んでください<a class="link-footnote" href="#footnote-anno" name="link-anno">※</a>。</p><pre><code class="haskell">main = runServer defaultOptionsWithLogging {} do 
    writeStatus statusOK
    contentType textPlain
    closeHeaders
    toResponse &quot;Hello, Hyper!&quot; :&gt;&gt;= send
    end</code></pre><p><code>writeStatus statusOK</code>はNodeの<code>res.statusCode = 200</code>に相当する操作ですし、<code>contentType textPlain</code>は<code>res.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;)</code>に対応してます。それで、このコードはもちろん正常にコンパイルすることができますが、このコードを次のように書き換えてみます。</p><pre><code class="haskell">main = runServer defaultOptionsWithLogging {} do 
    toResponse &quot;Hello, Hyper!&quot; :&gt;&gt;= send
    writeStatus statusOK
    contentType textPlain
    closeHeaders
    end</code></pre><p>つまり、<code>send</code>でレスポンスボディを送ってから、<code>writeStatus</code>でステータスを書き込んでしまうというミスをしているわけです。これは明らかに間違いですが、これをコンパイルしようとすると、コンパイラは次のようなエラーメッセージを吐きます。この種のミスをコンパイラが発見して、事故を未然に防いでくれているのです。</p><pre><code class="undefined">Error found:
in module Main
at src\Main.purs line 15, column 13 - line 19, column 16

  Could not match type

    StatusLineOpen

  with type

    BodyOpen


while trying to match type t6 StatusLineOpen
  with type t2 BodyOpen
while checking that expression writeStatus statusOK
  has type Middleware t0
             { request :: t1
             , response :: t2 BodyOpen
             , components :: t3
             }
             t4
             t5
in value declaration main</code></pre><p>エラーメッセージの言っていることは一見意味不明ですが、よくよく見てみるとこれは<strong>ただの型エラー</strong>だったりします。コンパイラが何か特別な静的解析を働かせているとか、そういうことではありません。<code>Could not match type StatusLineOpen with type BodyOpen</code>とあるように、コンパイラが言っているのは、関数に与えた引数の型<code>StatusLineOpen</code>が、関数が求めている型<code>BodyOpen</code>に合わない、というだけの話です。原理的にはそれだけなのですが、この型エラーの詳細について理解するには<strong>Indexed Monad</strong>という仕組みを学ばなくてはならず、話が長くなるので止めときます。またモナドかよ！</p><p>今回書いたコードはgistに載せておきました。</p><ul>
<li><a href="https://gist.github.com/aratama/1b3b9a2c1672f4ecfdf4183820cef28e">https://gist.github.com/aratama/1b3b9a2c1672f4ecfdf4183820cef28e</a></li>
</ul>
<h1><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>さいごに</h1><p>「こんな瑣末な落とし穴、書くときに気をつければ簡単に回避できるだろ」と思ったひともいるでしょう。このヘッダの順序の問題と、Indexed Monadなどという抽象的な機能を学ぶコストを天秤にかけて、「学習コストに見合わない」というふうに考える人もいるような気がします。</p><p>たしかにこの落とし穴だけについて考えれば、そうだと思います。でも問題は、<strong>現実のコードにはこういう些細な落とし穴が山ほど隠れている</strong>ということです。PureScriptのような言語を使っている人たちは、個々の落とし穴が瑣末であるからといって、その落とし穴を軽視して放置したりはしません。なぜなら、そうやって見逃されてきた単純な落とし穴も、いずれ寄り集まって複雑さを増し、やがて厄介なトラブルを山ほど生み出すとわかっているからです。些細な落とし穴だからこそ、PureScriptのような言語はそれを見逃さずに根本的な対処を与えて、そういう下らない問題で開発者の頭のなかがいっぱいにならないようにしてくれます。コンパイラがそういう下らないミスを開発者の代わりに検出してくれるからこそ、開発者は本来の問題に集中できるのです。</p><p><strong>プログラミング上のありとあらゆる落とし穴を可能な限りコンパイル時に検出する</strong>のが、PureScriptのような言語やHyperのようなフレームワークが目指すところです。PureScriptやHyperのような道具は詳細を追い始めるとやはり複雑なところはあるのですが、それは今まで個々の開発者が神経をすり減らして『気をつけて』いたことを、Hyperのようなフレームワークが代わりに『気をつけて』くれるようになった結果です。決して闇雲に複雑にしているわけではありません。ほかにも、「どうせ実行時エラーが出るのだから、コンパイルエラーにする必要はないのでは」と思う人もいるでしょうが……そういうことを説明し出すと、また話が長(略</p><p>今回は敢えて技術的詳細の説明を控えました。どうしても詳細を知りたければ、Hyperや<a href="https://github.com/garyb/purescript-indexed-monad">purescript-indexed-monad</a>のコードを眺めてみるといいかもしれません。ただし、今回紹介したHyperの手法を他の『普通の』プログラミング言語で実現することはまず不可能です。関数型プログラミングのテクニックを覚えて一般的なプログラミング言語で役立てるというのは、関数型プログラミングの初歩の初歩を齧っただけの人（しかも初歩しか齧っていないのに自分は関数型プログラミング全体を把握したと思い込んでいる人）が抱きがちな幻想です。HaskellやPureScript、Scalaのような本格的な関数型プログラミング言語へ移行して安全な世界で気楽に暮らすか、JavaやJavaScriptのような『普通の』プログラミング言語のまま落とし穴と隣り合わせに生きるか、どちらかしかありません。</p><p>Hyperはまだあまりに若いフレームワークですが、その方向性はPureScriptが目指しているところとぴったり一致していますし、今も活発に開発が続いていて有望なフレームワークだと思います。PureScriptの本格的なウェブサーバサイドフレームワークは、まだ片手で数えるほどしかありません。もっとPureScriptのユーザが増えて、こういう安全なフレームワークがたくさん育ってほしいと、筆者は願うところであります。</p><h1><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>参考文献</h1><ul>
<li><a href="https://hyper.wickstrom.tech/">hyper.wickstrom.tech</a> Hyperの公式サイト。ロゴが可愛い</li>
</ul>
<hr>
<p class="footnote"><a href="#link-anno" name="footnote-anno">^</a>  本当はもっと短く書くこともできますが、先ほどのJavaScriptでの例と対応させる感じにあえて冗長に書いています。また、インポートリストとか型注釈が長すぎるので、本質的なコードだけを抜粋してます。</p>
            
<hr style="margin-top: 60px;">

<div class="snsbuttons">

    <!-- Twitter -->
    <a href="https://twitter.com/share" class="twitter-share-button" data-related="cubbit2">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

    <!-- Hatena -->
    <div>
        <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="basic-label-counter" data-hatena-bookmark-lang="ja" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
    </div>

    <!-- line -->
    <div>
        <div class="line-it-button" style="display: none;" data-type="share-a" data-lang="ja" ></div>
        <script src="//scdn.line-apps.com/n/line_it/thirdparty/loader.min.js" async="async" defer="defer" ></script>
    </div>

    <!--facebook -->
    <div>
        <div id="fb-root"></div>
        <script>(function(d, s, id) {
        var js, fjs = d.getElementsByTagName(s)[0];
        if (d.getElementById(id)) return;
        js = d.createElement(s); js.id = id;
        js.src = "//connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v2.8";
        fjs.parentNode.insertBefore(js, fjs);
        }(document, 'script', 'facebook-jssdk'));</script>
        <div class="fb-like" data-href="https://aratama.github.io/blog/${metadata.id}.md" data-layout="button_count" data-action="like" data-size="small" data-show-faces="true" data-share="false"></div>
    </div>

    <!-- google+ -->
    <div>
        <script src="https://apis.google.com/js/platform.js" async defer>
        {lang: 'ja'}
        </script>
        <div class="g-plusone" data-size="medium"></div>
    </div>

</div>
        </article>
    </div>

<footer>
    <div class="block-centered footer-inner">
        <p class="copy">&nbsp;</p>
        <p class="author">このブログを書いてる人:&nbsp;&nbsp; 竹内稲穂<p>
    </div>

    <script>
        const poem = [
            "なんにもない毎日が、なによりの宝物。",
            "今日という日を、何度でも繰り返したい。",
            "世界を追いかけなくても、世界は私のまわりにある。", 
            "速すぎる雑踏。鼻先をくすぐる春風。", 
            "明日撮る写真を飾る場所を、アルバムに空けておこう。", 
            "落ち葉が地面に、触れる音がした。", 
            "明日は、明日の楽しさが待っている。", 
            "風が泣いている。この想いを紡ぐ言葉を持たないから。", 
            "もうここには何もない。だから、次の場所に旅立とう。", 
            "もう此処にはこないだろう。そう言って私は過去に背を向けた。", 
            "散りゆくからこそ、美しい。私は桜の花びらをかかとで踏みしめた。", 
            "思い出はいつだって輝いてる。",
            "正直ばかりじゃつまらない。たまには楽しい嘘をつこう。", 
            "ゆっくり歩けば歩くほど、時間がゆっくり過ぎてゆく。",
            "夜明けを、探しにいこう。", 
            "空はこんなに青かったんだ。", 
            "地球は青かった。それはこの空を見上げたことのある全員が知っている。", 
            "休み時間は、長すぎるということはない。", 
            "缶コーヒーを飲むときだけは、それ以外のすべてを忘れることにしてる。", 
            "ちょっと小さいのは確かですが、それは確かにここにあります。", 
            "ちょっと小さいのは確かですが、広すぎる家というのも寂しいでしょう？", 
            "ひつじが一匹、ひつじが二匹。五十匹までは、数えたことがある。"
        ];
    document.querySelector(".copy").textContent = poem[Math.floor(poem.length * Math.random())];
    </script>
</footer>

