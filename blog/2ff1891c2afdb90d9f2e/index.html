<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@cubbit2"><meta name="twitter:creator" content="@cubbit2"><meta name="twitter:title" content="HaskellerのためのPureScriptことはじめ - ちょっと小さいのはたしかですが。"><meta name="twitter:description"><meta name="twitter:image"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="icon.png"><link rel="stylesheet" href="/res/reset.css"><link rel="stylesheet" href="/res/style.css"><title>HaskellerのためのPureScriptことはじめ - ちょっと小さいのはたしかですが。</title><script>
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-61162129-3', 'auto');
                ga('send', 'pageview');
            </script></head><body><header><div class="sns"><a target="_blank" href="https://twitter.com/intent/tweet?text=undefined%20https%3A%2F%2Faratama.github.io%2Fblog%2F2ff1891c2afdb90d9f2e"><img src="/res/twitter.png"></a><a target="brank" href="http://www.facebook.com/sharer.php?u=https%3A%2F%2Faratama.github.io%2Fblog%2F2ff1891c2afdb90d9f2e&amp;t=undefined"><img src="/res/facebook.png"></a><a target="brank" href="https://plus.google.com/share?url=https%3A%2F%2Faratama.github.io%2Fblog%2F2ff1891c2afdb90d9f2e"><img src="/res/google.png"></a><a target="brank" href="http://b.hatena.ne.jp/entry/https%3A%2F%2Faratama.github.io%2Fblog%2F2ff1891c2afdb90d9f2e"><img src="/res/hatena.png"></a><a target="brank" href="http://getpocket.com/edit?url=https%3A%2F%2Faratama.github.io%2Fblog%2F2ff1891c2afdb90d9f2e&amp;title=undefined"><img src="/res/pocket.png"></a></div><div class="block-centered"><div class="site-title"><a href="/">Admittedly <wbr>something <wbr>small.</a></div><div class="sub-title">ちょっと<wbr>小さいのは<wbr>たしかですが。</div></div></header><div class="content"><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/res/article.css"><article id="rendered"><div class="date">2015年2月6日</div><h1 class="article-title"><a href=".">HaskellerのためのPureScriptことはじめ</a></h1><p class="tags"><a href="/blog/tag/JavaScript"><span class="tag"><i class="fa fa-tag"></i>JavaScript</span></a><a href="/blog/tag/Haskell"><span class="tag"><i class="fa fa-tag"></i>Haskell</span></a><a href="/blog/tag/altjs"><span class="tag"><i class="fa fa-tag"></i>altjs</span></a><a href="/blog/tag/purescript"><span class="tag"><i class="fa fa-tag"></i>purescript</span></a></p><hr><div><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><strong>【注意事項】この記事はとてもとても古いです。現在のPureScriptとは大きく言語仕様が変わっており、この記事の情報はあまり宛てにならないと思います。あまりに現状のPureScriptとかけ離れているので削除も考えましたが、何かの参考になるかもしれないので一応残しておきます。PureScriptについては、もし英語でも構わないのであれば、PureScriptのオリジナルの開発者であるPhilさん本人による<a href="https://leanpub.com/purescript/read">PureScript by Example</a>がもっとも信頼できる情報源です。どうしても日本語の情報を探しているなら、かなり古いですが<a href="f1e048fc9a8ca51eddb2.html">関数型なAltJS、PureScriptの入門書を邦訳しました。</a>も参考にしてください。</strong> </p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><hr>
<h2><a name="-strong-a-href-http-www-purescript-org-purescript-a-strong-" class="anchor" href="#-strong-a-href-http-www-purescript-org-purescript-a-strong-"><span class="header-link"></span></a><strong><a href="http://www.purescript.org/">PureScript</a></strong>とは：</h2><ul>
<li>Haskellライクな構文とライブラリ</li>
<li>Row Polymorphismによる柔軟な型システム</li>
<li>JavaScriptへトランスコンパイルされるAltJS</li>
</ul>
<p>そんなPureScriptについて調べた内容のざっくりとしたメモです。べつにHaskellユーザじゃなくても読めますのでどうぞ。</p><h2><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>言語仕様編</h2><h3><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>正格評価</h3><p>PureScriptは<strong>正格評価</strong>です</p><h3><a name="-kind" class="anchor" href="#-kind"><span class="header-link"></span></a>型とKind</h3><h4><a name="-type-" class="anchor" href="#-type-"><span class="header-link"></span></a>* (Type)</h4><p>Haskellと同じように、<code>*</code>は普通のデータ型を表すkindです。<code>* -&gt; *</code>は型をひとつとって型を返すkindです。例: <code>Number :: *</code>, <code>String :: *</code>, <code>Maybe :: * -&gt; *</code>, <code>Maybe Number :: *</code>, <code>(-&gt;) :: * -&gt; * -&gt; *</code>, <code>Number -&gt; Number :: *</code>, <code>[] :: * -&gt; *</code>, <code>[] Number :: *</code>, <code>[Number] :: *</code> </p><h4><a name="-effect-" class="anchor" href="#-effect-"><span class="header-link"></span></a>! (Effect)</h4><p>PureScriptのkindには<code>*</code>とは別に<code>!</code>というものもあります。この<code>!</code>は入出力や副作用を表すEffectの型のkindです。例: <code>Data.Trace.Trace :: !</code>, <code>Control.Monad.Eff.Random.Random :: !</code></p><p><code>foreign import</code>を使えば自分で新たなEffectを定義することもできます。</p><pre><code class="undefined">foreign%20import%20data%20Counter%20%3A%3A%20%21</code></pre><p>自分で定義したこの<code>!</code>は、FFIで<code>Eff</code>と一緒に使います。</p><h4><a name="-row-" class="anchor" href="#-row-"><span class="header-link"></span></a># (Row)</h4><p>Rowは名前と型の組み合わせを複数個順序なしでまとめたものです。副作用を表す型Effでどんな副作用が含まれているかを表したり、オブジェクト型を作り出したりするのに使います。<code># *</code>はフィールドに<code>*</code>だけをもつRowで、<code># !</code>はフィールドに<code>!</code>だけを持つRowのことです。Rowを作るには<code>()</code>を使います。</p><h6><a name="-code-code-" class="anchor" href="#-code-code-"><span class="header-link"></span></a><code>()</code></h6><p>例: <code>() :: # *</code>　または <code>() :: # !</code>, <code>( number :: Number ) :: # *</code>, <code>( number :: Number, string :: String ) :: # *</code>, <code>( trace :: Trace ) :: # !</code>, <code>( number :: Number, trace :: Trace )</code> は * と ! を混ぜているのでエラー</p><h6><a name="-code-object-code-" class="anchor" href="#-code-object-code-"><span class="header-link"></span></a><code>Object</code></h6><p><code>Object</code>は <code># *</code>から<code>*</code>を作ってくれます。JavaScriptのオブジェクトのような型は<code>()</code>でRowを作ってから<code>Object</code>に渡すと作ることができます。</p><p>例: <code>Object :: # * -&gt; *</code>, <code>Object () :: *</code>, <code>Object ( number :: Number ) :: *</code>, <code>Object ( trace :: Trace )</code> はObjectは # ! は受け取れないのでエラー</p><p><code>Object ( number :: Number )</code>は<code>number</code>という名前で<code>Number</code>という型のプロパティを持ったオブジェクトの型に相当します。</p><pre><code class="undefined">earth%20%3A%3A%20Object%20%28%20answer%20%3A%3A%20Number%20%29%0Aearth%20%3D%20%7B%20answer%20%3A%2042%20%7D</code></pre><h6><a name="-code-code-" class="anchor" href="#-code-code-"><span class="header-link"></span></a><code>{}</code></h6><p><code>{}</code>は<code>Object ()</code>のシンタックスシュガーです。JavaScriptのオブジェクトの型を作るときにちょっと便利です。</p><p>例: <code>{} :: *</code>,  <code>{ number :: Number } :: *</code>, <code>{ trace :: Trace }</code> は <code>Object ( trace :: Trace )</code> と同じ理由でエラー</p><pre><code class="undefined">earth%20%3A%3A%20%7B%20answer%20%3A%3A%20Number%20%7D%0Aearth%20%3D%20%7B%20answer%20%3A%2042%20%7D</code></pre><h6><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>そのほか</h6><p>例: <code>Eff :: # ! -&gt; * -&gt; *</code>, <code>Eff () :: * -&gt; *</code>, <code>Eff ( trace :: Trace ) :: * -&gt; *</code>, <code>Eff ( trace :: Trace ) Number :: *</code>, <code>Eff ( number :: Number )</code> は <code>Eff</code> は <code># *</code> を受け取れないのでエラー, <code>Eff ( trace :: Trace ) Trace</code> も <code>*</code> に <code>!</code> を渡そうとしているのでエラー</p><h3><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>オブジェクト(レコード)</h3><p><code>{ answer : 42 }</code>というようなRecord LiteralでJavaScriptのようなオブジェクトリテラルを書けます。レコードでパターンマッチングもできます。</p><pre><code class="undefined">f%20%7B%20foo%20%3D%20%22Foo%22%2C%20bar%20%3D%20n%20%7D%20%3D%20n%0Af%20_%20%3D%200</code></pre><p>(チュートリアルを読んでると、<code>{ answer :: Number }</code>みたいなのをHaskellと同様にRecordと呼んでいたり、<code>{ answer : 42 }</code>はRecord Literalと呼んだり、パターンマッチングするときは<code>Record Pattern</code>なのですが、Rowから型を作るときの型コンストラクタは<code>Object</code>だし、RecordとObjectという呼び方が混在している気もします。このあたりまだよくわかりません)</p><h6><a name="data-" class="anchor" href="#data-"><span class="header-link"></span></a>dataの直積型とオブジェクトの使い分け：</h6><ul>
<li>Haskellと同様に、のちほどフィールドを追加しそうなデータ型はオブジェクトにします。<code>type</code> で別名も定義しておくと良さそうです</li>
<li>インスタンスが必要な場合や、データ型が循環する場合では、<code>newtype</code>でさらにオブジェクトを包むデータ型を別に定義します</li>
<li>直和が必要な場合は<code>newtype</code>ではなく <code>data</code>でオブジェクトを包むことになります</li>
<li>２次元ベクトル型や単方向リストのように、フィールドの内容が明らかで今後増減しそうになくフィールドの個数が少ないデータ型は、直接<code>data</code>でデータ型を定義しても構いません。ただし、パターンマッチングは関数定義か<code>case</code>式のみで使用可能で、(関数ではない)値の定義や<code>let</code>式ではパターンマッチングが使えないらしく、直積型を<code>data</code>で定義すると不便なことがあります。dataによる直積型とオブジェクト型(レコード型)は異なるので、Haskellのように一旦dataで直積型を定義しておいてあとからフィールドラベルを付け加えるというようなことは簡単にはできません。筆者もいろいろ調査中ですが、この点についてはもしかしたら今後改善されるのかもしれません。</li>
</ul>
<pre><code class="hs">module%20Main%28main%29%20where%0A%0Aimport%20Debug.Trace%0A%0A--%20data%u3067%u76F4%u7A4D%u578B%u3092%u5B9A%u7FA9%u3002%0Adata%20Vector2%20%3D%20Vector2%20Number%20Number%0A%0Ap%20%3A%3A%20Vector2%0Ap%20%3D%20Vector2%2010%2020%0A%0A--%20%u95A2%u6570%u5B9A%u7FA9%u3067%u306E%u30D1%u30BF%u30FC%u30F3%u30DE%u30C3%u30C1%u30F3%u30B0%u306F%u53EF%u80FD%0AaddVector%20%3A%3A%20Vector2%20-%3E%20Vector2%20-%3E%20Vector2%0AaddVector%20%28Vector2%20x1%20y1%29%20%28Vector2%20x2%20y2%29%20%3D%20Vector2%20%28x1%20+%20x2%29%20%28y1%20+%20y2%29%0A%0A--%20case%u5F0F%u3067%u3082%u30D1%u30BF%u30FC%u30F3%u30DE%u30C3%u30C1%u30F3%u30B0%u306F%u53EF%u80FD%0Apx%20%3A%3A%20Number%0Apx%20%3D%20case%20p%20of%0A%20%20%20%20Vector2%20x%20y%20-%3E%20x%0A%0A--%20do%u8A18%u6CD5%u306E%20%3C-%20%u3067%u3082%u30D1%u30BF%u30FC%u30F3%u30DE%u30C3%u30C1%u30F3%u30B0%u304C%u53EF%u80FD%0Amain%20%3D%20do%20Vector2%20x%20y%20%3C-%20return%20%24%20Vector2%2010%2020%0A%20%20%20%20%20%20%20%20%20%20trace%20%24%20show%20x%0A%0A%0A%0A--%20%u30D1%u30FC%u30B9%u30A8%u30E9%u30FC%28Haskell%u3067%u306F%u53EF%u80FD%29%0AVector2%20x%20y%20%3D%20Vector2%2010%2020%0A%0A--%20%u30D1%u30FC%u30B9%u30A8%u30E9%u30FC%28Haskell%u3067%u306F%u53EF%u80FD%29%0Apy%20%3D%20let%20Vector2%20x%20y%20%3D%20p%20in%20y%0A%0A--%20%u30D1%u30FC%u30B9%u30A8%u30E9%u30FC%28Haskell%u3067%u306F%u53EF%u80FD%29%0Amain%20%3D%20do%20let%20Vector2%20x%20y%20%3D%20Vector2%2010%2020%0A%20%20%20%20%20%20%20%20%20%20trace%20%24%20show%20x%0A%0A--%20%u3053%u3046%u3044%u3046Workaround%u306F%u53EF%u80FD%u3060%u3051%u3069%u3001%u3055%u3059%u304C%u306B%u3061%u3087%u3063%u3068%u3088%u307F%u3065%u3089%u3044%0Apy%20%3D%20%28%5C%28Vector2%20x%20y%29%20-%3E%20y%29%20p%0A%0A--%20data%u3092%u76F4%u63A5%u4F7F%u3046%u5834%u5408%u306F%u3001%u30D5%u30A3%u30FC%u30EB%u30C9%u3092%u53D6%u308A%u51FA%u3059%u95A2%u6570%u3092%u81EA%u529B%u3067%u5B9A%u7FA9%u3059%u308B%u306E%u304C%u6B63%u653B%u6CD5%u304B%0Axop%20%28Vector2%20x%20_%29%20%3D%20x%0Apy%20%3D%20xop%20p</code></pre><h3><a name="row-polymorphism" class="anchor" href="#row-polymorphism"><span class="header-link"></span></a>Row Polymorphism</h3><p><code>( name::String, age::Number )</code>というRowは<code>name::String</code>と<code>age::Number</code>という２つのフィールド<strong>のみ</strong>を持った『閉じた』Rowです。それに対し、型変数<code>t</code>を加えた<code>( name::String, age::Number | t)</code>は<strong>少なくとも</strong><code>name::String</code>と<code>age::Number</code>という２つのフィールドを持つ『開いた』Rowです。</p><p><code>Object ()</code>のシンタックスシュガーである<code>{}</code>も同様で、<code>{ name::String, age::Number }</code>は閉じたオブジェクト、<code>{ name::String, age::Number | t}</code>は開いたオブジェクトの型になります。</p><p>閉じたRowには過不足なく同じ名前で同じ型のフィールドが揃っていなければその型の値として扱えません。</p><pre><code class="undefined">type%20Entry%20%3D%20%7B%20firstName%20%3A%3A%20String%2C%20lastName%20%3A%3A%20String%2C%20phone%20%3A%3A%20String%20%7D%0A%0Ajohn%20%3A%3A%20Entry%0Ajohn%20%3D%20%7B%20firstName%3A%20%22John%22%2C%20lastName%3A%20%22Smith%22%2C%20phone%3A%20%22555-555-5555%22%20%7D</code></pre><pre><code class="undefined">fullName%20%3A%3A%20%7B%20firstName%20%3A%3A%20String%2C%20lastName%20%3A%3A%20String%20%7D%20-%3E%20String%0AfullName%20person%20%3D%20person.firstName%20++%20%22%20%22%20++%20person.lastName%0A%0Amain%20%3D%20trace%20%24%20fullName%20john%20%20%20%20%20%20%20--%20John%u306B%u306F%u4F59%u8A08%u306A%u30D5%u30A3%u30FC%u30EB%u30C9phone%u304C%u542B%u307E%u308C%u3066%u3044%u308B%u304B%u3089ERROR</code></pre><p>それに対し、開いたRowにすると余分なフィールドがあっても受け取れます。<code>r</code>にその場に応じて適切な型が補完されると考えるとよいでしょう。この場合、<code>fullName</code>の呼び出しでは型変数<code>r</code>が<code>phone :: String</code>であるとすれば型を一致させることができます。</p><pre><code class="undefined">fullName%20%3A%3A%20forall%20r.%20%7B%20firstName%20%3A%3A%20String%2C%20lastName%20%3A%3A%20String%20%7C%20r%20%7D%20-%3E%20String%20%20---r%20%u3092%u8FFD%u52A0%0AfullName%20person%20%3D%20person.firstName%20++%20%22%20%22%20++%20person.lastName%0A%0Amain%20%3D%20trace%20%24%20fullName%20John%20%20%20%20%20%20%20--%20John%u306B%u306F%u4F59%u8A08%u306A%u30D5%u30A3%u30FC%u30EB%u30C9phone%u304C%u542B%u307E%u308C%u3066%u3044%u308B%u3051%u3069OK</code></pre><p>Row Polymorphismにより、入出力の時にいろんな<code>Eff</code>を混ぜて書くのが楽になります。逆に言えば、<code>Eff</code>を<code>Trace</code>するための<code>Eff</code>、例外を扱うための<code>Eff</code>、乱数を生成するための<code>Eff</code>……という風に細かく分けて定義し、必要に応じて合成させることでより詳細に制御できます。<code>Eff</code>について詳しくは後述します。</p><h3><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>型変数</h3><p>型変数を導入する際 <code>forall</code>は 必須です</p><h3><a name="main" class="anchor" href="#main"><span class="header-link"></span></a>main</h3><p>エントリポイントである <code>main</code> の型は <code>main :: Eff :: # ! -&gt; * -&gt; *</code>というような型です。<code>main</code>で<code>Trace</code>と<code>Random</code>の<code>Eff</code>を混ぜて使いたい時の<code>main</code>の型は次のようになります。</p><pre><code class="undefined">module%20Main%20where%0A%0Aimport%20Prelude%0Aimport%20Control.Monad.Eff%0Aimport%20Control.Monad.Eff.Random%0Aimport%20Debug.Trace%0A%0Amain%20%3A%3A%20Eff%20%28trace%20%3A%3A%20Trace%2C%20random%20%3A%3A%20Random%29%20Unit%0Amain%20%3D%20do%0A%20%20n%20%3C-%20random%0A%20%20print%20n</code></pre><p>もっとも、<code>main</code>の型注釈は書かなくても型推論でたぶんなんとかなります。</p><h3><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>モジュール</h3><p><code>module ... where</code> は必須です。</p><h3><a name="magic-do" class="anchor" href="#magic-do"><span class="header-link"></span></a>magic-do</h3><p><code>do</code>は<code>&gt;&gt;=</code>のシンタックスシュガーですから、</p><pre><code class="hs">do%20trace%20%22hoge%22%0A%20%20%20trace%20%22piyo%22</code></pre><p>のようなコードは<code>&gt;&gt;=</code>の入れ子になってしまいそうですが、<code>Eff</code>はコンパイラが特別扱いしてうまく平坦なコードにして出力してくれます。このmagic-doはコンパイラオプションでオフにすることもできます。magic-doが効くのは<code>Eff</code>だけですから、それ以外の独自のモナドで副作用を記述しようとすると恐ろしいコードが吐かれます（後述）。</p><h3><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>末尾再帰</h3><p>末尾再帰もちゃんと最適化してwhileのループにしてくれますので心配いりません。</p><pre><code class="hs">go%20n%20%3D%20do%0A%20%20print%20n%0A%20%20go%20%28n%20+%201%29%0A%0Amain%20%3D%20go%201</code></pre><pre><code class="js">var%20go%20%3D%20function%20%28__copy_n%29%20%7B%0A%20%20%20%20return%20function%20__do%28%29%20%7B%0A%20%20%20%20%20%20%20%20var%20n%20%3D%20__copy_n%3B%0A%20%20%20%20%20%20%20%20tco%3A%20while%20%28true%29%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20Debug_Trace.print%28Prelude.showNumber%29%28n%29%28%29%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20var%20__tco_n%20%3D%20n%20+%201%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20n%20%3D%20__tco_n%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20continue%20tco%3B%0A%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%7D%3B%0A%7D%3B</code></pre><h3><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>セクション</h3><p>演算子のセクションはありません。演算子を<code>()</code>で囲んで関数にし、<code>(+) 42</code>みたいに書くことはできます。</p><h2><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>ライブラリ編</h2><p><a href="https://github.com/purescript">PureScript</a> や　<a href="https://github.com/purescript-contrib">PureScript Contrib</a>　を覗くといろいろあります。</p><h3><a name="-a-href-https-github-com-purescript-purescript-tree-master-prelude-prelude-a-" class="anchor" href="#-a-href-https-github-com-purescript-purescript-tree-master-prelude-prelude-a-"><span class="header-link"></span></a><a href="https://github.com/purescript/purescript/tree/master/prelude">Prelude</a></h3><p>Preludeに入っているのは本当に基本的なものだけです。<code>Maybe</code>や<code>Either</code>も別モジュールです。ちゃんと<code>Fanctor</code> -&gt; <code>Applicative</code> -&gt; <code>Monad</code> の階層になっていたり、後発なだけあって全体的に整理されてすっきりしている印象です。</p><h4><a name="boolean-number-string" class="anchor" href="#boolean-number-string"><span class="header-link"></span></a>Boolean/Number/String</h4><p><code>Boolean</code>, <code>Number</code>, <code>String</code>がJavaScriptの<code>boolean</code>, <code>number</code>, <code>string</code>にそのまま対応します。<code>Boolean</code>な値は小文字から始まる<code>true</code>と<code>false</code>です。<code>true</code>や<code>false</code>はパターンマッチングでも使えるデータコンストラクタなのに！ふしぎ！</p><h4><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>標準出力</h4><p><code>trace</code>, <code>print</code>がそれぞれHaskellの<code>putStrLn</code>, <code>print</code>に相当します。</p><h4><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>関数合成</h4><p>Haskellのような<code>.</code>による関数合成はできません。関数は<code>Semigroupoid</code>という型クラスのインスタンスがあって、<code>f . g</code> は <code>f &lt;&lt;&lt; g</code>か<code>g &gt;&gt;&gt; f</code>と書きます。</p><h4><a name="unit" class="anchor" href="#unit"><span class="header-link"></span></a>Unit</h4><p>UnitはHaskellのような<code>() :: ()</code>ではなく<code>unit :: Unit</code>です。</p><h3><a name="foreign-function-interface" class="anchor" href="#foreign-function-interface"><span class="header-link"></span></a>Foreign Function Interface</h3><p>PureScriptのFFIは単純で、</p><ul>
<li>PureScriptから呼ぶ関数はカリー化して定義しておく(PureScriptの関数はJavaScriptレベルでもカリー化されて定義されるので、逆にJavaScriptからPureScriptの関数を呼ぶ場合は引数を一つづつ渡す)</li>
<li>Effモナドは単にnullary function</li>
<li>Haskell同様の <code>foreign import &quot; ... &quot; hoge :: Hoge -&gt; Piyo</code> というような構文で呼び出す先の型を定義する</li>
</ul>
<p>というだけです。仕組みは簡単なものの、何しろカリー化しなければならないので愚直に<code>foreign import</code>キーワードを使ってPureScriptからJavaScriptの関数を呼ぶのはとても面倒です。ffiを使う場合は<a href="https://github.com/pelotom/purescript-easy-ffi">purescript-easy-ffi</a>というモジュールを使いましょう。<code>unsafeForeignFunction</code>という関数を呼ぶだけです。</p><pre><code class="undefined">stringify%20%3A%3A%20forall%20a.%20Number%20-%3E%20a%20-%3E%20String%0Astringify%20%3D%20unsafeForeignFunction%20%5B%22n%22%2C%20%22x%22%5D%20%22JSON.stringify%28x%2C%20null%2C%20n%29%22</code></pre><p>purescript-easy-ffiがあれば、 <code>foreign import</code>で直接外部の関数を定義する方法や、<code>Data.Function</code>を組み合わせる方法はほとんど使う必要はないと思います。</p><h6><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>参考</h6><ul>
<li><a href="https://gist.github.com/paf31/8e9177b20ee920480fbc#day-3---purescript-easy-ffi-and-purescript-oo-ffi">24 Days of PureScript | day 3</a></li>
</ul>
<h3><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>例外処理</h3><p>JavaScriptのtry/catchのような<code>Eff</code>まみれの例外処理をしたければ、<a href="https://github.com/purescript/purescript-exceptions"><code>purescript-exceptions</code></a> の <code>Control.Monad.Eff.Exception</code> をインポートします。　<code>error</code>で例外オブジェクトを作り　<code>throwException</code>で投げて<code>catchException</code>で受けとります。</p><pre><code class="undefined">module%20Main%20where%0A%0Aimport%20Prelude%0Aimport%20Control.Monad.Eff%0Aimport%20Debug.Trace%0Aimport%20Control.Monad.Eff.Exception%0A%0Amain%20%3A%3A%20forall%20t.%20Eff%20%28trace%20%3A%3A%20Trace%2C%20ex%20%3A%3A%20Exception%29%20Unit%0Amain%20%3D%20do%0A%20%20%20%20catchException%20%28%5Cerr%20-%3E%20print%20%28message%20err%29%29%20do%0A%20%20%20%20%20%20%20%20print%20%22begin%22%0A%20%20%20%20%20%20%20%20throwException%20%28error%20%22Exception%22%29%0A%20%20%20%20%20%20%20%20print%20%22end%22%20%20%20--%20throwException%20%u3067%u629C%u3051%u308B%u306E%u3067%u3053%u3061%u3089%u306F%u547C%u3070%u308C%u306A%u3044</code></pre><p><code>throwException</code>はJavaScriptレベルでは<code>throw</code>しているだけで、<code>catchException</code>も<code>try-catch</code>で捕まえているだけです。</p><h3><a name="st-" class="anchor" href="#st-"><span class="header-link"></span></a>STモナド</h3><p><code>ST</code>モナドを<code>runPure</code>/<code>runST</code>で走らせた場合は、コンパイラが特別に処理してくれてただの変数になります</p><pre><code class="undefined">collatz%20%3A%3A%20Number%20-%3E%20Number%0Acollatz%20n%20%3D%20runPure%20%28runST%20%28do%0A%20%20r%20%3C-%20newSTRef%20n%0A%20%20count%20%3C-%20newSTRef%200%0A%20%20untilE%20%24%20do%0A%20%20%20%20modifySTRef%20count%20%24%20%28+%29%201%0A%20%20%20%20m%20%3C-%20readSTRef%20r%0A%20%20%20%20writeSTRef%20r%20%24%20if%20m%20%25%202%20%3D%3D%200%20then%20m%20/%202%20else%203%20*%20m%20+%201%0A%20%20%20%20return%20%24%20m%20%3D%3D%201%0A%20%20readSTRef%20count%29%29</code></pre><pre><code class="undefined">var%20collatz%20%3D%20function%20%28n%29%20%7B%0A%20%20%20%20%20%20%20%20return%20Control_Monad_Eff.runPure%28function%20__do%28%29%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20var%20_60%20%3D%20n%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20var%20_59%20%3D%200%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%28function%20%28%29%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20while%20%28%21%28function%20__do%28%29%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20_59%20%3D%201%20+%20_59%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20var%20_58%20%3D%20_60%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20_60%20%3D%20_58%20%25%202%20%3D%3D%3D%200%20%3F%20_58%20/%202%20%3A%203%20*%20_58%20+%201%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20_58%20%3D%3D%3D%201%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%29%28%29%29%20%7B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%7B%7D%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%29%28%29%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20_59%3B%0A%20%20%20%20%20%20%20%20%7D%29%3B%0A%20%20%20%20%7D%3B</code></pre><p>ただし、以下のように<code>ST</code>を他の<code>Eff</code>と混ぜて使った場合は普通にいろんな関数呼び出しにコンパイルされてました。残念。</p><pre><code class="undefined">main%20%3A%3A%20forall%20a%20.%20Eff%20%28trace%20%3A%3A%20Trace%2C%20random%20%3A%3A%20Random%2C%20st%20%3A%3A%20ST%20a%29%20Unit%0Amain%20%3D%20do%0A%20%20x%20%3C-%20newSTRef%200%0A%20%20forE%200%20100%20%24%20%5Ci%20-%3E%20do%0A%20%20%20%20n%20%3C-%20random%0A%20%20%20%20modifySTRef%20x%20%24%20%28+%29%20n%0A%20%20%20%20return%20unit%0A%20%20readSTRef%20x%20%3E%3E%3D%20print</code></pre><h3><a name="canvas-free-" class="anchor" href="#canvas-free-"><span class="header-link"></span></a>CanvasとFreeモナド</h3><p>ブラウザ環境でCanvasに描くためのバインディング<a href="https://github.com/purescript-contrib/purescript-canvas">Graphics.Canvas</a>もあります。ゲームを作ったりするときに役に立ちそうです。</p><p>CanvasのFreeモナド版<a href="https://github.com/paf31/purescript-free-canvas">Graphics.Canvas.Free</a>もあるみたいです。Freeモナドじゃないほうの生の<code>Graphics.Canvas</code>で書こうとすると</p><pre><code class="undefined">context%20%3C-%20getContext2D%20canvas%0Adimensions%20%3C-%20getCanvasDimensions%20canvas%0AclearRect%20context%20%7B%20x%3A0%2C%20y%3A0%2C%20w%3Adimensions.width%2C%20h%3Adimensions.height%20%7D%0Asave%20context%0AsetLineWidth%202%20context%0AsetShadowOffsetX%201%20context%0AsetShadowOffsetY%201%20context%0A...</code></pre><p>みたいにひたすら<code>context</code>に付きまとわれるCanvasの描画コマンド群が、Freeモナドを使うと<code>context</code>が消えて次のようにすっきり書くことができます。</p><pre><code class="undefined">context%20%3C-%20getContext2D%20canvas%0Adimensions%20%3C-%20getCanvasDimensions%20canvas%0AclearRect%20context%20%7B%20x%3A0%2C%20y%3A0%2C%20w%3Adimensions.width%2C%20h%3Adimensions.height%20%7D%0ArunGraphics%20context%20%24%20do%0A%20%20%20%20save%0A%20%20%20%20setLineWidth%202%0A%20%20%20%20setShadowOffsetX%201%0A%20%20%20%20setShadowOffsetY%201%0A%20%20%20%20...</code></pre><p><code>Graphics.Canvas</code>だけを使って<code>Eff</code>モナドで書けばmagic-doのおかげで以下のようなシンプルなJavaScriptを吐いてくれるのですが、</p><pre><code class="js">Graphics_Canvas.save%28_53%29%28%29%3B%0AGraphics_Canvas.setLineWidth%282%29%28_53%29%28%29%3B%0AGraphics_Canvas.setShadowOffsetX%281%29%28_53%29%28%29%3B%0AGraphics_Canvas.setShadowOffsetY%281%29%28_53%29%28%29%3B%0AGraphics_Canvas.setShadowColor%28%22%23808080%22%29%28_53%29%28%29%3B%0AGraphics_Canvas.setStrokeStyle%28%22%23FF8000%22%29%28_53%29%28%29%3B%0A....</code></pre><p><code>Graphics.Canvas.Free</code>を使うと、以下の様な恐ろしいコードを吐いてきます。</p><pre><code class="js">return%20Graphics_Canvas_Free.runGraphics%28_55%29%28Prelude%5B%22%3E%3E%3D%22%5D%28Control_Monad_Free.bindFree%28Data_Coyoneda.functorCoyoneda%29%29%28Graphics_Canvas_Free.save%29%28function%20%28%29%20%7B%0A%20%20%20%20return%20Prelude%5B%22%3E%3E%3D%22%5D%28Control_Monad_Free.bindFree%28Data_Coyoneda.functorCoyoneda%29%29%28Graphics_Canvas_Free.setLineWidth%282%29%29%28function%20%28%29%20%7B%0A%20%20%20%20%20%20%20%20return%20Prelude%5B%22%3E%3E%3D%22%5D%28Control_Monad_Free.bindFree%28Data_Coyoneda.functorCoyoneda%29%29%28Graphics_Canvas_Free.setShadowOffsetX%281%29%29%28function%20%28%29%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20Prelude%5B%22%3E%3E%3D%22%5D%28Control_Monad_Free.bindFree%28Data_Coyoneda.functorCoyoneda%29%29%28Graphics_Canvas_Free.setShadowOffsetY%281%29%29%28function%20%28%29%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20Prelude%5B%22%3E%3E%3D%22%5D%28Control_Monad_Free.bindFree%28Data_Coyoneda.functorCoyoneda%29%29%28Graphics_Canvas_Free.setShadowColor%28%22%23808080%22%29%29%28function%20%28%29%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20Prelude%5B%22%3E%3E%3D%22%5D%28Control_Monad_Free.bindFree%28Data_Coyoneda.functorCoyoneda%29%29%28Graphics_Canvas_Free.setStrokeStyle%28%22%23FF8000%22%29%29%28function%20%28%29%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20Prelude%5B%22%3E%3E%3D%22%5D%28Control_Monad_Free.bindFree%28Data_Coyoneda.functorCoyoneda%29%29%28Graphics_Canvas_Free.translate%2820%29%2820%29%29%28function%20%28%29%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20Prelude%5B%22%3E%3E%3D%22%5D%28Control_Monad_Free.bindFree%28Data_Coyoneda.functorCoyoneda%29%29%28Graphics_Canvas_Free.scale%282.0%29%281.5%29%29%28function%20%28%29%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20Prelude%5B%22%3E%3E%3D%22%5D%28Control_Monad_Free.bindFree%28Data_Coyoneda.functorCoyoneda%29%29%28Graphics_Canvas_Free.rotate%28state.rotation%29%29%28function%20%28%29%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20....</code></pre><p>１回きりの描画ならこれでも構わないのですが、ゲームみたいに頻繁に画面を更新するアプリケーションだとさすがにちょっと心配です。</p><h2><a name="-see-also" class="anchor" href="#-see-also"><span class="header-link"></span></a>参考文献というかSee Also</h2><p>まともにPureScriptに取り組む気があるなら、<strong>&quot;PureScript by Example&quot;</strong> と <strong>&quot;24 Days of PureScript&quot;</strong> は必須です。それ以外はお好みに応じてどうぞ。</p><ul>
<li><p><strong><a href="https://github.com/purescript/purescript/wiki">purescript/wiki</a></strong> とりあえずWikiがいろんな情報の入口です</p></li>
<li><p><strong><a href="https://leanpub.com/purescript/">PureScript by Example</a> PureScript開発者本人によって書かれたチュートリアルで、これさえ読めばPureScriptについてはだいたいすべてわかります。開発環境のインストールの方法から関数型言語の基礎的な概念まで丁寧に説明されており、PureScriptの入門に最適だろうと思います。主にJavaScriptのユーザ向けに書かれており、Haskellのような言語に通じていなくても読むことができます(というか、Haskellに通じている人ならすでに知っている内容のほうが多いかもしれません)。</strong> <del>長いので筆者はまだ全部は読んでませんが、十分な量がある充実したテキストなのでそのうち全部目を通そうと思います。</del> 読んだので邦訳しました。読んでください → <strong><a href="f1e048fc9a8ca51eddb2.html">関数型なAltJS、PureScriptの入門書を邦訳しました。</a></strong></p></li>
<li><p><strong><a href="https://gist.github.com/paf31/8e9177b20ee920480fbc">24 Days of PureScript</a></strong> PureScriptをいじろうと思うなら絶対に目を通しておくべき記事その２</p></li>
<li><p><a href="https://github.com/purescript/purescript/wiki/Handling-Native-Effects-with-the-Eff-Monad">Handling Native Effects with the Eff Monad</a> 入出力はHaskellとだいぶ違います。</p></li>
<li><a href="http://curtis.io/posts/purescript-for-web-development.html">Getting Started with Purescript for Web Development</a> &quot;PureScript by Example&quot;のサンプルコードはNode上で動かすものが多いですが、この記事はブラウザ環境で動かす方法。といってもビルドの方法がちょっと違ったりブラウザ環境専用のモジュールが必要になるだけの話です。</li>
<li><a href="http://pursuit.purescript.org/">pursuit</a> - PureScriptのドキュメント検索エンジン。Hoogleみたいなアレ</li>
</ul>
<h2><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>参考になりそうな小さめのプロジェクト</h2><p>とりあえず筆者も何かゲームでも作ってみようと思うので、PureScriptで書かれたゲームのデモを幾つか：</p><ul>
<li><a href="https://github.com/waterson/purescript-asteroids/">purescript-asteroids</a> アステロイド。DOMでイベントリスナを登録してSTを書き換えてというベタな方法で書かれている</li>
<li><a href="https://github.com/bodil/purescript-is-magic/">purescript-is-magic</a>　マイリトルポニーをジャンプさせてTroll Faceを避けるゲーム。purescript-signalでリアクティブに書かれている</li>
<li><a href="https://github.com/michaelficarra/purescript-demo-mario">purescript-demo-mario</a> purescript-signalでマリオがジャンプするデモ。これもpurescript-signal</li>
</ul>
<h2><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>材料</h2><ul>
<li><a href="https://github.com/aktowns/purescript-simple-dom">purescript-simple-dom</a> 基本的なDOMの操作はひと通り揃っているみたいです。別に<a href="https://github.com/purescript-contrib/purescript-dom/">purescript-dom</a> (<code>DOM</code>) というモジュールもありますが、そちらはすっからかん</li>
<li><a href="https://github.com/purescript-contrib/purescript-canvas">purescript-canvas</a>　Canvasへの描画。まだ<code>drawImage</code>すらなくて辛い</li>
</ul>
<h2><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>感想</h2><p>PureScriptは筆者が長年追い求めていた理想のAltJSに限りなく近い。すごい。</p><h2><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>さいごに</h2><p>そのうちPureScriptで何か作ってみようと思います。いろいろわかり次第また追記するつもりです。</p></div></article></div><footer><div class="sns"><a target="_blank" href="https://twitter.com/intent/tweet?text=undefined%20https%3A%2F%2Faratama.github.io%2Fblog%2F2ff1891c2afdb90d9f2e"><img src="/res/twitter.png"></a><a target="brank" href="http://www.facebook.com/sharer.php?u=https%3A%2F%2Faratama.github.io%2Fblog%2F2ff1891c2afdb90d9f2e&amp;t=undefined"><img src="/res/facebook.png"></a><a target="brank" href="https://plus.google.com/share?url=https%3A%2F%2Faratama.github.io%2Fblog%2F2ff1891c2afdb90d9f2e"><img src="/res/google.png"></a><a target="brank" href="http://b.hatena.ne.jp/entry/https%3A%2F%2Faratama.github.io%2Fblog%2F2ff1891c2afdb90d9f2e"><img src="/res/hatena.png"></a><a target="brank" href="http://getpocket.com/edit?url=https%3A%2F%2Faratama.github.io%2Fblog%2F2ff1891c2afdb90d9f2e&amp;title=undefined"><img src="/res/pocket.png"></a></div><div class="block-centered footer-inner"><p class="copy">&amp;nbsp;</p><p class="author">このブログを書いてる人: 竹内稲穂</p></div><script>
                    const poem = [
                        "なんにもない毎日が、なによりの宝物。",
                        "今日という日を、何度でも繰り返したい。",
                        "世界を追いかけなくても、世界は私のまわりにある。", 
                        "速すぎる雑踏。鼻先をくすぐる春風。", 
                        "明日撮る写真を飾る場所を、アルバムに空けておこう。", 
                        "落ち葉が地面に、触れる音がした。", 
                        "明日は、明日の楽しさが待っている。", 
                        "風が泣いている。この想いを紡ぐ言葉を持たないから。", 
                        "もうここには何もない。だから、次の場所に旅立とう。", 
                        "もう此処にはこないだろう。そう言って私は過去に背を向けた。", 
                        "散りゆくからこそ、美しい。私は桜の花びらをかかとで踏みしめた。", 
                        "思い出はいつだって輝いてる。",
                        "正直ばかりじゃつまらない。たまには楽しい嘘をつこう。", 
                        "ゆっくり歩けば歩くほど、時間がゆっくり過ぎてゆく。",
                        "夜明けを、探しにいこう。", 
                        "空はこんなに青かったんだ。", 
                        "地球は青かった。それはこの空を見上げたことのある全員が知っている。", 
                        "休み時間は、長すぎるということはない。", 
                        "缶コーヒーを飲むときだけは、それ以外のすべてを忘れることにしてる。", 
                        "ちょっと小さいのは確かですが、それは確かにここにあります。", 
                        "ちょっと小さいのは確かですが、広すぎる家というのも寂しいでしょう？", 
                        "ひつじが一匹、ひつじが二匹。五十匹までは、数えたことがある。"
                    ];
                    document.querySelector(".copy").textContent = poem[Math.floor(poem.length * Math.random())];
                </script></footer></body></html>