<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@cubbit2"><meta name="twitter:creator" content="@cubbit2"><meta name="twitter:title" content="『先にヘッダを送信してから、そのあとでレスポンスボディを送信しなくてはならない』ことをコンパイル時に検証する - ちょっと小さいのはたしかですが。"><meta name="twitter:description" content="Admittedly something small."><meta name="twitter:image" content="https://aratama.github.io/3c3b376d-5c80-47c6-58b9-23d264453a65.png"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="icon.png"><link rel="stylesheet" href="/res/reset.css"><link rel="stylesheet" href="/res/style.css"><title>『先にヘッダを送信してから、そのあとでレスポンスボディを送信しなくてはならない』ことをコンパイル時に検証する - ちょっと小さいのはたしかですが。</title><script>
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-61162129-3', 'auto');
                ga('send', 'pageview');
            </script></head><body><header><div class="sns"><a target="_blank" href="https://twitter.com/intent/tweet?text=%E3%81%A1%E3%82%87%E3%81%A3%E3%81%A8%E5%B0%8F%E3%81%95%E3%81%84%E3%81%AE%E3%81%AF%E3%81%9F%E3%81%97%E3%81%8B%E3%81%A7%E3%81%99%E3%81%8C%E3%80%82%20https%3A%2F%2Faratama.github.io%2Fblog%2F9e37a6bb6b6b3c9a59e4"><img src="/res/twitter.png"></a><a target="_brank" href="http://www.facebook.com/sharer.php?u=https%3A%2F%2Faratama.github.io%2Fblog%2F9e37a6bb6b6b3c9a59e4&amp;t=%E3%81%A1%E3%82%87%E3%81%A3%E3%81%A8%E5%B0%8F%E3%81%95%E3%81%84%E3%81%AE%E3%81%AF%E3%81%9F%E3%81%97%E3%81%8B%E3%81%A7%E3%81%99%E3%81%8C%E3%80%82"><img src="/res/facebook.png"></a><a target="_brank" href="https://plus.google.com/share?url=https%3A%2F%2Faratama.github.io%2Fblog%2F9e37a6bb6b6b3c9a59e4"><img src="/res/google.png"></a><a target="_brank" href="http://b.hatena.ne.jp/entry/https%3A%2F%2Faratama.github.io%2Fblog%2F9e37a6bb6b6b3c9a59e4"><img src="/res/hatena.png"></a><a target="_brank" href="http://getpocket.com/edit?url=https%3A%2F%2Faratama.github.io%2Fblog%2F9e37a6bb6b6b3c9a59e4&amp;title=%E3%81%A1%E3%82%87%E3%81%A3%E3%81%A8%E5%B0%8F%E3%81%95%E3%81%84%E3%81%AE%E3%81%AF%E3%81%9F%E3%81%97%E3%81%8B%E3%81%A7%E3%81%99%E3%81%8C%E3%80%82&quot;"><img src="/res/pocket.png"></a></div><div class="block-centered"><div class="site-title"><a href="/">Admittedly <wbr>something <wbr>small.</a></div><div class="sub-title">ちょっと<wbr>小さいのは<wbr>たしかですが。</div></div></header><div class="content"><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/res/article.css"><article id="rendered"><div class="date">2017年4月22日</div><h1 class="article-title"><a href=".">『先にヘッダを送信してから、そのあとでレスポンスボディを送信しなくてはならない』ことをコンパイル時に検証する</a></h1><p class="tags"><a href="/blog/tag/JavaScript"><span class="tag"><i class="fa fa-tag"></i>JavaScript</span></a><a href="/blog/tag/Node"><span class="tag"><i class="fa fa-tag"></i>Node</span></a><a href="/blog/tag/Node.js"><span class="tag"><i class="fa fa-tag"></i>Node.js</span></a><a href="/blog/tag/purescript"><span class="tag"><i class="fa fa-tag"></i>purescript</span></a><a href="/blog/tag/hyper"><span class="tag"><i class="fa fa-tag"></i>hyper</span></a></p><hr><div><p><a href="3c3b376d-5c80-47c6-58b9-23d264453a65.png"><img src="3c3b376d-5c80-47c6-58b9-23d264453a65.png"></img></a></p><h1><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>動機</h1><p>Nodeで簡単なサーバサイドアプリケーションを作ることを考えてみます。</p><pre><code class="js">const%20http%20%3D%20require%28%27http%27%29%3B%0A%0Aconst%20hostname%20%3D%20%27127.0.0.1%27%3B%0Aconst%20port%20%3D%203000%3B%0A%0Aconst%20server%20%3D%20http.createServer%28%28req%2C%20res%29%20%3D%3E%20%7B%0A%20%20res.statusCode%20%3D%20200%3B%0A%20%20res.setHeader%28%27Content-Type%27%2C%20%27text/plain%27%29%3B%0A%20%20res.write%28%27Hello%20World%5Cn%27%29%3B%0A%20%20res.end%28%29%3B%0A%7D%29%3B%0A%0Aserver.listen%28port%2C%20hostname%2C%20%28%29%20%3D%3E%20%7B%0A%20%20console.log%28%60Server%20running%20at%20http%3A//%24%7Bhostname%7D%3A%24%7Bport%7D/%60%29%3B%0A%7D%29%3B</code></pre><p>このコードが何をやっているかは明白ですし、Nodeを知らない人でもなんとなく見当がつくでしょう。さて、HTTPのレスポンスというのは、最初にステータス行、それからヘッダが続いて、最後にレスポンスボディの順で送信するプロトコルで、例えば次のような内容になっています。</p><pre><code class="undefined">HTTP/1.0%20200%20OK%0AContent-Type%3A%20text/plain%0A%0AHello%20World</code></pre><p>そういうプロトコルなので、レスポンスボディを送信したあとにヘッダを送信することはできません。たとえば、コードを次のように変更してみます。</p><pre><code class="js">%20%20res.write%28%27Hello%20World%5Cn%27%29%3B%0A%20%20res.statusCode%20%3D%20200%3B%0A%20%20res.setHeader%28%27Content-Type%27%2C%20%27text/plain%27%29%3B%0A%20%20res.end%28%29%3B</code></pre><p>変更後のコードでは、<code>write</code>でレスポンスボディを書いたあとに、<code>setHeader</code>でヘッダを書き込んでいます。これを実行すると、実行時例外でサーバはお亡くなりになります。</p><pre><code class="undefined">http_outgoing.js%3A371%0A%20%20%20%20throw%20new%20Error%28%27Can%5C%27t%20set%20headers%20after%20they%20are%20sent.%27%29%3B%0A%20%20%20%20%5E%0A%0AError%3A%20Can%27t%20set%20headers%20after%20they%20are%20sent.%0A%20%20%20%20at%20ServerResponse.setHeader%20%28_http_outgoing.js%3A371%3A11%29%0A%20%20%20%20at%20Server.http.createServer%20%28C%3A%5Cdev%5Cnodehttptest%5Ctest.js%3A9%3A7%29%0A%20%20%20%20at%20emitTwo%20%28events.js%3A106%3A13%29%0A%20%20%20%20at%20Server.emit%20%28events.js%3A194%3A7%29%0A%20%20%20%20at%20parserOnIncoming%20%28_http_server.js%3A563%3A12%29%0A%20%20%20%20at%20HTTPParser.parserOnHeadersComplete%20%28_http_common.js%3A99%3A23%29</code></pre><p>なので、<code>setHeader</code>は<code>write</code>よりも手前に書くように気をつけましょう。</p><p><br></p><p><br></p><p><br></p><p><strong>……何が「気をつけましょう」だよ！アホか！「気をつけましょう」なんていう心がけで本当にミスを防げたら誰も苦労しねーよ！</strong>『自動車のアクセルとブレーキを踏み間違えないようにしましょう』とか呼びかければ不幸な事故が減るとでも思ってるのか！？それに、ミスは不注意な人とか知識に乏しい人だけがするものではありません。疲労や寝不足で頭がおかしくなって訳のわからないコードを書くことは誰にでもあります。頻繁な変更が入り複雑怪奇に成り果てたコードからは、単純なミスでもそう簡単に見つけられるものではありません。ミスに対する有効な対策とは、「気をつけましょう」とかそういう心がけじゃなくて、機械がミスを発見して自動的に報告する機構を用意することでしょう。</p><p>そこで、<a href="https://hyper.wickstrom.tech/"><strong>Hyper</strong></a>というウェブサーバサイドフレームワークの手法を簡単に紹介します。<code>Hyper</code>は、『ヘッダを書き終えてからレスポンスボディを書く』という条件が満たされているかを、<strong>コンパイル時に</strong>検証してくれます。</p><h1><a name="hyper-" class="anchor" href="#hyper-"><span class="header-link"></span></a>Hyperによる解決</h1><p>HyperによるHelloWorldは、例えば次のようになります。PureScriptのコードですし、コードの詳細は気にしなくていいです。フィーリングで読んでください<a class="link-footnote" href="#footnote-anno" name="link-anno">※</a>。</p><pre><code class="haskell">main%20%3D%20runServer%20defaultOptionsWithLogging%20%7B%7D%20do%20%0A%20%20%20%20writeStatus%20statusOK%0A%20%20%20%20contentType%20textPlain%0A%20%20%20%20closeHeaders%0A%20%20%20%20toResponse%20%22Hello%2C%20Hyper%21%22%20%3A%3E%3E%3D%20send%0A%20%20%20%20end</code></pre><p><code>writeStatus statusOK</code>はNodeの<code>res.statusCode = 200</code>に相当する操作ですし、<code>contentType textPlain</code>は<code>res.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;)</code>に対応してます。それで、このコードはもちろん正常にコンパイルすることができますが、このコードを次のように書き換えてみます。</p><pre><code class="haskell">main%20%3D%20runServer%20defaultOptionsWithLogging%20%7B%7D%20do%20%0A%20%20%20%20toResponse%20%22Hello%2C%20Hyper%21%22%20%3A%3E%3E%3D%20send%0A%20%20%20%20writeStatus%20statusOK%0A%20%20%20%20contentType%20textPlain%0A%20%20%20%20closeHeaders%0A%20%20%20%20end</code></pre><p>つまり、<code>send</code>でレスポンスボディを送ってから、<code>writeStatus</code>でステータスを書き込んでしまうというミスをしているわけです。これは明らかに間違いですが、これをコンパイルしようとすると、コンパイラは次のようなエラーメッセージを吐きます。この種のミスをコンパイラが発見して、事故を未然に防いでくれているのです。</p><pre><code class="undefined">Error%20found%3A%0Ain%20module%20Main%0Aat%20src%5CMain.purs%20line%2015%2C%20column%2013%20-%20line%2019%2C%20column%2016%0A%0A%20%20Could%20not%20match%20type%0A%0A%20%20%20%20StatusLineOpen%0A%0A%20%20with%20type%0A%0A%20%20%20%20BodyOpen%0A%0A%0Awhile%20trying%20to%20match%20type%20t6%20StatusLineOpen%0A%20%20with%20type%20t2%20BodyOpen%0Awhile%20checking%20that%20expression%20writeStatus%20statusOK%0A%20%20has%20type%20Middleware%20t0%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%20request%20%3A%3A%20t1%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%2C%20response%20%3A%3A%20t2%20BodyOpen%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%2C%20components%20%3A%3A%20t3%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20t4%0A%20%20%20%20%20%20%20%20%20%20%20%20%20t5%0Ain%20value%20declaration%20main</code></pre><p>エラーメッセージの言っていることは一見意味不明ですが、よくよく見てみるとこれは<strong>ただの型エラー</strong>だったりします。コンパイラが何か特別な静的解析を働かせているとか、そういうことではありません。<code>Could not match type StatusLineOpen with type BodyOpen</code>とあるように、コンパイラが言っているのは、関数に与えた引数の型<code>StatusLineOpen</code>が、関数が求めている型<code>BodyOpen</code>に合わない、というだけの話です。原理的にはそれだけなのですが、この型エラーの詳細について理解するには<strong>Indexed Monad</strong>という仕組みを学ばなくてはならず、話が長くなるので止めときます。またモナドかよ！</p><p>今回書いたコードはgistに載せておきました。</p><ul>
<li><a href="https://gist.github.com/aratama/1b3b9a2c1672f4ecfdf4183820cef28e">https://gist.github.com/aratama/1b3b9a2c1672f4ecfdf4183820cef28e</a></li>
</ul>
<h1><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>さいごに</h1><p>「こんな瑣末な落とし穴、書くときに気をつければ簡単に回避できるだろ」と思ったひともいるでしょう。このヘッダの順序の問題と、Indexed Monadなどという抽象的な機能を学ぶコストを天秤にかけて、「学習コストに見合わない」というふうに考える人もいるような気がします。</p><p>たしかにこの落とし穴だけについて考えれば、そうだと思います。でも問題は、<strong>現実のコードにはこういう些細な落とし穴が山ほど隠れている</strong>ということです。PureScriptのような言語を使っている人たちは、個々の落とし穴が瑣末であるからといって、その落とし穴を軽視して放置したりはしません。なぜなら、そうやって見逃されてきた単純な落とし穴も、いずれ寄り集まって複雑さを増し、やがて厄介なトラブルを山ほど生み出すとわかっているからです。些細な落とし穴だからこそ、PureScriptのような言語はそれを見逃さずに根本的な対処を与えて、そういう下らない問題で開発者の頭のなかがいっぱいにならないようにしてくれます。コンパイラがそういう下らないミスを開発者の代わりに検出してくれるからこそ、開発者は本来の問題に集中できるのです。</p><p><strong>プログラミング上のありとあらゆる落とし穴を可能な限りコンパイル時に検出する</strong>のが、PureScriptのような言語やHyperのようなフレームワークが目指すところです。PureScriptやHyperのような道具は詳細を追い始めるとやはり複雑なところはあるのですが、それは今まで個々の開発者が神経をすり減らして『気をつけて』いたことを、Hyperのようなフレームワークが代わりに『気をつけて』くれるようになった結果です。決して闇雲に複雑にしているわけではありません。ほかにも、「どうせ実行時エラーが出るのだから、コンパイルエラーにする必要はないのでは」と思う人もいるでしょうが……そういうことを説明し出すと、また話が長(略</p><p>今回は敢えて技術的詳細の説明を控えました。どうしても詳細を知りたければ、Hyperや<a href="https://github.com/garyb/purescript-indexed-monad">purescript-indexed-monad</a>のコードを眺めてみるといいかもしれません。ただし、今回紹介したHyperの手法を他の『普通の』プログラミング言語で実現することはまず不可能です。関数型プログラミングのテクニックを覚えて一般的なプログラミング言語で役立てるというのは、関数型プログラミングの初歩の初歩を齧っただけの人（しかも初歩しか齧っていないのに自分は関数型プログラミング全体を把握したと思い込んでいる人）が抱きがちな幻想です。HaskellやPureScript、Scalaのような本格的な関数型プログラミング言語へ移行して安全な世界で気楽に暮らすか、JavaやJavaScriptのような『普通の』プログラミング言語のまま落とし穴と隣り合わせに生きるか、どちらかしかありません。</p><p>Hyperはまだあまりに若いフレームワークですが、その方向性はPureScriptが目指しているところとぴったり一致していますし、今も活発に開発が続いていて有望なフレームワークだと思います。PureScriptの本格的なウェブサーバサイドフレームワークは、まだ片手で数えるほどしかありません。もっとPureScriptのユーザが増えて、こういう安全なフレームワークがたくさん育ってほしいと、筆者は願うところであります。</p><h1><a name="-" class="anchor" href="#-"><span class="header-link"></span></a>参考文献</h1><ul>
<li><a href="https://hyper.wickstrom.tech/">hyper.wickstrom.tech</a> Hyperの公式サイト。ロゴが可愛い</li>
</ul>
<hr>
<p class="footnote"><a href="#link-anno" name="footnote-anno">^</a>  本当はもっと短く書くこともできますが、先ほどのJavaScriptでの例と対応させる感じにあえて冗長に書いています。また、インポートリストとか型注釈が長すぎるので、本質的なコードだけを抜粋してます。</p></div></article></div><footer><div class="sns"><a target="_blank" href="https://twitter.com/intent/tweet?text=%E3%81%A1%E3%82%87%E3%81%A3%E3%81%A8%E5%B0%8F%E3%81%95%E3%81%84%E3%81%AE%E3%81%AF%E3%81%9F%E3%81%97%E3%81%8B%E3%81%A7%E3%81%99%E3%81%8C%E3%80%82%20https%3A%2F%2Faratama.github.io%2Fblog%2F9e37a6bb6b6b3c9a59e4"><img src="/res/twitter.png"></a><a target="_brank" href="http://www.facebook.com/sharer.php?u=https%3A%2F%2Faratama.github.io%2Fblog%2F9e37a6bb6b6b3c9a59e4&amp;t=%E3%81%A1%E3%82%87%E3%81%A3%E3%81%A8%E5%B0%8F%E3%81%95%E3%81%84%E3%81%AE%E3%81%AF%E3%81%9F%E3%81%97%E3%81%8B%E3%81%A7%E3%81%99%E3%81%8C%E3%80%82"><img src="/res/facebook.png"></a><a target="_brank" href="https://plus.google.com/share?url=https%3A%2F%2Faratama.github.io%2Fblog%2F9e37a6bb6b6b3c9a59e4"><img src="/res/google.png"></a><a target="_brank" href="http://b.hatena.ne.jp/entry/https%3A%2F%2Faratama.github.io%2Fblog%2F9e37a6bb6b6b3c9a59e4"><img src="/res/hatena.png"></a><a target="_brank" href="http://getpocket.com/edit?url=https%3A%2F%2Faratama.github.io%2Fblog%2F9e37a6bb6b6b3c9a59e4&amp;title=%E3%81%A1%E3%82%87%E3%81%A3%E3%81%A8%E5%B0%8F%E3%81%95%E3%81%84%E3%81%AE%E3%81%AF%E3%81%9F%E3%81%97%E3%81%8B%E3%81%A7%E3%81%99%E3%81%8C%E3%80%82&quot;"><img src="/res/pocket.png"></a></div><div class="block-centered footer-inner"><p class="copy">&amp;nbsp;</p><p class="author">このブログを書いてる人: 竹内稲穂</p></div><script>
                    const poem = [
                        "なんにもない毎日が、なによりの宝物。",
                        "今日という日を、何度でも繰り返したい。",
                        "世界を追いかけなくても、世界は私のまわりにある。", 
                        "速すぎる雑踏。鼻先をくすぐる春風。", 
                        "明日撮る写真を飾る場所を、アルバムに空けておこう。", 
                        "落ち葉が地面に、触れる音がした。", 
                        "明日は、明日の楽しさが待っている。", 
                        "風が泣いている。この想いを紡ぐ言葉を持たないから。", 
                        "もうここには何もない。だから、次の場所に旅立とう。", 
                        "もう此処にはこないだろう。そう言って私は過去に背を向けた。", 
                        "散りゆくからこそ、美しい。私は桜の花びらをかかとで踏みしめた。", 
                        "思い出はいつだって輝いてる。",
                        "正直ばかりじゃつまらない。たまには楽しい嘘をつこう。", 
                        "ゆっくり歩けば歩くほど、時間がゆっくり過ぎてゆく。",
                        "夜明けを、探しにいこう。", 
                        "空はこんなに青かったんだ。", 
                        "地球は青かった。それはこの空を見上げたことのある全員が知っている。", 
                        "休み時間は、長すぎるということはない。", 
                        "缶コーヒーを飲むときだけは、それ以外のすべてを忘れることにしてる。", 
                        "ちょっと小さいのは確かですが、それは確かにここにあります。", 
                        "ちょっと小さいのは確かですが、広すぎる家というのも寂しいでしょう？", 
                        "ひつじが一匹、ひつじが二匹。五十匹までは、数えたことがある。"
                    ];
                    document.querySelector(".copy").textContent = poem[Math.floor(poem.length * Math.random())];
                </script></footer></body></html>